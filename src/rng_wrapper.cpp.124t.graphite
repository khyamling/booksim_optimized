
;; Function void ran_array(long int*, int) (_Z9ran_arrayPli.constprop.0, funcdef_no=36, decl_uid=3763, cgraph_uid=35, symbol_order=43)


Pass statistics:
----------------

void ran_array(long int*, int) (long intD.12 * aaD.3773)
{
  register intD.9 iD.3774;
  register intD.9 jD.3775;
  intD.9 nD.3772;
  long unsigned intD.14 _2;
  long unsigned intD.14 _3;
  long intD.12 * _5;
  long intD.12 _6;
  long unsigned intD.14 _9;
  long unsigned intD.14 _10;
  long intD.12 * _11;
  sizetype _12;
  long intD.12 * _13;
  long intD.12 _14;
  sizetype _15;
  long intD.12 * _16;
  long intD.12 _17;
  long intD.12 _18;
  long intD.12 _19;
  long unsigned intD.14 _23;
  long unsigned intD.14 _24;
  sizetype _25;
  long intD.12 * _26;
  long intD.12 _27;
  sizetype _28;
  long intD.12 * _29;
  long intD.12 _30;
  long intD.12 _31;
  long intD.12 _32;
  long unsigned intD.14 _37;
  long unsigned intD.14 _38;
  sizetype _39;
  long intD.12 * _40;
  long intD.12 _41;
  intD.9 _42;
  long intD.12 _43;
  long intD.12 _44;
  long intD.12 _45;

;;   basic block 2, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY [100.0%]  (FALLTHRU,EXECUTABLE)
  # DEBUG nD.3772 => 1009
  # DEBUG jD.3775 => 0
;;    succ:       3 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 3, loop depth 1, count 0, freq 9900, maybe hot
;;    prev block 2, next block 4, flags: (NEW, REACHABLE)
;;    pred:       4 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                2 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 100] NONZERO 127
  # j_75 = PHI <j_7(4), 0(2)>
  # .MEM_81 = PHI <.MEM_58(4), .MEM_57(D)(2)>
  # DEBUG jD.3775 => j_75
  # RANGE [0, 99] NONZERO 127
  _2 = (long unsigned intD.14) j_75;
  # RANGE [0, 792] NONZERO 1016
  _3 = _2 * 8;
  # PT = nonlocal 
  _5 = aa_4(D) + _3;
  # VUSE <.MEM_81>
  _6 = ran_xD.2818[j_75];
  # .MEM_58 = VDEF <.MEM_81>
  *_5 = _6;
  # RANGE [1, 100] NONZERO 127
  j_7 = j_75 + 1;
  # DEBUG jD.3775 => j_7
  # DEBUG jD.3775 => j_7
  if (j_7 == 100)
    goto <bb 5>;
  else
    goto <bb 4>;
;;    succ:       5 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                4 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 4, loop depth 1, count 0, freq 9800, maybe hot
;;    prev block 3, next block 5, flags: (NEW)
;;    pred:       3 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 5, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 4, next block 6, flags: (NEW)
;;    pred:       3 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;    succ:       6 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 6, loop depth 1, count 0, freq 1011, maybe hot
;;    prev block 5, next block 7, flags: (NEW, REACHABLE)
;;    pred:       5 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                7 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [100, 2147483646] NONZERO 1023
  # j_76 = PHI <100(5), j_20(7)>
  # .MEM_82 = PHI <.MEM_58(5), .MEM_59(7)>
  # DEBUG jD.3775 => j_76
  # RANGE [100, 1008] NONZERO 1023
  _9 = (long unsigned intD.14) j_76;
  # RANGE [800, 8064] NONZERO 8184
  _10 = _9 * 8;
  # PT = nonlocal 
  _11 = aa_4(D) + _10;
  # RANGE [0, 7264] NONZERO 8184
  _12 = _10 + 18446744073709550816;
  # PT = nonlocal 
  _13 = aa_4(D) + _12;
  # VUSE <.MEM_82>
  _14 = *_13;
  # RANGE [504, 7768] NONZERO 8184
  _15 = _10 + 18446744073709551320;
  # PT = nonlocal 
  _16 = aa_4(D) + _15;
  # VUSE <.MEM_82>
  _17 = *_16;
  _18 = _14 - _17;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _19 = _18 & 1073741823;
  # .MEM_59 = VDEF <.MEM_82>
  *_11 = _19;
  # RANGE [101, 1009] NONZERO 1023
  j_20 = j_76 + 1;
  # DEBUG jD.3775 => j_20
  # DEBUG jD.3775 => j_20
  if (j_20 > 1008)
    goto <bb 8>;
  else
    goto <bb 7>;
;;    succ:       8 [9.9%]  (TRUE_VALUE,EXECUTABLE)
;;                7 [90.1%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 7, loop depth 1, count 0, freq 911, maybe hot
;;    prev block 6, next block 8, flags: (NEW)
;;    pred:       6 [90.1%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 6>;
;;    succ:       6 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 8, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 7, next block 9, flags: (NEW)
;;    pred:       6 [9.9%]  (TRUE_VALUE,EXECUTABLE)
;;    succ:       9 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 9, loop depth 1, count 0, freq 3702, maybe hot
;;    prev block 8, next block 10, flags: (NEW, REACHABLE)
;;    pred:       8 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                10 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [0, 37] NONZERO 63
  # i_77 = PHI <0(8), i_33(10)>
  # RANGE [1009, 2147483647] NONZERO 2147483647
  # j_78 = PHI <1009(8), j_34(10)>
  # .MEM_83 = PHI <.MEM_59(8), .MEM_60(10)>
  # DEBUG jD.3775 => j_78
  # DEBUG iD.3774 => i_77
  # RANGE [0, 18446744073709551615] NONZERO 2147483647
  _23 = (long unsigned intD.14) j_78;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _24 = _23 * 8;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _25 = _24 + 18446744073709550816;
  # PT = nonlocal 
  _26 = aa_4(D) + _25;
  # VUSE <.MEM_83>
  _27 = *_26;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _28 = _24 + 18446744073709551320;
  # PT = nonlocal 
  _29 = aa_4(D) + _28;
  # VUSE <.MEM_83>
  _30 = *_29;
  _31 = _27 - _30;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _32 = _31 & 1073741823;
  # .MEM_60 = VDEF <.MEM_83>
  ran_xD.2818[i_77] = _32;
  # RANGE [1, 37] NONZERO 63
  i_33 = i_77 + 1;
  # DEBUG iD.3774 => i_33
  # RANGE [1010, 2147483647] NONZERO 2147483647
  j_34 = j_78 + 1;
  # DEBUG jD.3775 => j_34
  # DEBUG jD.3775 => j_34
  # DEBUG iD.3774 => i_33
  if (i_33 == 37)
    goto <bb 11>;
  else
    goto <bb 10>;
;;    succ:       11 [2.7%]  (TRUE_VALUE,EXECUTABLE)
;;                10 [97.3%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 10, loop depth 1, count 0, freq 3602, maybe hot
;;    prev block 9, next block 11, flags: (NEW)
;;    pred:       9 [97.3%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 9>;
;;    succ:       9 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 11, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 10, next block 12, flags: (NEW)
;;    pred:       9 [2.7%]  (TRUE_VALUE,EXECUTABLE)
;;    succ:       12 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 12, loop depth 1, count 0, freq 9900, maybe hot
;;    prev block 11, next block 13, flags: (NEW, REACHABLE)
;;    pred:       11 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                13 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [37, 137] NONZERO 127
  # i_79 = PHI <37(11), i_46(13)>
  # RANGE [1009, 2147483647] NONZERO 2147483647
  # j_80 = PHI <1046(11), j_47(13)>
  # .MEM_84 = PHI <.MEM_60(11), .MEM_61(13)>
  # DEBUG jD.3775 => j_80
  # DEBUG iD.3774 => i_79
  # RANGE [0, 18446744073709551615] NONZERO 2147483647
  _37 = (long unsigned intD.14) j_80;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _38 = _37 * 8;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _39 = _38 + 18446744073709550816;
  # PT = nonlocal 
  _40 = aa_4(D) + _39;
  # VUSE <.MEM_84>
  _41 = *_40;
  # RANGE [0, 62] NONZERO 63
  _42 = i_79 + -37;
  # VUSE <.MEM_84>
  _43 = ran_xD.2818[_42];
  _44 = _41 - _43;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _45 = _44 & 1073741823;
  # .MEM_61 = VDEF <.MEM_84>
  ran_xD.2818[i_79] = _45;
  # RANGE [38, 100] NONZERO 127
  i_46 = i_79 + 1;
  # DEBUG iD.3774 => i_46
  # RANGE [1010, 2147483647] NONZERO 2147483647
  j_47 = j_80 + 1;
  # DEBUG jD.3775 => j_47
  # DEBUG jD.3775 => j_47
  # DEBUG iD.3774 => i_46
  if (i_46 > 99)
    goto <bb 14>;
  else
    goto <bb 13>;
;;    succ:       14 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                13 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 13, loop depth 1, count 0, freq 9800, maybe hot
;;    prev block 12, next block 14, flags: (NEW)
;;    pred:       12 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 12>;
;;    succ:       12 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 14, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 13, next block 1, flags: (NEW, REACHABLE)
;;    pred:       12 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # VUSE <.MEM_61>
  return;
;;    succ:       EXIT [100.0%] 

}


Creating dr for ran_x[j_75]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for ran_x[j_75]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for *_5
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_4
Creating dr for *_5
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_4
Creating dr for ran_x[j_75]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for ran_x[j_75]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for *_5
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_4
Creating dr for *_5
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_4
Analyzing # of iterations of loop 4
  exit condition [1, + , 1](no_overflow) != 100
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
Analyzing # of iterations of loop 4
  exit condition [1, + , 1](no_overflow) != 100
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
Creating dr for *_13
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_3
Creating dr for *_13
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_3
Creating dr for *_16
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {504B, +, 8}_3
Creating dr for *_16
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {504B, +, 8}_3
Creating dr for *_11
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {800B, +, 8}_3
Creating dr for *_11
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {800B, +, 8}_3
Creating dr for *_13
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_3
Creating dr for *_13
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_3
Creating dr for *_16
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {504B, +, 8}_3
Creating dr for *_16
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {504B, +, 8}_3
Creating dr for *_11
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {800B, +, 8}_3
Creating dr for *_11
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {800B, +, 8}_3
Analyzing # of iterations of loop 3
  exit condition [101, + , 1](no_overflow) <= 1008
  bounds on difference of bases: 907 ... 907
  result:
    # of iterations 908, bounded by 908
Analyzing # of iterations of loop 3
  exit condition [101, + , 1](no_overflow) <= 1008
  bounds on difference of bases: 907 ... 907
  result:
    # of iterations 908, bounded by 908
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7272
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7272B, +, 8}_2
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7272
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7272B, +, 8}_2
Creating dr for *_29
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7776
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7776B, +, 8}_2
Creating dr for *_29
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7776
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7776B, +, 8}_2
Creating dr for ran_x[i_77]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_2
Creating dr for ran_x[i_77]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_2
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7272
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7272B, +, 8}_2
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7272
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7272B, +, 8}_2
Creating dr for *_29
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7776
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7776B, +, 8}_2
Creating dr for *_29
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7776
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7776B, +, 8}_2
Creating dr for ran_x[i_77]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_2
Creating dr for ran_x[i_77]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_2
Analyzing # of iterations of loop 2
  exit condition [1, + , 1](no_overflow) != 37
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Analyzing # of iterations of loop 2
  exit condition [1, + , 1](no_overflow) != 37
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Creating dr for *_40
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7568
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7568B, +, 8}_1
Creating dr for *_40
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7568
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7568B, +, 8}_1
Creating dr for ran_x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_1
Creating dr for ran_x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_1
Creating dr for ran_x[i_79]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_1
Creating dr for ran_x[i_79]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_1
Creating dr for *_40
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7568
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7568B, +, 8}_1
Creating dr for *_40
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7568
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7568B, +, 8}_1
Creating dr for ran_x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_1
Creating dr for ran_x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_1
Creating dr for ran_x[i_79]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_1
Creating dr for ran_x[i_79]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_1
Analyzing # of iterations of loop 1
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62
Analyzing # of iterations of loop 1
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62

Before limit_scops SCoP statistics (BBS:17, LOOPS:4, CONDITIONS:4, STMTS:69)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

number of SCoPs: 4

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:17)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:20)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:19)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:10)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Global statistics (BBS:19, LOOPS:4, CONDITIONS:4, STMTS:69)

Global profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)
Creating dr for *_13
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_3
Creating dr for *_16
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {504B, +, 8}_3
Creating dr for *_11
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {800B, +, 8}_3

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 908; c1 += 1)
  S_6(c1);


Removing basic block 24
basic block 24, loop depth 0
 pred:      
goto <bb 22>;
 succ:       22



Updating SSA:
Registering new PHI nodes in block #21
Registering new PHI nodes in block #23
Registering new PHI nodes in block #6
Updating SSA information for statement *_11 = _19;
Registering new PHI nodes in block #7
Registering new PHI nodes in block #8
Registering new PHI nodes in block #22
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #17
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #16
Registering new PHI nodes in block #12
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15

DFA Statistics for void ran_array(long int*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                             80        640b
DEF operands                             40        320b
VUSE operands                            12         96b
VDEF operands                             4         32b
PHI nodes                                11       1144b
PHI arguments                            22       1056b
---------------------------------------------------------
Total memory used by DFA/SSA data                 3288b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_104 -> { .MEM_59 }
Incremental SSA update started at block: 21
Number of blocks in CFG: 25
Number of blocks to update: 8 ( 32%)
Affected blocks: 6 7 8 9 17 21 22 23


Applying pattern match.pd:397, generic-match.c:4039
Applying pattern match.pd:397, generic-match.c:4039

Updating SSA:
creating PHI node in block #26 for .MEM
creating PHI node in block #29 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #3
Updating SSA information for statement _6 = ran_x[j_75];
Updating SSA information for statement *_5 = _6;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #18
Registering new PHI nodes in block #21
Registering new PHI nodes in block #25
Registering new PHI nodes in block #29
Registering new PHI nodes in block #33
Updating SSA information for statement _101 = *_98;
Updating SSA information for statement _97 = *_93;
Updating SSA information for statement _92 = _101 - _97;
Updating SSA information for statement _91 = _92 & 1073741823;
Updating SSA information for statement *_86 = _91;
Registering new PHI nodes in block #31
Registering new PHI nodes in block #30
Registering new PHI nodes in block #32
Registering new PHI nodes in block #27
Registering new PHI nodes in block #28
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #6
Updating SSA information for statement _14 = *_13;
Updating SSA information for statement _17 = *_16;
Updating SSA information for statement _18 = _14 - _17;
Updating SSA information for statement _19 = _18 & 1073741823;
Updating SSA information for statement *_11 = _19;
Registering new PHI nodes in block #7
Registering new PHI nodes in block #8
Registering new PHI nodes in block #22
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #17
Registering new PHI nodes in block #9
Updating SSA information for statement _27 = *_26;
Updating SSA information for statement _30 = *_29;
Updating SSA information for statement ran_x[i_77] = _32;
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #16
Registering new PHI nodes in block #12
Updating SSA information for statement _41 = *_40;
Updating SSA information for statement _43 = ran_x[_42];
Updating SSA information for statement ran_x[i_79] = _45;
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Updating SSA information for statement return;

DFA Statistics for void ran_array(long int*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            103        824b
DEF operands                             56        448b
VUSE operands                            15        120b
VDEF operands                             5         40b
PHI nodes                                14       1456b
PHI arguments                            28       1344b
---------------------------------------------------------
Total memory used by DFA/SSA data                 4232b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_90 -> { .MEM_59 }
_91 -> { _19 }
_92 -> { _18 }
_97 -> { _17 }
_101 -> { _14 }

Symbols to be put in SSA form
{ D.3771 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 34
Number of blocks to update: 32 ( 94%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 31 32 33



0 loops carried no dependency.
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7272
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7272B, +, 8}_2
Creating dr for *_29
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7776
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7776B, +, 8}_2
Creating dr for ran_x[i_77]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_2
Analyzing # of iterations of loop 2
  exit condition [1, + , 1](no_overflow) != 37
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 36; c1 += 1)
  S_9(c1);


Removing basic block 39
basic block 39, loop depth 0
 pred:      
goto <bb 37>;
 succ:       37



Updating SSA:
Registering new PHI nodes in block #36
Registering new PHI nodes in block #38
Registering new PHI nodes in block #9
Updating SSA information for statement ran_x[i_77] = _32;
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #37
Registering new PHI nodes in block #35
Registering new PHI nodes in block #34
Registering new PHI nodes in block #16
Registering new PHI nodes in block #12
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15

DFA Statistics for void ran_array(long int*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            103        824b
DEF operands                             56        448b
VUSE operands                            15        120b
VDEF operands                             5         40b
PHI nodes                                15       1560b
PHI arguments                            30       1440b
---------------------------------------------------------
Total memory used by DFA/SSA data                 4432b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_69 -> { .MEM_60 }
Incremental SSA update started at block: 36
Number of blocks in CFG: 40
Number of blocks to update: 8 ( 20%)
Affected blocks: 9 10 11 12 16 36 37 38


Applying pattern match.pd:397, generic-match.c:4039
Applying pattern match.pd:397, generic-match.c:4039

Updating SSA:
creating PHI node in block #41 for .MEM
creating PHI node in block #44 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #3
Updating SSA information for statement _6 = ran_x[j_75];
Updating SSA information for statement *_5 = _6;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #18
Registering new PHI nodes in block #21
Registering new PHI nodes in block #25
Registering new PHI nodes in block #29
Registering new PHI nodes in block #33
Updating SSA information for statement _101 = *_98;
Updating SSA information for statement _97 = *_93;
Updating SSA information for statement *_86 = _91;
Registering new PHI nodes in block #31
Registering new PHI nodes in block #30
Registering new PHI nodes in block #32
Registering new PHI nodes in block #27
Registering new PHI nodes in block #28
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #6
Updating SSA information for statement _14 = *_13;
Updating SSA information for statement _17 = *_16;
Updating SSA information for statement *_11 = _19;
Registering new PHI nodes in block #7
Registering new PHI nodes in block #8
Registering new PHI nodes in block #22
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #17
Registering new PHI nodes in block #36
Registering new PHI nodes in block #40
Registering new PHI nodes in block #44
Registering new PHI nodes in block #48
Updating SSA information for statement _66 = *_62;
Updating SSA information for statement _56 = *_52;
Updating SSA information for statement _51 = _66 - _56;
Updating SSA information for statement _50 = _51 & 1073741823;
Updating SSA information for statement ran_x[_48] = _50;
Registering new PHI nodes in block #46
Registering new PHI nodes in block #45
Registering new PHI nodes in block #47
Registering new PHI nodes in block #42
Registering new PHI nodes in block #43
Registering new PHI nodes in block #41
Registering new PHI nodes in block #38
Registering new PHI nodes in block #9
Updating SSA information for statement _27 = *_26;
Updating SSA information for statement _30 = *_29;
Updating SSA information for statement _31 = _27 - _30;
Updating SSA information for statement _32 = _31 & 1073741823;
Updating SSA information for statement ran_x[i_77] = _32;
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #37
Registering new PHI nodes in block #35
Registering new PHI nodes in block #34
Registering new PHI nodes in block #16
Registering new PHI nodes in block #12
Updating SSA information for statement _41 = *_40;
Updating SSA information for statement _43 = ran_x[_42];
Updating SSA information for statement ran_x[i_79] = _45;
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Updating SSA information for statement return;

DFA Statistics for void ran_array(long int*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            123        984b
DEF operands                             70        560b
VUSE operands                            18        144b
VDEF operands                             6         48b
PHI nodes                                18       1872b
PHI arguments                            36       1728b
---------------------------------------------------------
Total memory used by DFA/SSA data                 5336b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_49 -> { .MEM_60 }
_50 -> { _32 }
_51 -> { _31 }
_56 -> { _30 }
_66 -> { _27 }

Symbols to be put in SSA form
{ D.3771 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 49
Number of blocks to update: 46 ( 94%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 31 32 33 34 35 36 37 38 40 41 42 43 44 45 46 47 48



1 loops carried no dependency.
Creating dr for *_40
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7568
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7568B, +, 8}_1
Creating dr for ran_x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_1
Creating dr for ran_x[i_79]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_1
Analyzing # of iterations of loop 1
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 62; c1 += 1)
  S_12(c1);


Removing basic block 54
basic block 54, loop depth 0
 pred:      
goto <bb 52>;
 succ:       52



Updating SSA:
Registering new PHI nodes in block #51
Registering new PHI nodes in block #53
Registering new PHI nodes in block #12
Updating SSA information for statement ran_x[i_79] = _45;
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #52
Registering new PHI nodes in block #50
Registering new PHI nodes in block #49
Registering new PHI nodes in block #15
Updating SSA information for statement return;

DFA Statistics for void ran_array(long int*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            123        984b
DEF operands                             70        560b
VUSE operands                            18        144b
VDEF operands                             6         48b
PHI nodes                                19       1976b
PHI arguments                            38       1824b
---------------------------------------------------------
Total memory used by DFA/SSA data                 5536b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_128 -> { .MEM_61 }
Incremental SSA update started at block: 51
Number of blocks in CFG: 55
Number of blocks to update: 7 ( 13%)
Affected blocks: 12 13 14 15 51 52 53


Applying pattern match.pd:397, generic-match.c:4039

Updating SSA:
creating PHI node in block #56 for .MEM
creating PHI node in block #59 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #3
Updating SSA information for statement _6 = ran_x[j_75];
Updating SSA information for statement *_5 = _6;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #18
Registering new PHI nodes in block #21
Registering new PHI nodes in block #25
Registering new PHI nodes in block #29
Registering new PHI nodes in block #33
Updating SSA information for statement _101 = *_98;
Updating SSA information for statement _97 = *_93;
Updating SSA information for statement *_86 = _91;
Registering new PHI nodes in block #31
Registering new PHI nodes in block #30
Registering new PHI nodes in block #32
Registering new PHI nodes in block #27
Registering new PHI nodes in block #28
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #6
Updating SSA information for statement _14 = *_13;
Updating SSA information for statement _17 = *_16;
Updating SSA information for statement *_11 = _19;
Registering new PHI nodes in block #7
Registering new PHI nodes in block #8
Registering new PHI nodes in block #22
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #17
Registering new PHI nodes in block #36
Registering new PHI nodes in block #40
Registering new PHI nodes in block #44
Registering new PHI nodes in block #48
Updating SSA information for statement _66 = *_62;
Updating SSA information for statement _56 = *_52;
Updating SSA information for statement ran_x[_48] = _50;
Registering new PHI nodes in block #46
Registering new PHI nodes in block #45
Registering new PHI nodes in block #47
Registering new PHI nodes in block #42
Registering new PHI nodes in block #43
Registering new PHI nodes in block #41
Registering new PHI nodes in block #38
Registering new PHI nodes in block #9
Updating SSA information for statement _27 = *_26;
Updating SSA information for statement _30 = *_29;
Updating SSA information for statement ran_x[i_77] = _32;
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #37
Registering new PHI nodes in block #35
Registering new PHI nodes in block #34
Registering new PHI nodes in block #16
Registering new PHI nodes in block #51
Registering new PHI nodes in block #55
Registering new PHI nodes in block #59
Registering new PHI nodes in block #63
Updating SSA information for statement _123 = *_119;
Updating SSA information for statement _118 = ran_x[_117];
Updating SSA information for statement _116 = _123 - _118;
Updating SSA information for statement _115 = _116 & 1073741823;
Updating SSA information for statement ran_x[_112] = _115;
Registering new PHI nodes in block #61
Registering new PHI nodes in block #60
Registering new PHI nodes in block #62
Registering new PHI nodes in block #57
Registering new PHI nodes in block #58
Registering new PHI nodes in block #56
Registering new PHI nodes in block #53
Registering new PHI nodes in block #12
Updating SSA information for statement _41 = *_40;
Updating SSA information for statement _43 = ran_x[_42];
Updating SSA information for statement _44 = _41 - _43;
Updating SSA information for statement _45 = _44 & 1073741823;
Updating SSA information for statement ran_x[i_79] = _45;
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #52
Registering new PHI nodes in block #50
Registering new PHI nodes in block #49
Registering new PHI nodes in block #15
Updating SSA information for statement return;

DFA Statistics for void ran_array(long int*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            140       1120b
DEF operands                             82        656b
VUSE operands                            21        168b
VDEF operands                             7         56b
PHI nodes                                22       2288b
PHI arguments                            44       2112b
---------------------------------------------------------
Total memory used by DFA/SSA data                 6400b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_114 -> { .MEM_61 }
_115 -> { _45 }
_116 -> { _44 }
_118 -> { _43 }
_123 -> { _41 }

Symbols to be put in SSA form
{ D.3771 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 64
Number of blocks to update: 60 ( 94%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 31 32 33 34 35 36 37 38 40 41 42 43 44 45 46 47 48 49 50 51 52 53 55 56 57 58 59 60 61 62 63



1 loops carried no dependency.
Creating dr for ran_x[j_75]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for *_5
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_4
Analyzing # of iterations of loop 4
  exit condition [1, + , 1](no_overflow) != 100
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 99; c1 += 1)
  S_3(c1);


Removing basic block 69
basic block 69, loop depth 0
 pred:      
goto <bb 67>;
 succ:       67



Updating SSA:
Registering new PHI nodes in block #66
Registering new PHI nodes in block #68
Registering new PHI nodes in block #3
Updating SSA information for statement *_5 = _6;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #67
Registering new PHI nodes in block #65
Registering new PHI nodes in block #64
Registering new PHI nodes in block #18
Registering new PHI nodes in block #21
Registering new PHI nodes in block #25
Registering new PHI nodes in block #29
Registering new PHI nodes in block #33
Registering new PHI nodes in block #31
Registering new PHI nodes in block #30
Registering new PHI nodes in block #32
Registering new PHI nodes in block #27
Registering new PHI nodes in block #28
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #6
Registering new PHI nodes in block #7
Registering new PHI nodes in block #8
Registering new PHI nodes in block #22
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #17
Registering new PHI nodes in block #36
Registering new PHI nodes in block #40
Registering new PHI nodes in block #44
Registering new PHI nodes in block #48
Registering new PHI nodes in block #46
Registering new PHI nodes in block #45
Registering new PHI nodes in block #47
Registering new PHI nodes in block #42
Registering new PHI nodes in block #43
Registering new PHI nodes in block #41
Registering new PHI nodes in block #38
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #37
Registering new PHI nodes in block #35
Registering new PHI nodes in block #34
Registering new PHI nodes in block #16
Registering new PHI nodes in block #51
Registering new PHI nodes in block #55
Registering new PHI nodes in block #59
Registering new PHI nodes in block #63
Registering new PHI nodes in block #61
Registering new PHI nodes in block #60
Registering new PHI nodes in block #62
Registering new PHI nodes in block #57
Registering new PHI nodes in block #58
Registering new PHI nodes in block #56
Registering new PHI nodes in block #53
Registering new PHI nodes in block #12
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #52
Registering new PHI nodes in block #50
Registering new PHI nodes in block #49
Registering new PHI nodes in block #15

DFA Statistics for void ran_array(long int*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            140       1120b
DEF operands                             82        656b
VUSE operands                            21        168b
VDEF operands                             7         56b
PHI nodes                                23       2392b
PHI arguments                            46       2208b
---------------------------------------------------------
Total memory used by DFA/SSA data                 6600b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_106 -> { .MEM_58 }
Incremental SSA update started at block: 66
Number of blocks in CFG: 70
Number of blocks to update: 12 ( 17%)
Affected blocks: 3 4 5 6 21 25 26 28 29 66 67 68



Updating SSA:
creating PHI node in block #71 for .MEM
creating PHI node in block #74 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #66
Registering new PHI nodes in block #70
Registering new PHI nodes in block #74
Registering new PHI nodes in block #78
Updating SSA information for statement _130 = ran_x[_131];
Updating SSA information for statement *_135 = _130;
Registering new PHI nodes in block #76
Registering new PHI nodes in block #75
Registering new PHI nodes in block #77
Registering new PHI nodes in block #72
Registering new PHI nodes in block #73
Registering new PHI nodes in block #71
Registering new PHI nodes in block #68
Registering new PHI nodes in block #3
Updating SSA information for statement _6 = ran_x[j_75];
Updating SSA information for statement *_5 = _6;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #67
Registering new PHI nodes in block #65
Registering new PHI nodes in block #64
Registering new PHI nodes in block #18
Registering new PHI nodes in block #21
Registering new PHI nodes in block #25
Registering new PHI nodes in block #29
Registering new PHI nodes in block #33
Updating SSA information for statement _101 = *_98;
Updating SSA information for statement _97 = *_93;
Updating SSA information for statement *_86 = _91;
Registering new PHI nodes in block #31
Registering new PHI nodes in block #30
Registering new PHI nodes in block #32
Registering new PHI nodes in block #27
Registering new PHI nodes in block #28
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #6
Updating SSA information for statement _14 = *_13;
Updating SSA information for statement _17 = *_16;
Updating SSA information for statement *_11 = _19;
Registering new PHI nodes in block #7
Registering new PHI nodes in block #8
Registering new PHI nodes in block #22
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #17
Registering new PHI nodes in block #36
Registering new PHI nodes in block #40
Registering new PHI nodes in block #44
Registering new PHI nodes in block #48
Updating SSA information for statement _66 = *_62;
Updating SSA information for statement _56 = *_52;
Updating SSA information for statement ran_x[_48] = _50;
Registering new PHI nodes in block #46
Registering new PHI nodes in block #45
Registering new PHI nodes in block #47
Registering new PHI nodes in block #42
Registering new PHI nodes in block #43
Registering new PHI nodes in block #41
Registering new PHI nodes in block #38
Registering new PHI nodes in block #9
Updating SSA information for statement _27 = *_26;
Updating SSA information for statement _30 = *_29;
Updating SSA information for statement ran_x[i_77] = _32;
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #37
Registering new PHI nodes in block #35
Registering new PHI nodes in block #34
Registering new PHI nodes in block #16
Registering new PHI nodes in block #51
Registering new PHI nodes in block #55
Registering new PHI nodes in block #59
Registering new PHI nodes in block #63
Updating SSA information for statement _123 = *_119;
Updating SSA information for statement _118 = ran_x[_117];
Updating SSA information for statement ran_x[_112] = _115;
Registering new PHI nodes in block #61
Registering new PHI nodes in block #60
Registering new PHI nodes in block #62
Registering new PHI nodes in block #57
Registering new PHI nodes in block #58
Registering new PHI nodes in block #56
Registering new PHI nodes in block #53
Registering new PHI nodes in block #12
Updating SSA information for statement _41 = *_40;
Updating SSA information for statement _43 = ran_x[_42];
Updating SSA information for statement ran_x[i_79] = _45;
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #52
Registering new PHI nodes in block #50
Registering new PHI nodes in block #49
Registering new PHI nodes in block #15
Updating SSA information for statement return;

DFA Statistics for void ran_array(long int*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            150       1200b
DEF operands                             88        704b
VUSE operands                            23        184b
VDEF operands                             8         64b
PHI nodes                                26       2704b
PHI arguments                            52       2496b
---------------------------------------------------------
Total memory used by DFA/SSA data                 7352b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

_130 -> { _6 }
.MEM_132 -> { .MEM_58 }

Symbols to be put in SSA form
{ D.3771 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 79
Number of blocks to update: 74 ( 94%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 31 32 33 34 35 36 37 38 40 41 42 43 44 45 46 47 48 49 50 51 52 53 55 56 57 58 59 60 61 62 63 64 65 66 67 68 70 71 72 73 74 75 76 77 78



1 loops carried no dependency.
Merging blocks 2 and 66
Removing basic block 5
basic block 5, loop depth 0
 pred:      
goto <bb 67>;
 succ:       67


Removing basic block 8
basic block 8, loop depth 0
 pred:      
goto <bb 22>;
 succ:       22


Removing basic block 11
basic block 11, loop depth 0
 pred:      
goto <bb 37>;
 succ:       37


Removing basic block 14
basic block 14, loop depth 0
 pred:      
goto <bb 52>;
 succ:       52


Removing basic block 16
basic block 16, loop depth 0
 pred:      
 succ:       51


Removing basic block 17
basic block 17, loop depth 0
 pred:      
 succ:       36


Removing basic block 18
basic block 18, loop depth 0
 pred:      
 succ:       21


Removing basic block 19
basic block 19, loop depth 0
 pred:      
 succ:       36


Removing basic block 20
basic block 20, loop depth 0
 pred:      
goto <bb 36>;
 succ:       36


Removing basic block 7
basic block 7, loop depth 1
 pred:       6
goto <bb 6>;
 succ:       6


Removing basic block 6
basic block 6, loop depth 1
 pred:       21
# j_76 = PHI <100(21)>
# DEBUG j => j_76
_9 = (long unsigned int) j_76;
_10 = _9 * 8;
_11 = aa_4(D) + _10;
_12 = _10 + 18446744073709550816;
_13 = aa_4(D) + _12;
_14 = *_13;
_15 = _10 + 18446744073709551320;
_16 = aa_4(D) + _15;
_17 = *_16;
_18 = _14 - _17;
_19 = _18 & 1073741823;
*_11 = _19;
j_20 = j_76 + 1;
# DEBUG j => j_20
# DEBUG j => j_20
if (j_20 > 1008)
 succ:       22


Removing basic block 21
basic block 21, loop depth 0
 pred:      
 succ:       25


Removing basic block 23
basic block 23, loop depth 0
 pred:      
 succ:       22


Removing basic block 28
basic block 28, loop depth 0
 pred:       25
goto <bb 26>;
 succ:       26


Removing basic block 27
basic block 27, loop depth 0
 pred:      
 succ:       26


Merging blocks 29 and 33
Removing basic block 32
basic block 32, loop depth 0
 pred:      
 succ:       26


Removing basic block 34
basic block 34, loop depth 0
 pred:      
 succ:       51


Removing basic block 35
basic block 35, loop depth 0
 pred:      
goto <bb 51>;
 succ:       51


Removing basic block 10
basic block 10, loop depth 1
 pred:       9
goto <bb 9>;
 succ:       9


Removing basic block 9
basic block 9, loop depth 1
 pred:       36
# i_77 = PHI <0(36)>
# j_78 = PHI <1009(36)>
# DEBUG j => j_78
# DEBUG i => i_77
_23 = (long unsigned int) j_78;
_24 = _23 * 8;
_25 = _24 + 18446744073709550816;
_26 = aa_4(D) + _25;
_27 = *_26;
_28 = _24 + 18446744073709551320;
_29 = aa_4(D) + _28;
_30 = *_29;
_31 = _27 - _30;
_32 = _31 & 1073741823;
ran_x[i_77] = _32;
i_33 = i_77 + 1;
# DEBUG i => i_33
j_34 = j_78 + 1;
# DEBUG j => j_34
# DEBUG j => j_34
# DEBUG i => i_33
if (i_33 == 37)
 succ:       37


Removing basic block 36
basic block 36, loop depth 0
 pred:      
 succ:       40


Removing basic block 38
basic block 38, loop depth 0
 pred:      
 succ:       37


Removing basic block 43
basic block 43, loop depth 0
 pred:       40
goto <bb 41>;
 succ:       41


Removing basic block 42
basic block 42, loop depth 0
 pred:      
 succ:       41


Merging blocks 44 and 48
Removing basic block 47
basic block 47, loop depth 0
 pred:      
 succ:       41


Removing basic block 49
basic block 49, loop depth 0
 pred:      
 succ:       15


Removing basic block 50
basic block 50, loop depth 0
 pred:      
goto <bb 15>;
 succ:       15


Removing basic block 13
basic block 13, loop depth 1
 pred:       12
goto <bb 12>;
 succ:       12


Removing basic block 12
basic block 12, loop depth 1
 pred:       51
# i_79 = PHI <37(51)>
# j_80 = PHI <1046(51)>
# DEBUG j => j_80
# DEBUG i => i_79
_37 = (long unsigned int) j_80;
_38 = _37 * 8;
_39 = _38 + 18446744073709550816;
_40 = aa_4(D) + _39;
_41 = *_40;
_42 = i_79 + -37;
_43 = ran_x[_42];
_44 = _41 - _43;
_45 = _44 & 1073741823;
ran_x[i_79] = _45;
i_46 = i_79 + 1;
# DEBUG i => i_46
j_47 = j_80 + 1;
# DEBUG j => j_47
# DEBUG j => j_47
# DEBUG i => i_46
if (i_46 > 99)
 succ:       52


Removing basic block 51
basic block 51, loop depth 0
 pred:      
 succ:       55


Removing basic block 53
basic block 53, loop depth 0
 pred:      
 succ:       52


Removing basic block 58
basic block 58, loop depth 0
 pred:       55
goto <bb 56>;
 succ:       56


Removing basic block 57
basic block 57, loop depth 0
 pred:      
 succ:       56


Merging blocks 59 and 63
Removing basic block 62
basic block 62, loop depth 0
 pred:      
 succ:       56


Removing basic block 64
basic block 64, loop depth 0
 pred:      
 succ:       25


Removing basic block 65
basic block 65, loop depth 0
 pred:      
goto <bb 25>;
 succ:       25


Merging blocks 67 and 25
Removing basic block 68
basic block 68, loop depth 0
 pred:      
 succ:       67


Removing basic block 73
basic block 73, loop depth 0
 pred:       70
goto <bb 71>;
 succ:       71


Removing basic block 72
basic block 72, loop depth 0
 pred:      
 succ:       71


Merging blocks 74 and 78
Removing basic block 77
basic block 77, loop depth 0
 pred:      
 succ:       71


Removing basic block 4
basic block 4, loop depth 1
 pred:       3
goto <bb 3>;
 succ:       3


Removing basic block 3
basic block 3, loop depth 1
 pred:       2
# j_75 = PHI <0(2)>
# DEBUG j => j_75
_2 = (long unsigned int) j_75;
_3 = _2 * 8;
_5 = aa_4(D) + _3;
_6 = ran_x[j_75];
*_5 = _6;
j_7 = j_75 + 1;
# DEBUG j => j_7
# DEBUG j => j_7
if (j_7 == 100)
 succ:       67


Merging blocks 2 and 70
Merging blocks 26 and 22
Merging blocks 26 and 40
Merging blocks 29 and 31
Merging blocks 41 and 37
Merging blocks 41 and 55
Merging blocks 44 and 46
Merging blocks 56 and 52
Merging blocks 56 and 15
Merging blocks 59 and 61
Merging blocks 71 and 67
Merging blocks 74 and 76
fix_loop_structure: removing loop 1
fix_loop_structure: removing loop 2
fix_loop_structure: removing loop 3
fix_loop_structure: removing loop 4
Analyzing # of iterations of loop 7
  exit condition [0, + , 1](no_overflow) < 62
  bounds on difference of bases: 62 ... 62
  result:
    # of iterations 62, bounded by 62
Analyzing # of iterations of loop 6
  exit condition [0, + , 1](no_overflow) < 36
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Analyzing # of iterations of loop 5
  exit condition [0, + , 1](no_overflow) < 908
  bounds on difference of bases: 908 ... 908
  result:
    # of iterations 908, bounded by 908
Analyzing # of iterations of loop 8
  exit condition [0, + , 1](no_overflow) < 99
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
1 edges in bb 2 predicted to even probabilities
Predictions for bb 3
  DS theory heuristics (ignored): 99.0%
  first match heuristics: 99.0%
  combined heuristics: 99.0%
  loop iterations heuristics: 99.0%
1 edges in bb 4 predicted to even probabilities
1 edges in bb 5 predicted to even probabilities
Predictions for bb 6
  DS theory heuristics (ignored): 99.0%
  first match heuristics: 99.0%
  combined heuristics: 99.0%
  loop iterations heuristics: 99.0%
1 edges in bb 7 predicted to even probabilities
1 edges in bb 8 predicted to even probabilities
Predictions for bb 9
  DS theory heuristics (ignored): 97.3%
  first match heuristics: 97.3%
  combined heuristics: 97.3%
  loop iterations heuristics: 97.3%
1 edges in bb 10 predicted to even probabilities
1 edges in bb 11 predicted to even probabilities
Predictions for bb 12
  DS theory heuristics (ignored): 99.0%
  first match heuristics: 98.4%
  combined heuristics: 98.4%
  early return (on trees) heuristics (ignored): 61.0%
  loop iterations heuristics: 98.4%
1 edges in bb 13 predicted to even probabilities
1 edges in bb 14 predicted to even probabilities
loop_0 (header = 0, latch = 1, niter = )
{
  bb_2 (preds = {bb_0 }, succs = {bb_3 })
  {
    <bb 2>:
    # DEBUG n => 1009
    # DEBUG j => 0

  }
  bb_5 (preds = {bb_3 }, succs = {bb_6 })
  {
    <bb 5>:
    # .MEM_136 = PHI <.MEM_132(3)>

  }
  bb_8 (preds = {bb_6 }, succs = {bb_9 })
  {
    <bb 8>:
    # .MEM_85 = PHI <.MEM_90(6)>

  }
  bb_11 (preds = {bb_9 }, succs = {bb_12 })
  {
    <bb 11>:
    # .MEM_36 = PHI <.MEM_49(9)>

  }
  bb_14 (preds = {bb_12 }, succs = {bb_1 })
  {
    <bb 14>:
    # .MEM_111 = PHI <.MEM_114(12)>
    # VUSE <.MEM_111>
    return;

  }
  loop_7 (header = 12, latch = 13, niter = )
  {
    bb_12 (preds = {bb_11 bb_13 }, succs = {bb_13 bb_14 })
    {
      <bb 12>:
      # graphite_IV.16_127 = PHI <0(11), graphite_IV.16_126(13)>
      # .MEM_110 = PHI <.MEM_36(11), .MEM_114(13)>
      # DEBUG j => NULL
      # DEBUG i => NULL
      _122 = (sizetype) graphite_IV.16_127;
      _121 = _122 + 946;
      _120 = _121 * 8;
      _119 = aa_4(D) + _120;
      # VUSE <.MEM_110>
      _123 = *_119;
      _117 = (int) graphite_IV.16_127;
      # VUSE <.MEM_110>
      _118 = ran_x[_117];
      _116 = _123 - _118;
      _115 = _116 & 1073741823;
      _113 = (int) graphite_IV.16_127;
      _112 = _113 + 37;
      # .MEM_114 = VDEF <.MEM_110>
      ran_x[_112] = _115;
      # DEBUG i => NULL
      # DEBUG j => NULL
      # DEBUG j => NULL
      # DEBUG i => NULL
      graphite_IV.16_126 = graphite_IV.16_127 + 1;
      if (graphite_IV.16_127 < 62)
        goto <bb 13>;
      else
        goto <bb 14>;

    }
    bb_13 (preds = {bb_12 }, succs = {bb_12 })
    {
      <bb 13>:
      goto <bb 12>;

    }
  }
  loop_6 (header = 9, latch = 10, niter = )
  {
    bb_9 (preds = {bb_8 bb_10 }, succs = {bb_10 bb_11 })
    {
      <bb 9>:
      # graphite_IV.15_68 = PHI <0(8), graphite_IV.15_67(10)>
      # .MEM_35 = PHI <.MEM_85(8), .MEM_49(10)>
      # DEBUG j => NULL
      # DEBUG i => NULL
      _65 = (sizetype) graphite_IV.15_68;
      _64 = _65 + 909;
      _63 = _64 * 8;
      _62 = aa_4(D) + _63;
      # VUSE <.MEM_35>
      _66 = *_62;
      _55 = (sizetype) graphite_IV.15_68;
      _54 = _55 + 972;
      _53 = _54 * 8;
      _52 = aa_4(D) + _53;
      # VUSE <.MEM_35>
      _56 = *_52;
      _51 = _66 - _56;
      _50 = _51 & 1073741823;
      _48 = (int) graphite_IV.15_68;
      # .MEM_49 = VDEF <.MEM_35>
      ran_x[_48] = _50;
      # DEBUG i => NULL
      # DEBUG j => NULL
      # DEBUG j => NULL
      # DEBUG i => NULL
      graphite_IV.15_67 = graphite_IV.15_68 + 1;
      if (graphite_IV.15_68 < 36)
        goto <bb 10>;
      else
        goto <bb 11>;

    }
    bb_10 (preds = {bb_9 }, succs = {bb_9 })
    {
      <bb 10>:
      goto <bb 9>;

    }
  }
  loop_5 (header = 6, latch = 7, niter = )
  {
    bb_6 (preds = {bb_5 bb_7 }, succs = {bb_7 bb_8 })
    {
      <bb 6>:
      # graphite_IV.14_103 = PHI <0(5), graphite_IV.14_102(7)>
      # .MEM_74 = PHI <.MEM_136(5), .MEM_90(7)>
      # DEBUG j => NULL
      _100 = (sizetype) graphite_IV.14_103;
      _99 = _100 * 8;
      _98 = aa_4(D) + _99;
      # VUSE <.MEM_74>
      _101 = *_98;
      _96 = (sizetype) graphite_IV.14_103;
      _95 = _96 + 63;
      _94 = _95 * 8;
      _93 = aa_4(D) + _94;
      # VUSE <.MEM_74>
      _97 = *_93;
      _92 = _101 - _97;
      _91 = _92 & 1073741823;
      _89 = (sizetype) graphite_IV.14_103;
      _88 = _89 + 100;
      _87 = _88 * 8;
      _86 = aa_4(D) + _87;
      # .MEM_90 = VDEF <.MEM_74>
      *_86 = _91;
      # DEBUG j => NULL
      # DEBUG j => NULL
      graphite_IV.14_102 = graphite_IV.14_103 + 1;
      if (graphite_IV.14_103 < 908)
        goto <bb 7>;
      else
        goto <bb 8>;

    }
    bb_7 (preds = {bb_6 }, succs = {bb_6 })
    {
      <bb 7>:
      goto <bb 6>;

    }
  }
  loop_8 (header = 3, latch = 4, niter = )
  {
    bb_3 (preds = {bb_2 bb_4 }, succs = {bb_4 bb_5 })
    {
      <bb 3>:
      # graphite_IV.17_105 = PHI <0(2), graphite_IV.17_129(4)>
      # .MEM_137 = PHI <.MEM_57(D)(2), .MEM_132(4)>
      # DEBUG j => NULL
      _131 = (int) graphite_IV.17_105;
      # VUSE <.MEM_137>
      _130 = ran_x[_131];
      _133 = (sizetype) graphite_IV.17_105;
      _134 = _133 * 8;
      _135 = aa_4(D) + _134;
      # .MEM_132 = VDEF <.MEM_137>
      *_135 = _130;
      # DEBUG j => NULL
      # DEBUG j => NULL
      graphite_IV.17_129 = graphite_IV.17_105 + 1;
      if (graphite_IV.17_105 < 99)
        goto <bb 4>;
      else
        goto <bb 5>;

    }
    bb_4 (preds = {bb_3 }, succs = {bb_3 })
    {
      <bb 4>:
      goto <bb 3>;

    }
  }
}

Pass statistics:
----------------

void ran_array(long int*, int) (long intD.12 * aaD.3773)
{
  signed long graphite_IV.17D.3795;
  long intD.12 D.3794;
  signed long graphite_IV.16D.3793;
  long intD.12 D.3792;
  long intD.12 D.3791;
  long intD.12 D.3790;
  long intD.12 D.3789;
  signed long graphite_IV.15D.3788;
  long intD.12 D.3787;
  long intD.12 D.3786;
  long intD.12 D.3785;
  long intD.12 D.3784;
  signed long graphite_IV.14D.3783;
  long intD.12 D.3782;
  long intD.12 D.3781;
  long intD.12 D.3780;
  long intD.12 D.3779;
  register intD.9 iD.3774;
  register intD.9 jD.3775;
  intD.9 nD.3772;
  intD.9 _48;
  long intD.12 _50;
  long intD.12 _51;
  long intD.12 * _52;
  sizetype _53;
  sizetype _54;
  sizetype _55;
  long intD.12 _56;
  long intD.12 * _62;
  sizetype _63;
  sizetype _64;
  sizetype _65;
  long intD.12 _66;
  long intD.12 * _86;
  sizetype _87;
  sizetype _88;
  sizetype _89;
  long intD.12 _91;
  long intD.12 _92;
  long intD.12 * _93;
  sizetype _94;
  sizetype _95;
  sizetype _96;
  long intD.12 _97;
  long intD.12 * _98;
  sizetype _99;
  sizetype _100;
  long intD.12 _101;
  intD.9 _112;
  intD.9 _113;
  long intD.12 _115;
  long intD.12 _116;
  intD.9 _117;
  long intD.12 _118;
  long intD.12 * _119;
  sizetype _120;
  sizetype _121;
  sizetype _122;
  long intD.12 _123;
  long intD.12 _130;
  intD.9 _131;
  sizetype _133;
  sizetype _134;
  long intD.12 * _135;

;;   basic block 2, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY [100.0%]  (FALLTHRU,EXECUTABLE)
  # DEBUG nD.3772 => 1009
  # DEBUG jD.3775 => 0
;;    succ:       3 [100.0%]  (FALLTHRU)

;;   basic block 3, loop depth 1, count 0, freq 10000, maybe hot
;;    prev block 2, next block 4, flags: (NEW)
;;    pred:       2 [100.0%]  (FALLTHRU)
;;                4 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.17_105 = PHI <0(2), graphite_IV.17_129(4)>
  # .MEM_137 = PHI <.MEM_57(D)(2), .MEM_132(4)>
  # DEBUG jD.3775 => NULL
  _131 = (intD.9) graphite_IV.17_105;
  # VUSE <.MEM_137>
  _130 = ran_xD.2818[_131];
  _133 = (sizetype) graphite_IV.17_105;
  _134 = _133 * 8;
  _135 = aa_4(D) + _134;
  # .MEM_132 = VDEF <.MEM_137>
  *_135 = _130;
  # DEBUG jD.3775 => NULL
  # DEBUG jD.3775 => NULL
  graphite_IV.17_129 = graphite_IV.17_105 + 1;
  if (graphite_IV.17_105 < 99)
    goto <bb 4>;
  else
    goto <bb 5>;
;;    succ:       4 [99.0%]  (TRUE_VALUE)
;;                5 [1.0%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 4, loop depth 1, count 0, freq 9900, maybe hot
;;    prev block 3, next block 5, flags: (NEW)
;;    pred:       3 [99.0%]  (TRUE_VALUE)
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 5, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 4, next block 6, flags: (NEW)
;;    pred:       3 [1.0%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_136 = PHI <.MEM_132(3)>
;;    succ:       6 [100.0%]  (FALLTHRU)

;;   basic block 6, loop depth 1, count 0, freq 10000, maybe hot
;;    prev block 5, next block 7, flags: (NEW)
;;    pred:       5 [100.0%]  (FALLTHRU)
;;                7 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.14_103 = PHI <0(5), graphite_IV.14_102(7)>
  # .MEM_74 = PHI <.MEM_136(5), .MEM_90(7)>
  # DEBUG jD.3775 => NULL
  _100 = (sizetype) graphite_IV.14_103;
  _99 = _100 * 8;
  _98 = aa_4(D) + _99;
  # VUSE <.MEM_74>
  _101 = *_98;
  _96 = (sizetype) graphite_IV.14_103;
  _95 = _96 + 63;
  _94 = _95 * 8;
  _93 = aa_4(D) + _94;
  # VUSE <.MEM_74>
  _97 = *_93;
  _92 = _101 - _97;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _91 = _92 & 1073741823;
  _89 = (sizetype) graphite_IV.14_103;
  _88 = _89 + 100;
  _87 = _88 * 8;
  _86 = aa_4(D) + _87;
  # .MEM_90 = VDEF <.MEM_74>
  *_86 = _91;
  # DEBUG jD.3775 => NULL
  # DEBUG jD.3775 => NULL
  graphite_IV.14_102 = graphite_IV.14_103 + 1;
  if (graphite_IV.14_103 < 908)
    goto <bb 7>;
  else
    goto <bb 8>;
;;    succ:       7 [99.0%]  (TRUE_VALUE)
;;                8 [1.0%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 7, loop depth 1, count 0, freq 9900, maybe hot
;;    prev block 6, next block 8, flags: (NEW)
;;    pred:       6 [99.0%]  (TRUE_VALUE)
  goto <bb 6>;
;;    succ:       6 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 8, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 7, next block 9, flags: (NEW)
;;    pred:       6 [1.0%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_85 = PHI <.MEM_90(6)>
;;    succ:       9 [100.0%]  (FALLTHRU)

;;   basic block 9, loop depth 1, count 0, freq 3704, maybe hot
;;    prev block 8, next block 10, flags: (NEW)
;;    pred:       8 [100.0%]  (FALLTHRU)
;;                10 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.15_68 = PHI <0(8), graphite_IV.15_67(10)>
  # .MEM_35 = PHI <.MEM_85(8), .MEM_49(10)>
  # DEBUG jD.3775 => NULL
  # DEBUG iD.3774 => NULL
  _65 = (sizetype) graphite_IV.15_68;
  _64 = _65 + 909;
  _63 = _64 * 8;
  _62 = aa_4(D) + _63;
  # VUSE <.MEM_35>
  _66 = *_62;
  _55 = (sizetype) graphite_IV.15_68;
  _54 = _55 + 972;
  _53 = _54 * 8;
  _52 = aa_4(D) + _53;
  # VUSE <.MEM_35>
  _56 = *_52;
  _51 = _66 - _56;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _50 = _51 & 1073741823;
  _48 = (intD.9) graphite_IV.15_68;
  # .MEM_49 = VDEF <.MEM_35>
  ran_xD.2818[_48] = _50;
  # DEBUG iD.3774 => NULL
  # DEBUG jD.3775 => NULL
  # DEBUG jD.3775 => NULL
  # DEBUG iD.3774 => NULL
  graphite_IV.15_67 = graphite_IV.15_68 + 1;
  if (graphite_IV.15_68 < 36)
    goto <bb 10>;
  else
    goto <bb 11>;
;;    succ:       10 [97.3%]  (TRUE_VALUE)
;;                11 [2.7%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 10, loop depth 1, count 0, freq 3604, maybe hot
;;    prev block 9, next block 11, flags: (NEW)
;;    pred:       9 [97.3%]  (TRUE_VALUE)
  goto <bb 9>;
;;    succ:       9 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 11, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 10, next block 12, flags: (NEW)
;;    pred:       9 [2.7%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_36 = PHI <.MEM_49(9)>
;;    succ:       12 [100.0%]  (FALLTHRU)

;;   basic block 12, loop depth 1, count 0, freq 6289, maybe hot
;;    prev block 11, next block 13, flags: (NEW)
;;    pred:       11 [100.0%]  (FALLTHRU)
;;                13 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.16_127 = PHI <0(11), graphite_IV.16_126(13)>
  # .MEM_110 = PHI <.MEM_36(11), .MEM_114(13)>
  # DEBUG jD.3775 => NULL
  # DEBUG iD.3774 => NULL
  _122 = (sizetype) graphite_IV.16_127;
  _121 = _122 + 946;
  _120 = _121 * 8;
  _119 = aa_4(D) + _120;
  # VUSE <.MEM_110>
  _123 = *_119;
  _117 = (intD.9) graphite_IV.16_127;
  # VUSE <.MEM_110>
  _118 = ran_xD.2818[_117];
  _116 = _123 - _118;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _115 = _116 & 1073741823;
  _113 = (intD.9) graphite_IV.16_127;
  _112 = _113 + 37;
  # .MEM_114 = VDEF <.MEM_110>
  ran_xD.2818[_112] = _115;
  # DEBUG iD.3774 => NULL
  # DEBUG jD.3775 => NULL
  # DEBUG jD.3775 => NULL
  # DEBUG iD.3774 => NULL
  graphite_IV.16_126 = graphite_IV.16_127 + 1;
  if (graphite_IV.16_127 < 62)
    goto <bb 13>;
  else
    goto <bb 14>;
;;    succ:       13 [98.4%]  (TRUE_VALUE)
;;                14 [1.6%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 13, loop depth 1, count 0, freq 6189, maybe hot
;;    prev block 12, next block 14, flags: (NEW)
;;    pred:       12 [98.4%]  (TRUE_VALUE)
  goto <bb 12>;
;;    succ:       12 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 14, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 13, next block 1, flags: (NEW)
;;    pred:       12 [1.6%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_111 = PHI <.MEM_114(12)>
  # VUSE <.MEM_111>
  return;
;;    succ:       EXIT [100.0%] 

}



;; Function void ran_array(long int*, int) (_Z9ran_arrayPli, funcdef_no=0, decl_uid=2821, cgraph_uid=0, symbol_order=1)


Pass statistics:
----------------

void ran_array(long int*, int) (long intD.12 * aaD.2819, intD.9 nD.2820)
{
  register intD.9 jD.2824;
  register intD.9 iD.2823;
  long unsigned intD.14 _13;
  long unsigned intD.14 _14;
  long intD.12 * _16;
  long intD.12 _17;
  long unsigned intD.14 _21;
  long unsigned intD.14 _22;
  long intD.12 * _23;
  sizetype _26;
  long intD.12 * _27;
  long intD.12 _28;
  sizetype _30;
  long intD.12 * _31;
  long intD.12 _32;
  long intD.12 _33;
  long intD.12 _34;
  long unsigned intD.14 _37;
  long unsigned intD.14 _38;
  sizetype _39;
  long intD.12 * _40;
  long intD.12 _41;
  sizetype _43;
  long intD.12 * _44;
  long intD.12 _45;
  long intD.12 _46;
  long intD.12 _47;
  long unsigned intD.14 _51;
  long unsigned intD.14 _52;
  sizetype _53;
  long intD.12 * _54;
  long intD.12 _55;
  intD.9 _56;
  long intD.12 _57;
  long intD.12 _58;
  long intD.12 _59;

;;   basic block 2, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY [100.0%]  (FALLTHRU,EXECUTABLE)
  # DEBUG jD.2824 => 0
  # DEBUG jD.2824 => 0
;;    succ:       3 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 3, loop depth 1, count 0, freq 9900, maybe hot
;;    prev block 2, next block 4, flags: (NEW, REACHABLE)
;;    pred:       4 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                2 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 100] NONZERO 127
  # j_76 = PHI <j_19(4), 0(2)>
  # .MEM_79 = PHI <.MEM_18(4), .MEM_12(D)(2)>
  # DEBUG jD.2824 => j_76
  # RANGE [0, 99] NONZERO 127
  _13 = (long unsigned intD.14) j_76;
  # RANGE [0, 792] NONZERO 1016
  _14 = _13 * 8;
  # PT = nonlocal 
  _16 = aa_15(D) + _14;
  # VUSE <.MEM_79>
  _17 = ran_xD.2818[j_76];
  # .MEM_18 = VDEF <.MEM_79>
  *_16 = _17;
  # RANGE [1, 100] NONZERO 127
  j_19 = j_76 + 1;
  # DEBUG jD.2824 => j_19
  # DEBUG jD.2824 => j_19
  if (j_19 == 100)
    goto <bb 5>;
  else
    goto <bb 4>;
;;    succ:       5 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                4 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 4, loop depth 1, count 0, freq 9800, maybe hot
;;    prev block 3, next block 5, flags: (NEW)
;;    pred:       3 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 5, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 4, next block 6, flags: (NEW, REACHABLE)
;;    pred:       3 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # DEBUG jD.2824 => 100
  if (n_20(D) <= 100)
    goto <bb 9>;
  else
    goto <bb 6>;
;;    succ:       9 [9.0%]  (TRUE_VALUE,EXECUTABLE)
;;                6 [91.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 6, loop depth 0, count 0, freq 91, maybe hot
;;    prev block 5, next block 7, flags: (NEW)
;;    pred:       5 [91.0%]  (FALSE_VALUE,EXECUTABLE)
;;    succ:       7 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 7, loop depth 1, count 0, freq 1011, maybe hot
;;    prev block 6, next block 8, flags: (NEW, REACHABLE)
;;    pred:       6 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                8 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # j_72 = PHI <100(6), j_36(8)>
  # .MEM_3 = PHI <.MEM_18(6), .MEM_35(8)>
  # DEBUG jD.2824 => j_72
  # RANGE [0, 18446744073709551615]
  _21 = (long unsigned intD.14) j_72;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _22 = _21 * 8;
  # PT = nonlocal 
  _23 = aa_15(D) + _22;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _26 = _22 + 18446744073709550816;
  # PT = nonlocal 
  _27 = aa_15(D) + _26;
  # VUSE <.MEM_3>
  _28 = *_27;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _30 = _22 + 18446744073709551320;
  # PT = nonlocal 
  _31 = aa_15(D) + _30;
  # VUSE <.MEM_3>
  _32 = *_31;
  _33 = _28 - _32;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _34 = _33 & 1073741823;
  # .MEM_35 = VDEF <.MEM_3>
  *_23 = _34;
  j_36 = j_72 + 1;
  # DEBUG jD.2824 => j_36
  # DEBUG jD.2824 => j_36
  if (n_20(D) <= j_36)
    goto <bb 9>;
  else
    goto <bb 8>;
;;    succ:       9 [9.0%]  (TRUE_VALUE,EXECUTABLE)
;;                8 [91.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 8, loop depth 1, count 0, freq 920, maybe hot
;;    prev block 7, next block 9, flags: (NEW)
;;    pred:       7 [91.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 7>;
;;    succ:       7 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 9, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 8, next block 10, flags: (NEW, REACHABLE)
;;    pred:       7 [9.0%]  (TRUE_VALUE,EXECUTABLE)
;;                5 [9.0%]  (TRUE_VALUE,EXECUTABLE)
  # j_1 = PHI <n_20(D)(7), 100(5)>
  # .MEM_67 = PHI <.MEM_35(7), .MEM_18(5)>
;;    succ:       10 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 10, loop depth 1, count 0, freq 3702, maybe hot
;;    prev block 9, next block 11, flags: (NEW, REACHABLE)
;;    pred:       9 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                11 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [0, 37] NONZERO 63
  # i_74 = PHI <0(9), i_49(11)>
  # j_77 = PHI <j_1(9), j_50(11)>
  # .MEM_80 = PHI <.MEM_67(9), .MEM_48(11)>
  # DEBUG jD.2824 => j_77
  # DEBUG iD.2823 => i_74
  # RANGE ~[2147483648, 18446744071562067967]
  _37 = (long unsigned intD.14) j_77;
  # RANGE [0, 18446744073709551608] NONZERO 18446744073709551608
  _38 = _37 * 8;
  # RANGE ~[18446744073709550809, 18446744073709550815] NONZERO 18446744073709551608
  _39 = _38 + 18446744073709550816;
  # PT = nonlocal 
  _40 = aa_15(D) + _39;
  # VUSE <.MEM_80>
  _41 = *_40;
  # RANGE ~[18446744073709551313, 18446744073709551319] NONZERO 18446744073709551608
  _43 = _38 + 18446744073709551320;
  # PT = nonlocal 
  _44 = aa_15(D) + _43;
  # VUSE <.MEM_80>
  _45 = *_44;
  _46 = _41 - _45;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _47 = _46 & 1073741823;
  # .MEM_48 = VDEF <.MEM_80>
  ran_xD.2818[i_74] = _47;
  # RANGE [1, 37] NONZERO 63
  i_49 = i_74 + 1;
  # DEBUG iD.2823 => i_49
  j_50 = j_77 + 1;
  # DEBUG jD.2824 => j_50
  # DEBUG jD.2824 => j_50
  # DEBUG iD.2823 => i_49
  if (i_49 == 37)
    goto <bb 12>;
  else
    goto <bb 11>;
;;    succ:       12 [2.7%]  (TRUE_VALUE,EXECUTABLE)
;;                11 [97.3%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 11, loop depth 1, count 0, freq 3602, maybe hot
;;    prev block 10, next block 12, flags: (NEW)
;;    pred:       10 [97.3%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 10>;
;;    succ:       10 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 12, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 11, next block 13, flags: (NEW)
;;    pred:       10 [2.7%]  (TRUE_VALUE,EXECUTABLE)
  j_174 = j_1 + 37;
;;    succ:       13 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 13, loop depth 1, count 0, freq 9900, maybe hot
;;    prev block 12, next block 14, flags: (NEW, REACHABLE)
;;    pred:       12 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                14 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [37, 137] NONZERO 127
  # i_75 = PHI <37(12), i_61(14)>
  # j_78 = PHI <j_174(12), j_62(14)>
  # .MEM_81 = PHI <.MEM_48(12), .MEM_60(14)>
  # DEBUG jD.2824 => j_78
  # DEBUG iD.2823 => i_75
  # RANGE ~[2147483648, 18446744071562067967]
  _51 = (long unsigned intD.14) j_78;
  # RANGE [0, 18446744073709551608] NONZERO 18446744073709551608
  _52 = _51 * 8;
  # RANGE ~[18446744073709550809, 18446744073709550815] NONZERO 18446744073709551608
  _53 = _52 + 18446744073709550816;
  # PT = nonlocal 
  _54 = aa_15(D) + _53;
  # VUSE <.MEM_81>
  _55 = *_54;
  # RANGE [0, 62] NONZERO 63
  _56 = i_75 + -37;
  # VUSE <.MEM_81>
  _57 = ran_xD.2818[_56];
  _58 = _55 - _57;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _59 = _58 & 1073741823;
  # .MEM_60 = VDEF <.MEM_81>
  ran_xD.2818[i_75] = _59;
  # RANGE [38, 100] NONZERO 127
  i_61 = i_75 + 1;
  # DEBUG iD.2823 => i_61
  j_62 = j_78 + 1;
  # DEBUG jD.2824 => j_62
  # DEBUG jD.2824 => j_62
  # DEBUG iD.2823 => i_61
  if (i_61 > 99)
    goto <bb 15>;
  else
    goto <bb 14>;
;;    succ:       15 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                14 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 14, loop depth 1, count 0, freq 9800, maybe hot
;;    prev block 13, next block 15, flags: (NEW)
;;    pred:       13 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 13>;
;;    succ:       13 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 15, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 14, next block 1, flags: (NEW, REACHABLE)
;;    pred:       13 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # VUSE <.MEM_60>
  return;
;;    succ:       EXIT [100.0%] 

}



Updating SSA:
Registering new PHI nodes in block #19
Updating SSA information for statement if (n_20(D) <= 100)
Registering new PHI nodes in block #6
Registering new PHI nodes in block #7
Updating SSA information for statement *_23 = _34;
Updating SSA information for statement if (n_20(D) <= j_36)
Registering new PHI nodes in block #8
Registering new PHI nodes in block #18
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #17
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16

DFA Statistics for void ran_array(long int*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                             83        664b
DEF operands                             41        328b
VUSE operands                            12         96b
VDEF operands                             4         32b
PHI nodes                                14       1456b
PHI arguments                            26       1248b
---------------------------------------------------------
Total memory used by DFA/SSA data                 3824b
---------------------------------------------------------

Average number of arguments per PHI node: 1.9 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_126 -> { .MEM_35 }
n_175 -> { n_20(D) }
Incremental SSA update started at block: 19
Number of blocks in CFG: 20
Number of blocks to update: 4 ( 20%)
Affected blocks: 7 8 18 19


Creating dr for ran_x[j_76]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_1
Creating dr for ran_x[j_76]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_1
Creating dr for *_16
analyze_innermost: success.
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {0B, +, 8}_1
Creating dr for *_16
analyze_innermost: success.
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {0B, +, 8}_1
Creating dr for ran_x[j_76]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_1
Creating dr for ran_x[j_76]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_1
Creating dr for *_16
analyze_innermost: success.
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {0B, +, 8}_1
Creating dr for *_16
analyze_innermost: success.
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {0B, +, 8}_1
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 100
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 100
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
Creating dr for *_27
analyze_innermost: success.
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {0B, +, 8}_2
Creating dr for *_27
analyze_innermost: success.
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {0B, +, 8}_2
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {504B, +, 8}_2
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {504B, +, 8}_2
Creating dr for *_23
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {800B, +, 8}_2
Creating dr for *_23
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {800B, +, 8}_2
Creating dr for *_27
analyze_innermost: success.
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {0B, +, 8}_2
Creating dr for *_27
analyze_innermost: success.
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {0B, +, 8}_2
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {504B, +, 8}_2
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {504B, +, 8}_2
Creating dr for *_23
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {800B, +, 8}_2
Creating dr for *_23
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {800B, +, 8}_2
Analyzing # of iterations of loop 2
  exit condition [101, + , 1](no_overflow) < n_20(D)
  bounds on difference of bases: 0 ... 2147483546
  result:
    # of iterations (unsigned int) n_20(D) + 4294967195, bounded by 2147483546
Analyzing # of iterations of loop 2
  exit condition [101, + , 1](no_overflow) < n_20(D)
  bounds on difference of bases: 0 ... 2147483546
  result:
    # of iterations (unsigned int) n_20(D) + 4294967195, bounded by 2147483546
Creating dr for *_40
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -800(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-800B, +, 8}_3
Creating dr for *_40
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -800(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-800B, +, 8}_3
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -296(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-296B, +, 8}_3
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -296(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-296B, +, 8}_3
Creating dr for ran_x[i_74]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_3
Creating dr for ran_x[i_74]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_3
Creating dr for *_40
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -800(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-800B, +, 8}_3
Creating dr for *_40
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -800(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-800B, +, 8}_3
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -296(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-296B, +, 8}_3
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -296(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-296B, +, 8}_3
Creating dr for ran_x[i_74]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_3
Creating dr for ran_x[i_74]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_3
Analyzing # of iterations of loop 3
  exit condition [1, + , 1](no_overflow) != 37
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Analyzing # of iterations of loop 3
  exit condition [1, + , 1](no_overflow) != 37
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Creating dr for *_54
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -504(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-504B, +, 8}_4
Creating dr for *_54
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -504(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-504B, +, 8}_4
Creating dr for ran_x[_56]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for ran_x[_56]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for ran_x[i_75]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_4
Creating dr for ran_x[i_75]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_4
Creating dr for *_54
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -504(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-504B, +, 8}_4
Creating dr for *_54
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -504(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-504B, +, 8}_4
Creating dr for ran_x[_56]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for ran_x[_56]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for ran_x[i_75]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_4
Creating dr for ran_x[i_75]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_4
Analyzing # of iterations of loop 4
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62
Analyzing # of iterations of loop 4
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62

Before limit_scops SCoP statistics (BBS:18, LOOPS:4, CONDITIONS:5, STMTS:72)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

number of SCoPs: 4

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:10)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:17)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:20)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:19)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Global statistics (BBS:20, LOOPS:4, CONDITIONS:5, STMTS:72)

Global profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)
Creating dr for ran_x[j_76]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_1
Creating dr for *_16
analyze_innermost: success.
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {0B, +, 8}_1

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 99; c1 += 1)
  S_3(c1);


Removing basic block 25
basic block 25, loop depth 0
 pred:      
goto <bb 23>;
 succ:       23



Updating SSA:
Registering new PHI nodes in block #22
Registering new PHI nodes in block #24
Registering new PHI nodes in block #3
Updating SSA information for statement *_16 = _17;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #23
Registering new PHI nodes in block #21
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #6
Registering new PHI nodes in block #7
Registering new PHI nodes in block #8
Registering new PHI nodes in block #18
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #17
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16

DFA Statistics for void ran_array(long int*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                             83        664b
DEF operands                             41        328b
VUSE operands                            12         96b
VDEF operands                             4         32b
PHI nodes                                15       1560b
PHI arguments                            28       1344b
---------------------------------------------------------
Total memory used by DFA/SSA data                 4024b
---------------------------------------------------------

Average number of arguments per PHI node: 1.9 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_130 -> { .MEM_18 }
Incremental SSA update started at block: 22
Number of blocks in CFG: 26
Number of blocks to update: 10 ( 38%)
Affected blocks: 3 4 5 6 7 9 19 22 23 24



Updating SSA:
creating PHI node in block #27 for .MEM
creating PHI node in block #30 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #22
Registering new PHI nodes in block #26
Registering new PHI nodes in block #30
Registering new PHI nodes in block #34
Updating SSA information for statement _136 = ran_x[_138];
Updating SSA information for statement *_156 = _136;
Registering new PHI nodes in block #32
Registering new PHI nodes in block #31
Registering new PHI nodes in block #33
Registering new PHI nodes in block #28
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #24
Registering new PHI nodes in block #3
Updating SSA information for statement _17 = ran_x[j_76];
Updating SSA information for statement *_16 = _17;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #23
Registering new PHI nodes in block #21
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #6
Registering new PHI nodes in block #7
Updating SSA information for statement _28 = *_27;
Updating SSA information for statement _32 = *_31;
Updating SSA information for statement *_23 = _34;
Registering new PHI nodes in block #8
Registering new PHI nodes in block #18
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Updating SSA information for statement _41 = *_40;
Updating SSA information for statement _45 = *_44;
Updating SSA information for statement ran_x[i_74] = _47;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #17
Registering new PHI nodes in block #13
Updating SSA information for statement _55 = *_54;
Updating SSA information for statement _57 = ran_x[_56];
Updating SSA information for statement ran_x[i_75] = _59;
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16
Updating SSA information for statement return;

DFA Statistics for void ran_array(long int*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                             93        744b
DEF operands                             47        376b
VUSE operands                            14        112b
VDEF operands                             5         40b
PHI nodes                                18       1872b
PHI arguments                            34       1632b
---------------------------------------------------------
Total memory used by DFA/SSA data                 4776b
---------------------------------------------------------

Average number of arguments per PHI node: 1.9 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

_136 -> { _17 }
.MEM_140 -> { .MEM_18 }

Symbols to be put in SSA form
{ D.3747 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 35
Number of blocks to update: 33 ( 94%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 26 27 28 29 30 31 32 33 34



0 loops carried no dependency.
Creating dr for *_27
analyze_innermost: success.
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {0B, +, 8}_2
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {504B, +, 8}_2
Creating dr for *_23
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_15(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_15(D)
	Access function 0: {800B, +, 8}_2
Analyzing # of iterations of loop 2
  exit condition [101, + , 1](no_overflow) < n_20(D)
  bounds on difference of bases: 0 ... 2147483546
  result:
    # of iterations (unsigned int) n_20(D) + 4294967195, bounded by 2147483546
Analyzing # of iterations of loop 2
  exit condition [101, + , 1](no_overflow) < n_20(D)
  bounds on difference of bases: 0 ... 2147483546
  result:
    # of iterations (unsigned int) n_20(D) + 4294967195, bounded by 2147483546
Statement (exit)if (n_20(D) <= j_36)
 is executed at most (unsigned int) n_20(D) + 4294967195 (bounded by 2147483546) + 1 times in loop 2.
Induction variable (long int *) aa_15(D) + 800 + 8 * iteration does not wrap in statement _23 = aa_15(D) + _22;
 in loop 2.
Statement _23 = aa_15(D) + _22;
 is executed at most 2305843009213693950 (bounded by 2305843009213693950) + 1 times in loop 2.
Induction variable (long int *) aa_15(D) + 8 * iteration does not wrap in statement _27 = aa_15(D) + _26;
 in loop 2.
Statement _27 = aa_15(D) + _26;
 is executed at most 2305843009213693950 (bounded by 2305843009213693950) + 1 times in loop 2.
Induction variable (long int *) aa_15(D) + 504 + 8 * iteration does not wrap in statement _31 = aa_15(D) + _30;
 in loop 2.
Statement _31 = aa_15(D) + _30;
 is executed at most 2305843009213693950 (bounded by 2305843009213693950) + 1 times in loop 2.
Induction variable (int) 101 + 1 * iteration does not wrap in statement j_36 = j_72 + 1;
 in loop 2.
Statement j_36 = j_72 + 1;
 is executed at most 2147483546 (bounded by 2147483546) + 1 times in loop 2.

ISL AST generated by ISL: 
for (int c1 = 0; c1 < n - 100; c1 += 1)
  S_7(c1);


Removing basic block 40
basic block 40, loop depth 0
 pred:      
goto <bb 38>;
 succ:       38



Updating SSA:
Registering new PHI nodes in block #19
Registering new PHI nodes in block #6
Registering new PHI nodes in block #37
Registering new PHI nodes in block #39
Registering new PHI nodes in block #7
Registering new PHI nodes in block #8
Registering new PHI nodes in block #18
Registering new PHI nodes in block #38
Registering new PHI nodes in block #36
Registering new PHI nodes in block #35
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #17
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16

DFA Statistics for void ran_array(long int*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                             93        744b
DEF operands                             47        376b
VUSE operands                            14        112b
VDEF operands                             5         40b
PHI nodes                                19       1976b
PHI arguments                            36       1728b
---------------------------------------------------------
Total memory used by DFA/SSA data                 4976b
---------------------------------------------------------

Average number of arguments per PHI node: 1.9 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_118 -> { .MEM_126 }
Incremental SSA update started at block: 19
Number of blocks in CFG: 41
Number of blocks to update: 5 ( 12%)
Affected blocks: 9 18 35 38 39


Applying pattern match.pd:491, generic-match.c:4667
Applying pattern match.pd:491, generic-match.c:3721
Applying pattern match.pd:397, generic-match.c:4039
Applying pattern match.pd:397, generic-match.c:4039

Updating SSA:
creating PHI node in block #42 for .MEM
creating PHI node in block #45 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #22
Registering new PHI nodes in block #26
Registering new PHI nodes in block #30
Registering new PHI nodes in block #34
Updating SSA information for statement _136 = ran_x[_138];
Updating SSA information for statement *_156 = _136;
Registering new PHI nodes in block #32
Registering new PHI nodes in block #31
Registering new PHI nodes in block #33
Registering new PHI nodes in block #28
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #24
Registering new PHI nodes in block #3
Updating SSA information for statement _17 = ran_x[j_76];
Updating SSA information for statement *_16 = _17;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #23
Registering new PHI nodes in block #21
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #6
Registering new PHI nodes in block #37
Registering new PHI nodes in block #41
Registering new PHI nodes in block #47
Registering new PHI nodes in block #45
Registering new PHI nodes in block #50
Updating SSA information for statement _112 = *_109;
Updating SSA information for statement _108 = *_104;
Updating SSA information for statement _103 = _112 - _108;
Updating SSA information for statement _102 = _103 & 1073741823;
Updating SSA information for statement *_97 = _102;
Registering new PHI nodes in block #48
Registering new PHI nodes in block #46
Registering new PHI nodes in block #49
Registering new PHI nodes in block #43
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #39
Registering new PHI nodes in block #7
Updating SSA information for statement _28 = *_27;
Updating SSA information for statement _32 = *_31;
Updating SSA information for statement _33 = _28 - _32;
Updating SSA information for statement _34 = _33 & 1073741823;
Updating SSA information for statement *_23 = _34;
Registering new PHI nodes in block #8
Registering new PHI nodes in block #18
Registering new PHI nodes in block #38
Registering new PHI nodes in block #36
Registering new PHI nodes in block #35
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Updating SSA information for statement _41 = *_40;
Updating SSA information for statement _45 = *_44;
Updating SSA information for statement ran_x[i_74] = _47;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #17
Registering new PHI nodes in block #13
Updating SSA information for statement _55 = *_54;
Updating SSA information for statement _57 = ran_x[_56];
Updating SSA information for statement ran_x[i_75] = _59;
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16
Updating SSA information for statement return;

DFA Statistics for void ran_array(long int*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            121        968b
DEF operands                             66        528b
VUSE operands                            17        136b
VDEF operands                             6         48b
PHI nodes                                22       2288b
PHI arguments                            42       2016b
---------------------------------------------------------
Total memory used by DFA/SSA data                 5984b
---------------------------------------------------------

Average number of arguments per PHI node: 1.9 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_101 -> { .MEM_35 }
_102 -> { _34 }
_103 -> { _33 }
_108 -> { _32 }
_112 -> { _28 }

Symbols to be put in SSA form
{ D.3747 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 51
Number of blocks to update: 48 ( 94%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 26 27 28 29 30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46 47 48 49 50



0 loops carried no dependency.
Creating dr for *_40
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -800(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-800B, +, 8}_3
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -296(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-296B, +, 8}_3
Creating dr for ran_x[i_74]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_3
Analyzing # of iterations of loop 3
  exit condition [1, + , 1](no_overflow) != 37
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 36; c1 += 1)
  S_10(c1);


Removing basic block 56
basic block 56, loop depth 0
 pred:      
goto <bb 54>;
 succ:       54



Updating SSA:
Registering new PHI nodes in block #53
Registering new PHI nodes in block #55
Registering new PHI nodes in block #10
Updating SSA information for statement ran_x[i_74] = _47;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #54
Registering new PHI nodes in block #52
Registering new PHI nodes in block #51
Registering new PHI nodes in block #17
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16

DFA Statistics for void ran_array(long int*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            121        968b
DEF operands                             66        528b
VUSE operands                            17        136b
VDEF operands                             6         48b
PHI nodes                                23       2392b
PHI arguments                            44       2112b
---------------------------------------------------------
Total memory used by DFA/SSA data                 6184b
---------------------------------------------------------

Average number of arguments per PHI node: 1.9 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_90 -> { .MEM_48 }
Incremental SSA update started at block: 53
Number of blocks in CFG: 57
Number of blocks to update: 8 ( 14%)
Affected blocks: 10 11 12 13 17 53 54 55


Applying pattern match.pd:397, generic-match.c:4039
Applying pattern match.pd:725, generic-match.c:1428
gimple_simplified to _84 = _85 + _86;
Applying pattern match.pd:397, generic-match.c:4039
Applying pattern match.pd:725, generic-match.c:1428
gimple_simplified to _68 = _69 + _70;

Updating SSA:
creating PHI node in block #58 for .MEM
creating PHI node in block #61 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #22
Registering new PHI nodes in block #26
Registering new PHI nodes in block #30
Registering new PHI nodes in block #34
Updating SSA information for statement _136 = ran_x[_138];
Updating SSA information for statement *_156 = _136;
Registering new PHI nodes in block #32
Registering new PHI nodes in block #31
Registering new PHI nodes in block #33
Registering new PHI nodes in block #28
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #24
Registering new PHI nodes in block #3
Updating SSA information for statement _17 = ran_x[j_76];
Updating SSA information for statement *_16 = _17;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #23
Registering new PHI nodes in block #21
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #6
Registering new PHI nodes in block #37
Registering new PHI nodes in block #41
Registering new PHI nodes in block #47
Registering new PHI nodes in block #45
Registering new PHI nodes in block #50
Updating SSA information for statement _112 = *_109;
Updating SSA information for statement _108 = *_104;
Updating SSA information for statement *_97 = _102;
Registering new PHI nodes in block #48
Registering new PHI nodes in block #46
Registering new PHI nodes in block #49
Registering new PHI nodes in block #43
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #39
Registering new PHI nodes in block #7
Updating SSA information for statement _28 = *_27;
Updating SSA information for statement _32 = *_31;
Updating SSA information for statement *_23 = _34;
Registering new PHI nodes in block #8
Registering new PHI nodes in block #18
Registering new PHI nodes in block #38
Registering new PHI nodes in block #36
Registering new PHI nodes in block #35
Registering new PHI nodes in block #9
Registering new PHI nodes in block #53
Registering new PHI nodes in block #57
Registering new PHI nodes in block #61
Registering new PHI nodes in block #65
Updating SSA information for statement _87 = *_73;
Updating SSA information for statement _71 = *_64;
Updating SSA information for statement _63 = _87 - _71;
Updating SSA information for statement _42 = _63 & 1073741823;
Updating SSA information for statement ran_x[_25] = _42;
Registering new PHI nodes in block #63
Registering new PHI nodes in block #62
Registering new PHI nodes in block #64
Registering new PHI nodes in block #59
Registering new PHI nodes in block #60
Registering new PHI nodes in block #58
Registering new PHI nodes in block #55
Registering new PHI nodes in block #10
Updating SSA information for statement _41 = *_40;
Updating SSA information for statement _45 = *_44;
Updating SSA information for statement _46 = _41 - _45;
Updating SSA information for statement _47 = _46 & 1073741823;
Updating SSA information for statement ran_x[i_74] = _47;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #54
Registering new PHI nodes in block #52
Registering new PHI nodes in block #51
Registering new PHI nodes in block #17
Registering new PHI nodes in block #13
Updating SSA information for statement _55 = *_54;
Updating SSA information for statement _57 = ran_x[_56];
Updating SSA information for statement ran_x[i_75] = _59;
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16
Updating SSA information for statement return;

DFA Statistics for void ran_array(long int*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            147       1176b
DEF operands                             84        672b
VUSE operands                            20        160b
VDEF operands                             7         56b
PHI nodes                                26       2704b
PHI arguments                            50       2400b
---------------------------------------------------------
Total memory used by DFA/SSA data                 7168b
---------------------------------------------------------

Average number of arguments per PHI node: 1.9 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_29 -> { .MEM_48 }
_42 -> { _47 }
_63 -> { _46 }
_71 -> { _45 }
_87 -> { _41 }

Symbols to be put in SSA form
{ D.3747 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 66
Number of blocks to update: 62 ( 94%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 26 27 28 29 30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 57 58 59 60 61 62 63 64 65



1 loops carried no dependency.
Creating dr for *_54
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -504(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_15(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-504B, +, 8}_4
Creating dr for ran_x[_56]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for ran_x[i_75]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_4
Analyzing # of iterations of loop 4
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 62; c1 += 1)
  S_13(c1);


Removing basic block 71
basic block 71, loop depth 0
 pred:      
goto <bb 69>;
 succ:       69



Updating SSA:
Registering new PHI nodes in block #68
Registering new PHI nodes in block #70
Registering new PHI nodes in block #13
Updating SSA information for statement ran_x[i_75] = _59;
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #69
Registering new PHI nodes in block #67
Registering new PHI nodes in block #66
Registering new PHI nodes in block #16
Updating SSA information for statement return;

DFA Statistics for void ran_array(long int*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            147       1176b
DEF operands                             84        672b
VUSE operands                            20        160b
VDEF operands                             7         56b
PHI nodes                                27       2808b
PHI arguments                            52       2496b
---------------------------------------------------------
Total memory used by DFA/SSA data                 7368b
---------------------------------------------------------

Average number of arguments per PHI node: 1.9 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_6 -> { .MEM_60 }
Incremental SSA update started at block: 68
Number of blocks in CFG: 72
Number of blocks to update: 7 ( 10%)
Affected blocks: 13 14 15 16 68 69 70


Applying pattern match.pd:397, generic-match.c:4039
Applying pattern match.pd:725, generic-match.c:1428
gimple_simplified to _171 = _172 + _173;

Updating SSA:
creating PHI node in block #73 for .MEM
creating PHI node in block #76 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #22
Registering new PHI nodes in block #26
Registering new PHI nodes in block #30
Registering new PHI nodes in block #34
Updating SSA information for statement _136 = ran_x[_138];
Updating SSA information for statement *_156 = _136;
Registering new PHI nodes in block #32
Registering new PHI nodes in block #31
Registering new PHI nodes in block #33
Registering new PHI nodes in block #28
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #24
Registering new PHI nodes in block #3
Updating SSA information for statement _17 = ran_x[j_76];
Updating SSA information for statement *_16 = _17;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #23
Registering new PHI nodes in block #21
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #6
Registering new PHI nodes in block #37
Registering new PHI nodes in block #41
Registering new PHI nodes in block #47
Registering new PHI nodes in block #45
Registering new PHI nodes in block #50
Updating SSA information for statement _112 = *_109;
Updating SSA information for statement _108 = *_104;
Updating SSA information for statement *_97 = _102;
Registering new PHI nodes in block #48
Registering new PHI nodes in block #46
Registering new PHI nodes in block #49
Registering new PHI nodes in block #43
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #39
Registering new PHI nodes in block #7
Updating SSA information for statement _28 = *_27;
Updating SSA information for statement _32 = *_31;
Updating SSA information for statement *_23 = _34;
Registering new PHI nodes in block #8
Registering new PHI nodes in block #18
Registering new PHI nodes in block #38
Registering new PHI nodes in block #36
Registering new PHI nodes in block #35
Registering new PHI nodes in block #9
Registering new PHI nodes in block #53
Registering new PHI nodes in block #57
Registering new PHI nodes in block #61
Registering new PHI nodes in block #65
Updating SSA information for statement _87 = *_73;
Updating SSA information for statement _71 = *_64;
Updating SSA information for statement ran_x[_25] = _42;
Registering new PHI nodes in block #63
Registering new PHI nodes in block #62
Registering new PHI nodes in block #64
Registering new PHI nodes in block #59
Registering new PHI nodes in block #60
Registering new PHI nodes in block #58
Registering new PHI nodes in block #55
Registering new PHI nodes in block #10
Updating SSA information for statement _41 = *_40;
Updating SSA information for statement _45 = *_44;
Updating SSA information for statement ran_x[i_74] = _47;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #54
Registering new PHI nodes in block #52
Registering new PHI nodes in block #51
Registering new PHI nodes in block #17
Registering new PHI nodes in block #68
Registering new PHI nodes in block #72
Registering new PHI nodes in block #76
Registering new PHI nodes in block #80
Updating SSA information for statement _2 = *_168;
Updating SSA information for statement _167 = ran_x[_166];
Updating SSA information for statement _165 = _2 - _167;
Updating SSA information for statement _164 = _165 & 1073741823;
Updating SSA information for statement ran_x[_161] = _164;
Registering new PHI nodes in block #78
Registering new PHI nodes in block #77
Registering new PHI nodes in block #79
Registering new PHI nodes in block #74
Registering new PHI nodes in block #75
Registering new PHI nodes in block #73
Registering new PHI nodes in block #70
Registering new PHI nodes in block #13
Updating SSA information for statement _55 = *_54;
Updating SSA information for statement _57 = ran_x[_56];
Updating SSA information for statement _58 = _55 - _57;
Updating SSA information for statement _59 = _58 & 1073741823;
Updating SSA information for statement ran_x[i_75] = _59;
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #69
Registering new PHI nodes in block #67
Registering new PHI nodes in block #66
Registering new PHI nodes in block #16
Updating SSA information for statement return;

DFA Statistics for void ran_array(long int*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            167       1336b
DEF operands                             98        784b
VUSE operands                            23        184b
VDEF operands                             8         64b
PHI nodes                                30       3120b
PHI arguments                            58       2784b
---------------------------------------------------------
Total memory used by DFA/SSA data                 8272b
---------------------------------------------------------

Average number of arguments per PHI node: 1.9 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

_2 -> { _55 }
.MEM_163 -> { .MEM_60 }
_164 -> { _59 }
_165 -> { _58 }
_167 -> { _57 }

Symbols to be put in SSA form
{ D.3747 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 81
Number of blocks to update: 76 ( 94%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 26 27 28 29 30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 57 58 59 60 61 62 63 64 65 66 67 68 69 70 72 73 74 75 76 77 78 79 80



1 loops carried no dependency.
Merging blocks 2 and 22
Removing basic block 5
basic block 5, loop depth 0
 pred:      
goto <bb 23>;
 succ:       23


Removing basic block 6
basic block 6, loop depth 0
 pred:      
 succ:       37


Merging blocks 9 and 53
Removing basic block 12
basic block 12, loop depth 0
 pred:      
goto <bb 54>;
 succ:       54


Removing basic block 15
basic block 15, loop depth 0
 pred:      
goto <bb 69>;
 succ:       69


Removing basic block 20
basic block 20, loop depth 0
 pred:      
 succ:       19


Removing basic block 21
basic block 21, loop depth 0
 pred:      
goto <bb 19>;
 succ:       19


Merging blocks 23 and 19
Removing basic block 24
basic block 24, loop depth 0
 pred:      
 succ:       23


Removing basic block 29
basic block 29, loop depth 0
 pred:       26
goto <bb 27>;
 succ:       27


Removing basic block 28
basic block 28, loop depth 0
 pred:      
 succ:       27


Merging blocks 30 and 34
Removing basic block 33
basic block 33, loop depth 0
 pred:      
 succ:       27


Removing basic block 35
basic block 35, loop depth 0
 pred:      
 succ:       9


Removing basic block 36
basic block 36, loop depth 0
 pred:      
goto <bb 9>;
 succ:       9


Removing basic block 8
basic block 8, loop depth 1
 pred:       7
goto <bb 7>;
 succ:       7


Removing basic block 18
basic block 18, loop depth 0
 pred:       7
# n_175 = PHI <n_20(D)(7)>
goto <bb 38>;
 succ:       38


Removing basic block 7
basic block 7, loop depth 1
 pred:       37
# j_72 = PHI <100(37)>
# DEBUG j => j_72
_21 = (long unsigned int) j_72;
_22 = _21 * 8;
_23 = aa_15(D) + _22;
_26 = _22 + 18446744073709550816;
_27 = aa_15(D) + _26;
_28 = *_27;
_30 = _22 + 18446744073709551320;
_31 = aa_15(D) + _30;
_32 = *_31;
_33 = _28 - _32;
_34 = _33 & 1073741823;
*_23 = _34;
j_36 = j_72 + 1;
# DEBUG j => j_36
# DEBUG j => j_36
if (n_20(D) <= j_36)
 succ:      


Removing basic block 37
basic block 37, loop depth 0
 pred:      
 succ:       41


Removing basic block 39
basic block 39, loop depth 0
 pred:      
 succ:       38


Merging blocks 42 and 38
Removing basic block 43
basic block 43, loop depth 0
 pred:      
 succ:       42


Removing basic block 44
basic block 44, loop depth 0
 pred:      
goto <bb 42>;
 succ:       42


Merging blocks 45 and 50
Removing basic block 49
basic block 49, loop depth 0
 pred:      
 succ:       42


Removing basic block 51
basic block 51, loop depth 0
 pred:      
 succ:       17


Removing basic block 52
basic block 52, loop depth 0
 pred:      
goto <bb 17>;
 succ:       17


Merging blocks 54 and 17
Removing basic block 55
basic block 55, loop depth 0
 pred:      
 succ:       54


Removing basic block 60
basic block 60, loop depth 0
 pred:       57
goto <bb 58>;
 succ:       58


Removing basic block 59
basic block 59, loop depth 0
 pred:      
 succ:       58


Merging blocks 61 and 65
Removing basic block 64
basic block 64, loop depth 0
 pred:      
 succ:       58


Removing basic block 66
basic block 66, loop depth 0
 pred:      
 succ:       16


Removing basic block 67
basic block 67, loop depth 0
 pred:      
goto <bb 16>;
 succ:       16


Removing basic block 14
basic block 14, loop depth 1
 pred:       13
goto <bb 13>;
 succ:       13


Removing basic block 13
basic block 13, loop depth 1
 pred:       68
# i_75 = PHI <37(68)>
# j_78 = PHI <j_174(68)>
# DEBUG j => j_78
# DEBUG i => i_75
_51 = (long unsigned int) j_78;
_52 = _51 * 8;
_53 = _52 + 18446744073709550816;
_54 = aa_15(D) + _53;
_55 = *_54;
_56 = i_75 + -37;
_57 = ran_x[_56];
_58 = _55 - _57;
_59 = _58 & 1073741823;
ran_x[i_75] = _59;
i_61 = i_75 + 1;
# DEBUG i => i_61
j_62 = j_78 + 1;
# DEBUG j => j_62
# DEBUG j => j_62
# DEBUG i => i_61
if (i_61 > 99)
 succ:       69


Removing basic block 68
basic block 68, loop depth 0
 pred:      
 succ:       72


Removing basic block 70
basic block 70, loop depth 0
 pred:      
 succ:       69


Removing basic block 75
basic block 75, loop depth 0
 pred:       72
goto <bb 73>;
 succ:       73


Removing basic block 74
basic block 74, loop depth 0
 pred:      
 succ:       73


Merging blocks 76 and 80
Removing basic block 79
basic block 79, loop depth 0
 pred:      
 succ:       73


Removing basic block 4
basic block 4, loop depth 1
 pred:       3
goto <bb 3>;
 succ:       3


Removing basic block 3
basic block 3, loop depth 1
 pred:       2
# j_76 = PHI <0(2)>
# DEBUG j => j_76
_13 = (long unsigned int) j_76;
_14 = _13 * 8;
_16 = aa_15(D) + _14;
_17 = ran_x[j_76];
*_16 = _17;
j_19 = j_76 + 1;
# DEBUG j => j_19
# DEBUG j => j_19
if (j_19 == 100)
 succ:       23


Merging blocks 2 and 26
Removing basic block 11
basic block 11, loop depth 1
 pred:       10
goto <bb 10>;
 succ:       10


Removing basic block 10
basic block 10, loop depth 1
 pred:       9
# i_74 = PHI <0(9)>
# j_77 = PHI <j_1(9)>
# DEBUG j => j_77
# DEBUG i => i_74
_37 = (long unsigned int) j_77;
_38 = _37 * 8;
_39 = _38 + 18446744073709550816;
_40 = aa_15(D) + _39;
_41 = *_40;
_43 = _38 + 18446744073709551320;
_44 = aa_15(D) + _43;
_45 = *_44;
_46 = _41 - _45;
_47 = _46 & 1073741823;
ran_x[i_74] = _47;
i_49 = i_74 + 1;
# DEBUG i => i_49
j_50 = j_77 + 1;
# DEBUG j => j_50
# DEBUG j => j_50
# DEBUG i => i_49
if (i_49 == 37)
 succ:       54


Merging blocks 9 and 57
Merging blocks 27 and 23
Merging blocks 30 and 32
Merging blocks 45 and 48
Merging blocks 58 and 54
Merging blocks 58 and 72
Merging blocks 61 and 63
Merging blocks 73 and 69
Merging blocks 73 and 16
Merging blocks 76 and 78
fix_loop_structure: removing loop 4
fix_loop_structure: removing loop 3
fix_loop_structure: removing loop 2
fix_loop_structure: removing loop 1
Analyzing # of iterations of loop 8
  exit condition [0, + , 1](no_overflow) < 62
  bounds on difference of bases: 62 ... 62
  result:
    # of iterations 62, bounded by 62
Analyzing # of iterations of loop 7
  exit condition [0, + , 1](no_overflow) < 36
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Analyzing # of iterations of loop 6
  exit condition [0, + , 1](no_overflow) < (signed long) n_20(D) + -101
  bounds on difference of bases: -9223372036854775808 ... 9223372036854775706
Applying pattern match.pd:49, generic-match.c:4253
  result:
    zero if n_20(D) <= 100
    # of iterations (unsigned long) ((signed long) n_20(D) + -101), bounded by 9223372036854775706
Analyzing # of iterations of loop 6
  exit condition [0, + , 1](no_overflow) < (signed long) n_20(D) + -101
  bounds on difference of bases: -9223372036854775808 ... 9223372036854775706
Applying pattern match.pd:49, generic-match.c:4253
  result:
    zero if n_20(D) <= 100
    # of iterations (unsigned long) ((signed long) n_20(D) + -101), bounded by 9223372036854775706
Analyzing # of iterations of loop 6
  exit condition [0, + , 1](no_overflow) < (signed long) n_20(D) + -101
  bounds on difference of bases: -9223372036854775808 ... 9223372036854775706
Applying pattern match.pd:49, generic-match.c:4253
  result:
    zero if n_20(D) <= 100
    # of iterations (unsigned long) ((signed long) n_20(D) + -101), bounded by 9223372036854775706
Statement (exit)if (graphite_IV.127_114 < _115)
 is executed at most (unsigned long) ((signed long) n_20(D) + -101) (bounded by 9223372036854775706) + 1 times in loop 6.
Induction variable (long int *) aa_15(D) + 8 * iteration does not wrap in statement _109 = aa_15(D) + _110;
 in loop 6.
Statement _109 = aa_15(D) + _110;
 is executed at most 2305843009213693950 (bounded by 2305843009213693950) + 1 times in loop 6.
Induction variable (long int *) aa_15(D) + 504 + 8 * iteration does not wrap in statement _104 = aa_15(D) + _105;
 in loop 6.
Statement _104 = aa_15(D) + _105;
 is executed at most 2305843009213693950 (bounded by 2305843009213693950) + 1 times in loop 6.
Induction variable (long int *) aa_15(D) + 800 + 8 * iteration does not wrap in statement _97 = aa_15(D) + _98;
 in loop 6.
Statement _97 = aa_15(D) + _98;
 is executed at most 2305843009213693950 (bounded by 2305843009213693950) + 1 times in loop 6.
Induction variable (signed long) 1 + 1 * iteration does not wrap in statement graphite_IV.127_113 = graphite_IV.127_114 + 1;
 in loop 6.
Statement graphite_IV.127_113 = graphite_IV.127_114 + 1;
 is executed at most 9223372036854775806 (bounded by 9223372036854775806) + 1 times in loop 6.
Reducing loop iteration estimate by 1; undefined statement must be executed at the last iteration.
Analyzing # of iterations of loop 5
  exit condition [0, + , 1](no_overflow) < 99
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
1 edges in bb 2 predicted to even probabilities
Predictions for bb 3
  DS theory heuristics (ignored): 99.0%
  first match heuristics: 99.0%
  combined heuristics: 99.0%
  loop iterations heuristics: 99.0%
1 edges in bb 4 predicted to even probabilities
Predictions for bb 5
  no prediction heuristics: 50.0%
  combined heuristics: 50.0%
Predictions for bb 6
  no prediction heuristics: 50.0%
  combined heuristics: 50.0%
1 edges in bb 7 predicted to even probabilities
Predictions for bb 8
  DS theory heuristics (ignored): 91.0%
  first match heuristics: 91.0%
  combined heuristics: 91.0%
  loop exit heuristics: 91.0%
1 edges in bb 9 predicted to even probabilities
1 edges in bb 10 predicted to even probabilities
1 edges in bb 11 predicted to even probabilities
Predictions for bb 12
  DS theory heuristics (ignored): 97.3%
  first match heuristics: 97.3%
  combined heuristics: 97.3%
  loop iterations heuristics: 97.3%
1 edges in bb 13 predicted to even probabilities
1 edges in bb 14 predicted to even probabilities
Predictions for bb 15
  DS theory heuristics (ignored): 99.0%
  first match heuristics: 98.4%
  combined heuristics: 98.4%
  early return (on trees) heuristics (ignored): 61.0%
  loop iterations heuristics: 98.4%
1 edges in bb 16 predicted to even probabilities
1 edges in bb 17 predicted to even probabilities
loop_0 (header = 0, latch = 1, niter = )
{
  bb_2 (preds = {bb_0 }, succs = {bb_3 })
  {
    <bb 2>:
    # DEBUG j => 0
    # DEBUG j => 0

  }
  bb_5 (preds = {bb_3 }, succs = {bb_11 bb_6 })
  {
    <bb 5>:
    # .MEM_155 = PHI <.MEM_140(3)>
    # DEBUG j => 100
    if (n_20(D) <= 100)
      goto <bb 11>;
    else
      goto <bb 6>;

  }
  bb_6 (preds = {bb_5 }, succs = {bb_7 bb_10 })
  {
    <bb 6>:
    _117 = n_20(D) > 100;
    if (_117 != 0)
      goto <bb 7>;
    else
      goto <bb 10>;

  }
  bb_7 (preds = {bb_6 }, succs = {bb_8 })
  {
    <bb 7>:
    _116 = (signed long) n_20(D);
    _115 = _116 + -101;

  }
  bb_10 (preds = {bb_8 bb_6 }, succs = {bb_11 })
  {
    <bb 10>:
    # .MEM_96 = PHI <.MEM_101(8), .MEM_155(6)>

  }
  bb_11 (preds = {bb_10 bb_5 }, succs = {bb_12 })
  {
    <bb 11>:
    # j_1 = PHI <n_20(D)(10), 100(5)>
    # .MEM_67 = PHI <.MEM_96(10), .MEM_155(5)>

  }
  bb_14 (preds = {bb_12 }, succs = {bb_15 })
  {
    <bb 14>:
    # .MEM_24 = PHI <.MEM_29(12)>
    j_174 = j_1 + 37;

  }
  bb_17 (preds = {bb_15 }, succs = {bb_1 })
  {
    <bb 17>:
    # .MEM_160 = PHI <.MEM_163(15)>
    # VUSE <.MEM_160>
    return;

  }
  loop_8 (header = 15, latch = 16, niter = )
  {
    bb_15 (preds = {bb_14 bb_16 }, succs = {bb_16 bb_17 })
    {
      <bb 15>:
      # graphite_IV.129_5 = PHI <0(14), graphite_IV.129_4(16)>
      # .MEM_159 = PHI <.MEM_24(14), .MEM_163(16)>
      # DEBUG j => NULL
      # DEBUG i => NULL
      _173 = (sizetype) j_174;
      _172 = (sizetype) graphite_IV.129_5;
      _171 = _172 + _173;
      _170 = _171 * 8;
      _169 = _170 + 18446744073709550816;
      _168 = aa_15(D) + _169;
      # VUSE <.MEM_159>
      _2 = *_168;
      _166 = (int) graphite_IV.129_5;
      # VUSE <.MEM_159>
      _167 = ran_x[_166];
      _165 = _2 - _167;
      _164 = _165 & 1073741823;
      _162 = (int) graphite_IV.129_5;
      _161 = _162 + 37;
      # .MEM_163 = VDEF <.MEM_159>
      ran_x[_161] = _164;
      # DEBUG i => NULL
      # DEBUG j => NULL
      # DEBUG j => NULL
      # DEBUG i => NULL
      graphite_IV.129_4 = graphite_IV.129_5 + 1;
      if (graphite_IV.129_5 < 62)
        goto <bb 16>;
      else
        goto <bb 17>;

    }
    bb_16 (preds = {bb_15 }, succs = {bb_15 })
    {
      <bb 16>:
      goto <bb 15>;

    }
  }
  loop_7 (header = 12, latch = 13, niter = )
  {
    bb_12 (preds = {bb_11 bb_13 }, succs = {bb_13 bb_14 })
    {
      <bb 12>:
      # graphite_IV.128_89 = PHI <0(11), graphite_IV.128_88(13)>
      # .MEM_11 = PHI <.MEM_67(11), .MEM_29(13)>
      # DEBUG j => NULL
      # DEBUG i => NULL
      _86 = (sizetype) j_1;
      _85 = (sizetype) graphite_IV.128_89;
      _84 = _85 + _86;
      _83 = _84 * 8;
      _82 = _83 + 18446744073709550816;
      _73 = aa_15(D) + _82;
      # VUSE <.MEM_11>
      _87 = *_73;
      _70 = (sizetype) j_1;
      _69 = (sizetype) graphite_IV.128_89;
      _68 = _69 + _70;
      _66 = _68 * 8;
      _65 = _66 + 18446744073709551320;
      _64 = aa_15(D) + _65;
      # VUSE <.MEM_11>
      _71 = *_64;
      _63 = _87 - _71;
      _42 = _63 & 1073741823;
      _25 = (int) graphite_IV.128_89;
      # .MEM_29 = VDEF <.MEM_11>
      ran_x[_25] = _42;
      # DEBUG i => NULL
      # DEBUG j => NULL
      # DEBUG j => NULL
      # DEBUG i => NULL
      graphite_IV.128_88 = graphite_IV.128_89 + 1;
      if (graphite_IV.128_89 < 36)
        goto <bb 13>;
      else
        goto <bb 14>;

    }
    bb_13 (preds = {bb_12 }, succs = {bb_12 })
    {
      <bb 13>:
      goto <bb 12>;

    }
  }
  loop_6 (header = 8, latch = 9, niter = (unsigned long) ((signed long) n_20(D) + -101), upper_bound = 2305843009213693950)
  {
    bb_8 (preds = {bb_7 bb_9 }, succs = {bb_9 bb_10 })
    {
      <bb 8>:
      # graphite_IV.127_114 = PHI <0(7), graphite_IV.127_113(9)>
      # .MEM_95 = PHI <.MEM_155(7), .MEM_101(9)>
      # DEBUG j => NULL
      _111 = (sizetype) graphite_IV.127_114;
      _110 = _111 * 8;
      _109 = aa_15(D) + _110;
      # VUSE <.MEM_95>
      _112 = *_109;
      _107 = (sizetype) graphite_IV.127_114;
      _106 = _107 + 63;
      _105 = _106 * 8;
      _104 = aa_15(D) + _105;
      # VUSE <.MEM_95>
      _108 = *_104;
      _103 = _112 - _108;
      _102 = _103 & 1073741823;
      _100 = (sizetype) graphite_IV.127_114;
      _99 = _100 + 100;
      _98 = _99 * 8;
      _97 = aa_15(D) + _98;
      # .MEM_101 = VDEF <.MEM_95>
      *_97 = _102;
      # DEBUG j => NULL
      # DEBUG j => NULL
      graphite_IV.127_113 = graphite_IV.127_114 + 1;
      if (graphite_IV.127_114 < _115)
        goto <bb 9>;
      else
        goto <bb 10>;

    }
    bb_9 (preds = {bb_8 }, succs = {bb_8 })
    {
      <bb 9>:
      goto <bb 8>;

    }
  }
  loop_5 (header = 3, latch = 4, niter = )
  {
    bb_3 (preds = {bb_2 bb_4 }, succs = {bb_4 bb_5 })
    {
      <bb 3>:
      # graphite_IV.126_132 = PHI <0(2), graphite_IV.126_134(4)>
      # .MEM_154 = PHI <.MEM_12(D)(2), .MEM_140(4)>
      # DEBUG j => NULL
      _138 = (int) graphite_IV.126_132;
      # VUSE <.MEM_154>
      _136 = ran_x[_138];
      _142 = (sizetype) graphite_IV.126_132;
      _157 = _142 * 8;
      _156 = aa_15(D) + _157;
      # .MEM_140 = VDEF <.MEM_154>
      *_156 = _136;
      # DEBUG j => NULL
      # DEBUG j => NULL
      graphite_IV.126_134 = graphite_IV.126_132 + 1;
      if (graphite_IV.126_132 < 99)
        goto <bb 4>;
      else
        goto <bb 5>;

    }
    bb_4 (preds = {bb_3 }, succs = {bb_3 })
    {
      <bb 4>:
      goto <bb 3>;

    }
  }
}

Pass statistics:
----------------

void ran_array(long int*, int) (long intD.12 * aaD.2819, intD.9 nD.2820)
{
  signed long graphite_IV.129D.3939;
  long intD.12 D.3938;
  long intD.12 D.3937;
  long intD.12 D.3936;
  long intD.12 D.3935;
  signed long graphite_IV.128D.3934;
  long intD.12 D.3933;
  long intD.12 D.3932;
  long intD.12 D.3931;
  long intD.12 D.3930;
  signed long graphite_IV.127D.3929;
  long intD.12 D.3928;
  long intD.12 D.3927;
  long intD.12 D.3926;
  long intD.12 D.3925;
  signed long graphite_IV.126D.3924;
  long intD.12 D.3923;
  register intD.9 jD.2824;
  register intD.9 iD.2823;
  long intD.12 _2;
  intD.9 _25;
  long intD.12 _42;
  long intD.12 _63;
  long intD.12 * _64;
  sizetype _65;
  sizetype _66;
  sizetype _68;
  sizetype _69;
  sizetype _70;
  long intD.12 _71;
  long intD.12 * _73;
  sizetype _82;
  sizetype _83;
  sizetype _84;
  sizetype _85;
  sizetype _86;
  long intD.12 _87;
  long intD.12 * _97;
  sizetype _98;
  sizetype _99;
  sizetype _100;
  long intD.12 _102;
  long intD.12 _103;
  long intD.12 * _104;
  sizetype _105;
  sizetype _106;
  sizetype _107;
  long intD.12 _108;
  long intD.12 * _109;
  sizetype _110;
  sizetype _111;
  long intD.12 _112;
  signed long _115;
  signed long _116;
  boolD.2757 _117;
  long intD.12 _136;
  intD.9 _138;
  sizetype _142;
  long intD.12 * _156;
  sizetype _157;
  intD.9 _161;
  intD.9 _162;
  long intD.12 _164;
  long intD.12 _165;
  intD.9 _166;
  long intD.12 _167;
  long intD.12 * _168;
  sizetype _169;
  sizetype _170;
  sizetype _171;
  sizetype _172;
  sizetype _173;

;;   basic block 2, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY [100.0%]  (FALLTHRU,EXECUTABLE)
  # DEBUG jD.2824 => 0
  # DEBUG jD.2824 => 0
;;    succ:       3 [100.0%]  (FALLTHRU)

;;   basic block 3, loop depth 1, count 0, freq 10000, maybe hot
;;    prev block 2, next block 4, flags: (NEW)
;;    pred:       2 [100.0%]  (FALLTHRU)
;;                4 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.126_132 = PHI <0(2), graphite_IV.126_134(4)>
  # .MEM_154 = PHI <.MEM_12(D)(2), .MEM_140(4)>
  # DEBUG jD.2824 => NULL
  _138 = (intD.9) graphite_IV.126_132;
  # VUSE <.MEM_154>
  _136 = ran_xD.2818[_138];
  _142 = (sizetype) graphite_IV.126_132;
  _157 = _142 * 8;
  _156 = aa_15(D) + _157;
  # .MEM_140 = VDEF <.MEM_154>
  *_156 = _136;
  # DEBUG jD.2824 => NULL
  # DEBUG jD.2824 => NULL
  graphite_IV.126_134 = graphite_IV.126_132 + 1;
  if (graphite_IV.126_132 < 99)
    goto <bb 4>;
  else
    goto <bb 5>;
;;    succ:       4 [99.0%]  (TRUE_VALUE)
;;                5 [1.0%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 4, loop depth 1, count 0, freq 9900, maybe hot
;;    prev block 3, next block 5, flags: (NEW)
;;    pred:       3 [99.0%]  (TRUE_VALUE)
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 5, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 4, next block 6, flags: (NEW)
;;    pred:       3 [1.0%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_155 = PHI <.MEM_140(3)>
  # DEBUG jD.2824 => 100
  if (n_20(D) <= 100)
    goto <bb 11>;
  else
    goto <bb 6>;
;;    succ:       11 [50.0%]  (TRUE_VALUE,EXECUTABLE)
;;                6 [50.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 6, loop depth 0, count 0, freq 50, maybe hot
;;    prev block 5, next block 7, flags: (NEW)
;;    pred:       5 [50.0%]  (FALSE_VALUE,EXECUTABLE)
  _117 = n_20(D) > 100;
  if (_117 != 0)
    goto <bb 7>;
  else
    goto <bb 10>;
;;    succ:       7 [50.0%]  (TRUE_VALUE)
;;                10 [50.0%]  (FALSE_VALUE)

;;   basic block 7, loop depth 0, count 0, freq 25, maybe hot
;;    prev block 6, next block 8, flags: (NEW)
;;    pred:       6 [50.0%]  (TRUE_VALUE)
  _116 = (signed long) n_20(D);
  _115 = _116 + -101;
;;    succ:       8 [100.0%]  (FALLTHRU)

;;   basic block 8, loop depth 1, count 0, freq 278, maybe hot
;;    prev block 7, next block 9, flags: (NEW)
;;    pred:       7 [100.0%]  (FALLTHRU)
;;                9 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.127_114 = PHI <0(7), graphite_IV.127_113(9)>
  # .MEM_95 = PHI <.MEM_155(7), .MEM_101(9)>
  # DEBUG jD.2824 => NULL
  _111 = (sizetype) graphite_IV.127_114;
  _110 = _111 * 8;
  _109 = aa_15(D) + _110;
  # VUSE <.MEM_95>
  _112 = *_109;
  _107 = (sizetype) graphite_IV.127_114;
  _106 = _107 + 63;
  _105 = _106 * 8;
  _104 = aa_15(D) + _105;
  # VUSE <.MEM_95>
  _108 = *_104;
  _103 = _112 - _108;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _102 = _103 & 1073741823;
  _100 = (sizetype) graphite_IV.127_114;
  _99 = _100 + 100;
  _98 = _99 * 8;
  _97 = aa_15(D) + _98;
  # .MEM_101 = VDEF <.MEM_95>
  *_97 = _102;
  # DEBUG jD.2824 => NULL
  # DEBUG jD.2824 => NULL
  graphite_IV.127_113 = graphite_IV.127_114 + 1;
  if (graphite_IV.127_114 < _115)
    goto <bb 9>;
  else
    goto <bb 10>;
;;    succ:       9 [91.0%]  (TRUE_VALUE)
;;                10 [9.0%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 9, loop depth 1, count 0, freq 253, maybe hot
;;    prev block 8, next block 10, flags: (NEW)
;;    pred:       8 [91.0%]  (TRUE_VALUE)
  goto <bb 8>;
;;    succ:       8 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 10, loop depth 0, count 0, freq 50, maybe hot
;;    prev block 9, next block 11, flags: (NEW)
;;    pred:       8 [9.0%]  (FALSE_VALUE,LOOP_EXIT)
;;                6 [50.0%]  (FALSE_VALUE)
  # .MEM_96 = PHI <.MEM_101(8), .MEM_155(6)>
;;    succ:       11 [100.0%]  (FALLTHRU)

;;   basic block 11, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 10, next block 12, flags: (NEW, REACHABLE)
;;    pred:       10 [100.0%]  (FALLTHRU)
;;                5 [50.0%]  (TRUE_VALUE,EXECUTABLE)
  # j_1 = PHI <n_20(D)(10), 100(5)>
  # .MEM_67 = PHI <.MEM_96(10), .MEM_155(5)>
;;    succ:       12 [100.0%]  (FALLTHRU)

;;   basic block 12, loop depth 1, count 0, freq 3704, maybe hot
;;    prev block 11, next block 13, flags: (NEW)
;;    pred:       11 [100.0%]  (FALLTHRU)
;;                13 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.128_89 = PHI <0(11), graphite_IV.128_88(13)>
  # .MEM_11 = PHI <.MEM_67(11), .MEM_29(13)>
  # DEBUG jD.2824 => NULL
  # DEBUG iD.2823 => NULL
  _86 = (sizetype) j_1;
  _85 = (sizetype) graphite_IV.128_89;
  _84 = _85 + _86;
  _83 = _84 * 8;
  _82 = _83 + 18446744073709550816;
  _73 = aa_15(D) + _82;
  # VUSE <.MEM_11>
  _87 = *_73;
  _70 = (sizetype) j_1;
  _69 = (sizetype) graphite_IV.128_89;
  _68 = _69 + _70;
  _66 = _68 * 8;
  _65 = _66 + 18446744073709551320;
  _64 = aa_15(D) + _65;
  # VUSE <.MEM_11>
  _71 = *_64;
  _63 = _87 - _71;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _42 = _63 & 1073741823;
  _25 = (intD.9) graphite_IV.128_89;
  # .MEM_29 = VDEF <.MEM_11>
  ran_xD.2818[_25] = _42;
  # DEBUG iD.2823 => NULL
  # DEBUG jD.2824 => NULL
  # DEBUG jD.2824 => NULL
  # DEBUG iD.2823 => NULL
  graphite_IV.128_88 = graphite_IV.128_89 + 1;
  if (graphite_IV.128_89 < 36)
    goto <bb 13>;
  else
    goto <bb 14>;
;;    succ:       13 [97.3%]  (TRUE_VALUE)
;;                14 [2.7%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 13, loop depth 1, count 0, freq 3604, maybe hot
;;    prev block 12, next block 14, flags: (NEW)
;;    pred:       12 [97.3%]  (TRUE_VALUE)
  goto <bb 12>;
;;    succ:       12 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 14, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 13, next block 15, flags: (NEW)
;;    pred:       12 [2.7%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_24 = PHI <.MEM_29(12)>
  j_174 = j_1 + 37;
;;    succ:       15 [100.0%]  (FALLTHRU)

;;   basic block 15, loop depth 1, count 0, freq 6289, maybe hot
;;    prev block 14, next block 16, flags: (NEW)
;;    pred:       14 [100.0%]  (FALLTHRU)
;;                16 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.129_5 = PHI <0(14), graphite_IV.129_4(16)>
  # .MEM_159 = PHI <.MEM_24(14), .MEM_163(16)>
  # DEBUG jD.2824 => NULL
  # DEBUG iD.2823 => NULL
  _173 = (sizetype) j_174;
  _172 = (sizetype) graphite_IV.129_5;
  _171 = _172 + _173;
  _170 = _171 * 8;
  _169 = _170 + 18446744073709550816;
  _168 = aa_15(D) + _169;
  # VUSE <.MEM_159>
  _2 = *_168;
  _166 = (intD.9) graphite_IV.129_5;
  # VUSE <.MEM_159>
  _167 = ran_xD.2818[_166];
  _165 = _2 - _167;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _164 = _165 & 1073741823;
  _162 = (intD.9) graphite_IV.129_5;
  _161 = _162 + 37;
  # .MEM_163 = VDEF <.MEM_159>
  ran_xD.2818[_161] = _164;
  # DEBUG iD.2823 => NULL
  # DEBUG jD.2824 => NULL
  # DEBUG jD.2824 => NULL
  # DEBUG iD.2823 => NULL
  graphite_IV.129_4 = graphite_IV.129_5 + 1;
  if (graphite_IV.129_5 < 62)
    goto <bb 16>;
  else
    goto <bb 17>;
;;    succ:       16 [98.4%]  (TRUE_VALUE)
;;                17 [1.6%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 16, loop depth 1, count 0, freq 6189, maybe hot
;;    prev block 15, next block 17, flags: (NEW)
;;    pred:       15 [98.4%]  (TRUE_VALUE)
  goto <bb 15>;
;;    succ:       15 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 17, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 16, next block 1, flags: (NEW)
;;    pred:       15 [1.6%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_160 = PHI <.MEM_163(15)>
  # VUSE <.MEM_160>
  return;
;;    succ:       EXIT [100.0%] 

}



;; Function void ran_start(long int) (_Z9ran_startl, funcdef_no=1, decl_uid=2838, cgraph_uid=1, symbol_order=6)


Pass statistics:
----------------

void ran_start(long int) (long intD.12 seedD.2837)
{
  register long intD.12 ssD.2843;
  long intD.12 xD.2842[199];
  register intD.9 jD.2841;
  register intD.9 tD.2840;
  long intD.12 _22;
  long intD.12 _30;
  long intD.12 _31;
  intD.9 _35;
  long intD.12 _36;
  intD.9 _39;
  intD.9 _42;
  long intD.12 _43;
  long intD.12 _44;
  long intD.12 _45;
  long intD.12 _46;
  intD.9 _48;
  long intD.12 _49;
  long intD.12 _50;
  long intD.12 _51;
  long intD.12 _52;
  long intD.12 _55;
  long intD.12 _61;
  long intD.12 _63;
  long intD.12 _64;
  long intD.12 _65;
  long intD.12[199] * _105;
  long intD.12[100] * _122;
  long intD.12[199] * _124;

;;   basic block 2, loop depth 0, count 0, freq 10, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY [100.0%]  (FALLTHRU,EXECUTABLE)
  _22 = seed_21(D) + 2;
  # RANGE [0, 1073741822] NONZERO 1073741822
  ss_23 = _22 & 1073741822;
  # DEBUG ssD.2843 => ss_23
  # DEBUG jD.2841 => 0
  # DEBUG ssD.2843 => ss_23
  # DEBUG jD.2841 => 0
;;    succ:       3 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 3, loop depth 1, count 0, freq 979, maybe hot
;;    prev block 2, next block 4, flags: (NEW, REACHABLE)
;;    pred:       6 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                2 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 100] NONZERO 127
  # j_34 = PHI <j_29(6), 0(2)>
  # RANGE [-9223372036854775808, 9223372036854775806] NONZERO 18446744073709551614
  # ss_116 = PHI <ss_10(6), ss_23(2)>
  # .MEM_118 = PHI <.MEM_26(6), .MEM_25(D)(2)>
  # DEBUG ssD.2843 => ss_116
  # DEBUG jD.2841 => j_34
  # .MEM_26 = VDEF <.MEM_118>
  xD.2842[j_34] = ss_116;
  # RANGE [-9223372036854775808, 9223372036854775807] NONZERO 18446744073709551612
  ss_27 = ss_116 << 1;
  # DEBUG ssD.2843 => ss_27
  if (ss_27 > 1073741823)
    goto <bb 4>;
  else
    goto <bb 5>;
;;    succ:       4 [50.0%]  (TRUE_VALUE,EXECUTABLE)
;;                5 [50.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 4, loop depth 1, count 0, freq 490, maybe hot
;;    prev block 3, next block 5, flags: (NEW, REACHABLE)
;;    pred:       3 [50.0%]  (TRUE_VALUE,EXECUTABLE)
  # RANGE [2, 9223372035781033985] NONZERO 9223372036854775806
  ss_28 = ss_27 + -1073741822;
  # DEBUG ssD.2843 => ss_28
;;    succ:       5 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 5, loop depth 1, count 0, freq 979, maybe hot
;;    prev block 4, next block 6, flags: (NEW, REACHABLE)
;;    pred:       3 [50.0%]  (FALSE_VALUE,EXECUTABLE)
;;                4 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [-9223372036854775808, 9223372036854775806] NONZERO 18446744073709551614
  # ss_10 = PHI <ss_27(3), ss_28(4)>
  # DEBUG ssD.2843 => ss_10
  # RANGE [1, 100] NONZERO 127
  j_29 = j_34 + 1;
  # DEBUG jD.2841 => j_29
  # DEBUG ssD.2843 => ss_10
  # DEBUG jD.2841 => j_29
  if (j_29 == 100)
    goto <bb 7>;
  else
    goto <bb 6>;
;;    succ:       7 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                6 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 6, loop depth 1, count 0, freq 969, maybe hot
;;    prev block 5, next block 7, flags: (NEW)
;;    pred:       5 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 7, loop depth 0, count 0, freq 10, maybe hot
;;    prev block 6, next block 8, flags: (NEW, REACHABLE)
;;    pred:       5 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # VUSE <.MEM_26>
  _30 = xD.2842[1];
  _31 = _30 + 1;
  # .MEM_32 = VDEF <.MEM_26>
  xD.2842[1] = _31;
  # RANGE [0, 1073741823] NONZERO 1073741823
  ss_33 = seed_21(D) & 1073741823;
  # DEBUG ssD.2843 => ss_33
  # DEBUG tD.2840 => 69
  # DEBUG ssD.2843 => ss_33
  # DEBUG tD.2840 => 69
  goto <bb 10>;
;;    succ:       10 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 8, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 7, next block 9, flags: (NEW, REACHABLE)
;;    pred:       23 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                22 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [-2147483648, 69]
  # t_60 = PHI <t_67(23), t_90(22)>
  # RANGE [0, 536870911] NONZERO 536870911
  # ss_38 = PHI <0(23), ss_68(22)>
  # .MEM_89 = PHI <.MEM_53(23), .MEM_123(22)>
  # DEBUG ssD.2843 => ss_38
  # DEBUG tD.2840 => t_60
  if (t_60 == 0)
    goto <bb 24>;
  else
    goto <bb 9>;
;;    succ:       24 [9.9%]  (TRUE_VALUE,EXECUTABLE)
;;                9 [90.1%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 9, loop depth 1, count 0, freq 90, maybe hot
;;    prev block 8, next block 10, flags: (NEW)
;;    pred:       8 [90.1%]  (FALSE_VALUE,EXECUTABLE)
;;    succ:       10 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 10, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 9, next block 11, flags: (NEW, REACHABLE)
;;    pred:       9 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                7 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [-2147483648, 69]
  # t_90 = PHI <t_60(9), 69(7)>
  # RANGE [0, 1073741823] NONZERO 1073741823
  # ss_117 = PHI <ss_38(9), ss_33(7)>
  # .MEM_119 = PHI <.MEM_89(9), .MEM_32(7)>
  # DEBUG ssD.2843 => ss_117
  # DEBUG tD.2840 => t_90
  # DEBUG jD.2841 => 99
;;    succ:       11 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 11, loop depth 2, count 0, freq 9900, maybe hot
;;    prev block 10, next block 12, flags: (NEW, REACHABLE)
;;    pred:       12 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                10 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 99] NONZERO 127
  # j_110 = PHI <j_41(12), 99(10)>
  # .MEM_120 = PHI <.MEM_40(12), .MEM_119(10)>
  # DEBUG jD.2841 => j_110
  # RANGE [2, 198] NONZERO 255
  _35 = j_110 + j_110;
  # VUSE <.MEM_120>
  _36 = xD.2842[j_110];
  # .MEM_37 = VDEF <.MEM_120>
  xD.2842[_35] = _36;
  # RANGE [1, 197] NONZERO 255
  _39 = _35 + -1;
  # .MEM_40 = VDEF <.MEM_37>
  xD.2842[_39] = 0;
  # RANGE [0, 98] NONZERO 127
  j_41 = j_110 + -1;
  # DEBUG jD.2841 => j_41
  # DEBUG jD.2841 => j_41
  if (j_41 == 0)
    goto <bb 13>;
  else
    goto <bb 12>;
;;    succ:       13 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                12 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 12, loop depth 2, count 0, freq 9800, maybe hot
;;    prev block 11, next block 13, flags: (NEW)
;;    pred:       11 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 11>;
;;    succ:       11 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 13, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 12, next block 14, flags: (NEW)
;;    pred:       11 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;    succ:       14 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 14, loop depth 2, count 0, freq 9900, maybe hot
;;    prev block 13, next block 15, flags: (NEW, REACHABLE)
;;    pred:       13 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                15 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [99, 198] NONZERO 255
  # j_111 = PHI <198(13), j_54(15)>
  # .MEM_121 = PHI <.MEM_40(13), .MEM_53(15)>
  # DEBUG jD.2841 => j_111
  # RANGE [37, 135] NONZERO 255
  _42 = j_111 + -63;
  # VUSE <.MEM_121>
  _43 = xD.2842[_42];
  # VUSE <.MEM_121>
  _44 = xD.2842[j_111];
  _45 = _43 - _44;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _46 = _45 & 1073741823;
  # .MEM_47 = VDEF <.MEM_121>
  xD.2842[_42] = _46;
  # RANGE [0, 98] NONZERO 127
  _48 = j_111 + -100;
  # VUSE <.MEM_47>
  _49 = xD.2842[_48];
  # VUSE <.MEM_47>
  _50 = xD.2842[j_111];
  _51 = _49 - _50;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _52 = _51 & 1073741823;
  # .MEM_53 = VDEF <.MEM_47>
  xD.2842[_48] = _52;
  # RANGE [99, 197] NONZERO 255
  j_54 = j_111 + -1;
  # DEBUG jD.2841 => j_54
  # DEBUG jD.2841 => j_54
  if (j_54 == 99)
    goto <bb 16>;
  else
    goto <bb 15>;
;;    succ:       16 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                15 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 15, loop depth 2, count 0, freq 9800, maybe hot
;;    prev block 14, next block 16, flags: (NEW)
;;    pred:       14 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 14>;
;;    succ:       14 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 16, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 15, next block 17, flags: (NEW, REACHABLE)
;;    pred:       14 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # RANGE [0, 1] NONZERO 1
  _55 = ss_117 & 1;
  if (_55 != 0)
    goto <bb 17>;
  else
    goto <bb 21>;
;;    succ:       17 [50.0%]  (TRUE_VALUE,EXECUTABLE)
;;                21 [50.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 17, loop depth 1, count 0, freq 50, maybe hot
;;   Invalid sum of outgoing probabilities 1.0%
;;    prev block 16, next block 20, flags: (NEW)
;;    pred:       16 [50.0%]  (TRUE_VALUE,EXECUTABLE)
  _105 = &xD.2842 + 8;
  # .MEM_125 = VDEF <.MEM_53>
  # USE = anything 
  # CLB = anything 
  memmoveD.995 (_105, &xD.2842, 800);
;;    succ:       20 [1.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 20, loop depth 1, count 0, freq 50, maybe hot
;;    prev block 17, next block 21, flags: (NEW, REACHABLE)
;;    pred:       17 [1.0%]  (FALLTHRU,EXECUTABLE)
  # VUSE <.MEM_125>
  _61 = xD.2842[100];
  # .MEM_62 = VDEF <.MEM_125>
  xD.2842[0] = _61;
  # VUSE <.MEM_62>
  _63 = xD.2842[37];
  _64 = _63 - _61;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _65 = _64 & 1073741823;
  # .MEM_66 = VDEF <.MEM_62>
  xD.2842[37] = _65;
  goto <bb 22>;
;;    succ:       22 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 21, loop depth 1, count 0, freq 50, maybe hot
;;    prev block 20, next block 22, flags: (NEW, REACHABLE)
;;    pred:       16 [50.0%]  (FALSE_VALUE,EXECUTABLE)
  if (ss_117 != 0)
    goto <bb 22>;
  else
    goto <bb 23>;
;;    succ:       22 (TRUE_VALUE,EXECUTABLE)
;;                23 [100.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 22, loop depth 1, count 0, freq 50, maybe hot
;;    prev block 21, next block 23, flags: (NEW, REACHABLE)
;;    pred:       21 (TRUE_VALUE,EXECUTABLE)
;;                20 [100.0%]  (FALLTHRU,EXECUTABLE)
  # .MEM_123 = PHI <.MEM_53(21), .MEM_66(20)>
  # RANGE [0, 536870911] NONZERO 536870911
  ss_68 = ss_117 >> 1;
  # DEBUG ssD.2843 => ss_68
  goto <bb 8>;
;;    succ:       8 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 23, loop depth 1, count 0, freq 50, maybe hot
;;    prev block 22, next block 24, flags: (NEW, REACHABLE)
;;    pred:       21 [100.0%]  (FALSE_VALUE,EXECUTABLE)
  # RANGE [-2147483648, 68]
  t_67 = t_90 + -1;
  # DEBUG tD.2840 => t_67
  goto <bb 8>;
;;    succ:       8 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 24, loop depth 0, count 0, freq 10, maybe hot
;;   Invalid sum of outgoing probabilities 2.7%
;;    prev block 23, next block 27, flags: (NEW)
;;    pred:       8 [9.9%]  (TRUE_VALUE,EXECUTABLE)
  _122 = &ran_xD.2818 + 504;
  # .MEM_114 = VDEF <.MEM_89>
  # USE = anything 
  # CLB = anything 
  memcpyD.992 (_122, &xD.2842, 296);
;;    succ:       27 [2.7%]  (FALLTHRU,EXECUTABLE)

;;   basic block 27, loop depth 0, count 0, freq 10, maybe hot
;;   Invalid sum of outgoing probabilities 1.0%
;;    prev block 24, next block 30, flags: (NEW)
;;    pred:       24 [2.7%]  (FALLTHRU,EXECUTABLE)
  _124 = &xD.2842 + 296;
  # .MEM_73 = VDEF <.MEM_114>
  # USE = anything 
  # CLB = anything 
  memcpyD.992 (&ran_xD.2818, _124, 504);
;;    succ:       30 [1.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 30, loop depth 0, count 0, freq 10, maybe hot
;;    prev block 27, next block 31, flags: (NEW)
;;    pred:       27 [1.0%]  (FALLTHRU,EXECUTABLE)
;;    succ:       31 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 31, loop depth 1, count 0, freq 99, maybe hot
;;    prev block 30, next block 32, flags: (NEW, REACHABLE)
;;    pred:       30 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                32 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [0, 10] NONZERO 15
  # j_115 = PHI <0(30), j_79(32)>
  # .MEM_126 = PHI <.MEM_73(30), .MEM_78(32)>
  # DEBUG jD.2841 => j_115
  # .MEM_78 = VDEF <.MEM_126>
  # USE = nonlocal null { D.2835 D.2842 } (nonlocal, escaped)
  # CLB = nonlocal null { D.2835 D.2842 } (nonlocal, escaped)
  _Z9ran_arrayPliD.2821 (&xD.2842, 199);
  # RANGE [1, 10] NONZERO 15
  j_79 = j_115 + 1;
  # DEBUG jD.2841 => j_79
  # DEBUG jD.2841 => j_79
  if (j_79 == 10)
    goto <bb 33>;
  else
    goto <bb 32>;
;;    succ:       33 [10.0%]  (TRUE_VALUE,EXECUTABLE)
;;                32 [90.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 32, loop depth 1, count 0, freq 89, maybe hot
;;    prev block 31, next block 33, flags: (NEW)
;;    pred:       31 [90.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 31>;
;;    succ:       31 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 33, loop depth 0, count 0, freq 10, maybe hot
;;    prev block 32, next block 1, flags: (NEW, REACHABLE)
;;    pred:       31 [10.0%]  (TRUE_VALUE,EXECUTABLE)
  # .MEM_80 = VDEF <.MEM_78>
  ran_arr_ptrD.2836 = &ran_arr_startedD.2835;
  # .MEM_81 = VDEF <.MEM_80>
  xD.2842 ={v} {CLOBBER};
  # VUSE <.MEM_81>
  return;
;;    succ:       EXIT [100.0%] 

}


Creating dr for x[j_34]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: x
	Access function 0: {0, +, 1}_1
Creating dr for x[j_34]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: x
	Access function 0: {0, +, 1}_1
Creating dr for x[j_34]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: x
	Access function 0: {0, +, 1}_1
Creating dr for x[j_34]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: x
	Access function 0: {0, +, 1}_1
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 100
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 100
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
Creating dr for x[j_34]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: x
	Access function 0: {0, +, 1}_1
Creating dr for x[j_34]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: x
	Access function 0: {0, +, 1}_1
Creating dr for x[j_34]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: x
	Access function 0: {0, +, 1}_1
Creating dr for x[j_34]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: x
	Access function 0: {0, +, 1}_1
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 100
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
Creating dr for x[1]
analyze_innermost: success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 8
	step: 0
	aligned to: 256
	base_object: x
	Access function 0: 1
Creating dr for x[1]
analyze_innermost: success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 8
	step: 0
	aligned to: 256
	base_object: x
	Access function 0: 1
Creating dr for x[j_110]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {99, +, -1}_3
Creating dr for x[j_110]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {99, +, -1}_3
Creating dr for x[j_110]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {99, +, -1}_3
Creating dr for x[_35]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -2}_3
Creating dr for x[_35]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -2}_3
Creating dr for x[_35]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -2}_3
Creating dr for x[_39]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {197, +, -2}_3
Creating dr for x[_39]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {197, +, -2}_3
Creating dr for x[_39]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {197, +, -2}_3
Creating dr for x[j_110]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {99, +, -1}_3
Creating dr for x[j_110]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {99, +, -1}_3
Creating dr for x[j_110]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {99, +, -1}_3
Creating dr for x[_35]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -2}_3
Creating dr for x[_35]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -2}_3
Creating dr for x[_35]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -2}_3
Creating dr for x[_39]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {197, +, -2}_3
Creating dr for x[_39]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {197, +, -2}_3
Creating dr for x[_39]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {197, +, -2}_3
Analyzing # of iterations of loop 3
  exit condition [98, + , -1](no_overflow) != 0
  bounds on difference of bases: -98 ... -98
  result:
    # of iterations 98, bounded by 98
Analyzing # of iterations of loop 3
  exit condition [98, + , -1](no_overflow) != 0
  bounds on difference of bases: -98 ... -98
  result:
    # of iterations 98, bounded by 98
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Analyzing # of iterations of loop 4
  exit condition [197, + , -1](no_overflow) != 99
  bounds on difference of bases: -98 ... -98
  result:
    # of iterations 98, bounded by 98
Analyzing # of iterations of loop 4
  exit condition [197, + , -1](no_overflow) != 99
  bounds on difference of bases: -98 ... -98
  result:
    # of iterations 98, bounded by 98
Creating dr for x[100]
analyze_innermost: success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 800
	step: 0
	aligned to: 256
	base_object: x
	Access function 0: 100
Creating dr for x[100]
analyze_innermost: success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 800
	step: 0
	aligned to: 256
	base_object: x
	Access function 0: 100
Creating dr for x[0]
analyze_innermost: success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 0
	step: 0
	aligned to: 256
	base_object: x
	Access function 0: 0
Creating dr for x[0]
analyze_innermost: success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 0
	step: 0
	aligned to: 256
	base_object: x
	Access function 0: 0
Creating dr for x[37]
analyze_innermost: success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 296
	step: 0
	aligned to: 256
	base_object: x
	Access function 0: 37
Creating dr for x[37]
analyze_innermost: success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 296
	step: 0
	aligned to: 256
	base_object: x
	Access function 0: 37
Creating dr for x[37]
analyze_innermost: success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 296
	step: 0
	aligned to: 256
	base_object: x
	Access function 0: 37
Creating dr for x[37]
analyze_innermost: success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 296
	step: 0
	aligned to: 256
	base_object: x
	Access function 0: 37
Creating dr for x[j_110]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {99, +, -1}_3
Creating dr for x[j_110]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {99, +, -1}_3
Creating dr for x[j_110]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {99, +, -1}_3
Creating dr for x[_35]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -2}_3
Creating dr for x[_35]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -2}_3
Creating dr for x[_35]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -2}_3
Creating dr for x[_39]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {197, +, -2}_3
Creating dr for x[_39]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {197, +, -2}_3
Creating dr for x[_39]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {197, +, -2}_3
Creating dr for x[j_110]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {99, +, -1}_3
Creating dr for x[j_110]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {99, +, -1}_3
Creating dr for x[j_110]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {99, +, -1}_3
Creating dr for x[_35]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -2}_3
Creating dr for x[_35]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -2}_3
Creating dr for x[_35]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -2}_3
Creating dr for x[_39]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {197, +, -2}_3
Creating dr for x[_39]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {197, +, -2}_3
Creating dr for x[_39]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {197, +, -2}_3
Analyzing # of iterations of loop 3
  exit condition [98, + , -1](no_overflow) != 0
  bounds on difference of bases: -98 ... -98
  result:
    # of iterations 98, bounded by 98
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Analyzing # of iterations of loop 4
  exit condition [197, + , -1](no_overflow) != 99
  bounds on difference of bases: -98 ... -98
  result:
    # of iterations 98, bounded by 98
Creating dr for x[100]
analyze_innermost: success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 800
	step: 0
	aligned to: 256
	base_object: x
	Access function 0: 100
Creating dr for x[100]
analyze_innermost: success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 800
	step: 0
	aligned to: 256
	base_object: x
	Access function 0: 100
Creating dr for x[0]
analyze_innermost: success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 0
	step: 0
	aligned to: 256
	base_object: x
	Access function 0: 0
Creating dr for x[0]
analyze_innermost: success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 0
	step: 0
	aligned to: 256
	base_object: x
	Access function 0: 0
Creating dr for x[37]
analyze_innermost: success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 296
	step: 0
	aligned to: 256
	base_object: x
	Access function 0: 37
Creating dr for x[37]
analyze_innermost: success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 296
	step: 0
	aligned to: 256
	base_object: x
	Access function 0: 37
Creating dr for x[37]
analyze_innermost: success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 296
	step: 0
	aligned to: 256
	base_object: x
	Access function 0: 37
Creating dr for x[37]
analyze_innermost: success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 296
	step: 0
	aligned to: 256
	base_object: x
	Access function 0: 37
Analyzing # of iterations of loop 8
  exit condition [1, + , 1](no_overflow) != 10
  bounds on difference of bases: 9 ... 9
  result:
    # of iterations 9, bounded by 9
Analyzing # of iterations of loop 8
  exit condition [1, + , 1](no_overflow) != 10
  bounds on difference of bases: 9 ... 9
  result:
    # of iterations 9, bounded by 9
Analyzing # of iterations of loop 8
  exit condition [1, + , 1](no_overflow) != 10
  bounds on difference of bases: 9 ... 9
  result:
    # of iterations 9, bounded by 9
Creating dr for ran_arr_ptr
analyze_innermost: success.
	base_address: &ran_arr_ptr
	offset from base address: 0
	constant offset from base address: 0
	step: 0
	aligned to: 256
	base_object: ran_arr_ptr

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:2)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:6)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:6)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:2)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:2)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:8, LOOPS:2, CONDITIONS:2, STMTS:30)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:2, LOOPS:0, CONDITIONS:0, STMTS:8)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

number of SCoPs: 2

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:10)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:17)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Global statistics (BBS:35, LOOPS:5, CONDITIONS:8, STMTS:89)

Global profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)
Creating dr for x[j_110]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {99, +, -1}_3
Creating dr for x[_35]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -2}_3
Creating dr for x[_39]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {197, +, -2}_3

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 98; c1 += 1)
  S_11(c1);


Removing basic block 46
basic block 46, loop depth 1
 pred:      
goto <bb 44>;
 succ:       44



Updating SSA:
Registering new PHI nodes in block #43
Registering new PHI nodes in block #45
Registering new PHI nodes in block #11
Updating SSA information for statement x[_39] = 0;
Registering new PHI nodes in block #12
Registering new PHI nodes in block #13
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #41
Registering new PHI nodes in block #37
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16
Registering new PHI nodes in block #36
Registering new PHI nodes in block #21
Registering new PHI nodes in block #23
Registering new PHI nodes in block #17
Registering new PHI nodes in block #20
Registering new PHI nodes in block #22
Registering new PHI nodes in block #39
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Registering new PHI nodes in block #24
Registering new PHI nodes in block #35
Registering new PHI nodes in block #27
Registering new PHI nodes in block #30
Registering new PHI nodes in block #31
Registering new PHI nodes in block #32
Registering new PHI nodes in block #33
Registering new PHI nodes in block #34

DFA Statistics for void ran_start(long int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                             82        656b
DEF operands                             34        272b
VUSE operands                            23        184b
VDEF operands                            14        112b
PHI nodes                                18       1872b
PHI arguments                            36       1728b
---------------------------------------------------------
Total memory used by DFA/SSA data                 4824b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_75 -> { .MEM_40 }
Incremental SSA update started at block: 43
Number of blocks in CFG: 47
Number of blocks to update: 8 ( 17%)
Affected blocks: 11 12 13 14 37 43 44 45


Applying pattern match.pd:822, generic-match.c:7035
Applying pattern match.pd:439, generic-match.c:3611
Applying pattern match.pd:625, generic-match.c:1309

Updating SSA:
creating PHI node in block #48 for .MEM
creating PHI node in block #51 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #3
Updating SSA information for statement x[j_34] = ss_116;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #6
Registering new PHI nodes in block #7
Registering new PHI nodes in block #38
Updating SSA information for statement _30 = x[1];
Updating SSA information for statement x[1] = _31;
Registering new PHI nodes in block #10
Registering new PHI nodes in block #40
Registering new PHI nodes in block #43
Registering new PHI nodes in block #47
Registering new PHI nodes in block #51
Registering new PHI nodes in block #55
Updating SSA information for statement _69 = x[_71];
Updating SSA information for statement x[_58] = _69;
Updating SSA information for statement x[_100] = 0;
Registering new PHI nodes in block #53
Registering new PHI nodes in block #52
Registering new PHI nodes in block #54
Registering new PHI nodes in block #49
Registering new PHI nodes in block #50
Registering new PHI nodes in block #48
Registering new PHI nodes in block #45
Registering new PHI nodes in block #11
Updating SSA information for statement _36 = x[j_110];
Updating SSA information for statement x[_35] = _36;
Updating SSA information for statement x[_39] = 0;
Registering new PHI nodes in block #12
Registering new PHI nodes in block #13
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #41
Registering new PHI nodes in block #37
Registering new PHI nodes in block #14
Updating SSA information for statement _43 = x[_42];
Updating SSA information for statement _44 = x[j_111];
Updating SSA information for statement x[_42] = _46;
Updating SSA information for statement _49 = x[_48];
Updating SSA information for statement _50 = x[j_111];
Updating SSA information for statement x[_48] = _52;
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16
Registering new PHI nodes in block #36
Registering new PHI nodes in block #21
Registering new PHI nodes in block #23
Registering new PHI nodes in block #17
Updating SSA information for statement __builtin_memmove (_105, &x, 800);
Registering new PHI nodes in block #20
Updating SSA information for statement _61 = x[100];
Updating SSA information for statement x[0] = _61;
Updating SSA information for statement _63 = x[37];
Updating SSA information for statement x[37] = _65;
Registering new PHI nodes in block #22
Registering new PHI nodes in block #39
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Registering new PHI nodes in block #24
Registering new PHI nodes in block #35
Updating SSA information for statement __builtin_memcpy (_122, &x, 296);
Registering new PHI nodes in block #27
Updating SSA information for statement __builtin_memcpy (&ran_x, _124, 504);
Registering new PHI nodes in block #30
Registering new PHI nodes in block #31
Updating SSA information for statement ran_array (&x, 199);
Registering new PHI nodes in block #32
Registering new PHI nodes in block #33
Registering new PHI nodes in block #34
Updating SSA information for statement ran_arr_ptr = &ran_arr_started;
Updating SSA information for statement x ={v} {CLOBBER};
Updating SSA information for statement return;

DFA Statistics for void ran_start(long int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                             96        768b
DEF operands                             44        352b
VUSE operands                            26        208b
VDEF operands                            16        128b
PHI nodes                                21       2184b
PHI arguments                            42       2016b
---------------------------------------------------------
Total memory used by DFA/SSA data                 5656b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_59 -> { .MEM_40 }
_69 -> { _36 }
.MEM_72 -> { .MEM_37 }

Symbols to be put in SSA form
{ D.3748 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 56
Number of blocks to update: 48 ( 86%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 20 21 22 23 24 27 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 47 48 49 50 51 52 53 54 55



0 loops carried no dependency.
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {135, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Creating dr for x[j_111]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {198, +, -1}_4
Creating dr for x[_48]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &x
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: x
	Access function 0: {98, +, -1}_4
Analyzing # of iterations of loop 4
  exit condition [197, + , -1](no_overflow) != 99
  bounds on difference of bases: -98 ... -98
  result:
    # of iterations 98, bounded by 98

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 98; c1 += 1)
  S_14(c1);


Removing basic block 61
basic block 61, loop depth 1
 pred:      
goto <bb 59>;
 succ:       59



Updating SSA:
Registering new PHI nodes in block #58
Registering new PHI nodes in block #60
Registering new PHI nodes in block #14
Updating SSA information for statement x[_48] = _52;
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16
Registering new PHI nodes in block #59
Registering new PHI nodes in block #57
Registering new PHI nodes in block #56
Registering new PHI nodes in block #36
Registering new PHI nodes in block #21
Registering new PHI nodes in block #23
Registering new PHI nodes in block #17
Updating SSA information for statement __builtin_memmove (_105, &x, 800);
Registering new PHI nodes in block #20
Registering new PHI nodes in block #22
Registering new PHI nodes in block #39
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Registering new PHI nodes in block #24
Registering new PHI nodes in block #35
Registering new PHI nodes in block #27
Registering new PHI nodes in block #30
Registering new PHI nodes in block #31
Registering new PHI nodes in block #32
Registering new PHI nodes in block #33
Registering new PHI nodes in block #34

DFA Statistics for void ran_start(long int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                             96        768b
DEF operands                             44        352b
VUSE operands                            26        208b
VDEF operands                            16        128b
PHI nodes                                22       2288b
PHI arguments                            44       2112b
---------------------------------------------------------
Total memory used by DFA/SSA data                 5856b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_107 -> { .MEM_53 }
Incremental SSA update started at block: 58
Number of blocks in CFG: 62
Number of blocks to update: 11 ( 18%)
Affected blocks: 8 14 15 16 17 21 22 23 58 59 60


Applying pattern match.pd:822, generic-match.c:7035
Applying pattern match.pd:439, generic-match.c:3611
Applying pattern match.pd:625, generic-match.c:1309
Applying pattern match.pd:822, generic-match.c:7035
Applying pattern match.pd:439, generic-match.c:3611
Applying pattern match.pd:625, generic-match.c:1309
Applying pattern match.pd:822, generic-match.c:7035
Applying pattern match.pd:439, generic-match.c:3611
Applying pattern match.pd:625, generic-match.c:1309

Updating SSA:
creating PHI node in block #63 for .MEM
creating PHI node in block #66 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #3
Updating SSA information for statement x[j_34] = ss_116;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #6
Registering new PHI nodes in block #7
Registering new PHI nodes in block #38
Updating SSA information for statement _30 = x[1];
Updating SSA information for statement x[1] = _31;
Registering new PHI nodes in block #10
Registering new PHI nodes in block #40
Registering new PHI nodes in block #43
Registering new PHI nodes in block #47
Registering new PHI nodes in block #51
Registering new PHI nodes in block #55
Updating SSA information for statement _69 = x[_71];
Updating SSA information for statement x[_58] = _69;
Updating SSA information for statement x[_100] = 0;
Registering new PHI nodes in block #53
Registering new PHI nodes in block #52
Registering new PHI nodes in block #54
Registering new PHI nodes in block #49
Registering new PHI nodes in block #50
Registering new PHI nodes in block #48
Registering new PHI nodes in block #45
Registering new PHI nodes in block #11
Updating SSA information for statement _36 = x[j_110];
Updating SSA information for statement x[_35] = _36;
Updating SSA information for statement x[_39] = 0;
Registering new PHI nodes in block #12
Registering new PHI nodes in block #13
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #41
Registering new PHI nodes in block #37
Registering new PHI nodes in block #58
Registering new PHI nodes in block #62
Registering new PHI nodes in block #66
Registering new PHI nodes in block #70
Updating SSA information for statement _94 = x[_91];
Updating SSA information for statement _11 = x[_5];
Updating SSA information for statement _2 = _94 - _11;
Updating SSA information for statement _1 = _2 & 1073741823;
Updating SSA information for statement x[_91] = _1;
Updating SSA information for statement _101 = x[_99];
Updating SSA information for statement _20 = x[_5];
Updating SSA information for statement _87 = _101 - _20;
Updating SSA information for statement _24 = _87 & 1073741823;
Updating SSA information for statement x[_99] = _24;
Registering new PHI nodes in block #68
Registering new PHI nodes in block #67
Registering new PHI nodes in block #69
Registering new PHI nodes in block #64
Registering new PHI nodes in block #65
Registering new PHI nodes in block #63
Registering new PHI nodes in block #60
Registering new PHI nodes in block #14
Updating SSA information for statement _43 = x[_42];
Updating SSA information for statement _44 = x[j_111];
Updating SSA information for statement _45 = _43 - _44;
Updating SSA information for statement _46 = _45 & 1073741823;
Updating SSA information for statement x[_42] = _46;
Updating SSA information for statement _49 = x[_48];
Updating SSA information for statement _50 = x[j_111];
Updating SSA information for statement _51 = _49 - _50;
Updating SSA information for statement _52 = _51 & 1073741823;
Updating SSA information for statement x[_48] = _52;
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16
Registering new PHI nodes in block #59
Registering new PHI nodes in block #57
Registering new PHI nodes in block #56
Registering new PHI nodes in block #36
Registering new PHI nodes in block #21
Registering new PHI nodes in block #23
Registering new PHI nodes in block #17
Updating SSA information for statement __builtin_memmove (_105, &x, 800);
Registering new PHI nodes in block #20
Updating SSA information for statement _61 = x[100];
Updating SSA information for statement x[0] = _61;
Updating SSA information for statement _63 = x[37];
Updating SSA information for statement x[37] = _65;
Registering new PHI nodes in block #22
Registering new PHI nodes in block #39
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Registering new PHI nodes in block #24
Registering new PHI nodes in block #35
Updating SSA information for statement __builtin_memcpy (_122, &x, 296);
Registering new PHI nodes in block #27
Updating SSA information for statement __builtin_memcpy (&ran_x, _124, 504);
Registering new PHI nodes in block #30
Registering new PHI nodes in block #31
Updating SSA information for statement ran_array (&x, 199);
Registering new PHI nodes in block #32
Registering new PHI nodes in block #33
Registering new PHI nodes in block #34
Updating SSA information for statement ran_arr_ptr = &ran_arr_started;
Updating SSA information for statement x ={v} {CLOBBER};
Updating SSA information for statement return;

DFA Statistics for void ran_start(long int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            118        944b
DEF operands                             59        472b
VUSE operands                            32        256b
VDEF operands                            18        144b
PHI nodes                                25       2600b
PHI arguments                            50       2400b
---------------------------------------------------------
Total memory used by DFA/SSA data                 6816b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

_1 -> { _46 }
_2 -> { _45 }
_11 -> { _44 }
.MEM_19 -> { .MEM_53 }
_20 -> { _50 }
_24 -> { _52 }
_87 -> { _51 }
_94 -> { _43 }
.MEM_95 -> { .MEM_47 }
_101 -> { _49 }

Symbols to be put in SSA form
{ D.3748 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 71
Number of blocks to update: 62 ( 87%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 20 21 22 23 24 27 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 47 48 49 50 51 52 53 54 55 56 57 58 59 60 62 63 64 65 66 67 68 69 70



0 loops carried no dependency.
Removing basic block 7
basic block 7, loop depth 0
 pred:      
 succ:       38


Merging blocks 10 and 40
Removing basic block 13
basic block 13, loop depth 1
 pred:      
goto <bb 44>;
 succ:       44


Removing basic block 16
basic block 16, loop depth 1
 pred:      
goto <bb 59>;
 succ:       59


Merging blocks 17 and 20
Merging blocks 22 and 39
Removing basic block 24
basic block 24, loop depth 0
 pred:      
 succ:       35


Removing basic block 33
basic block 33, loop depth 0
 pred:      
 succ:       34


Merging blocks 35 and 27
Removing basic block 37
basic block 37, loop depth 1
 pred:      
 succ:       58


Removing basic block 41
basic block 41, loop depth 1
 pred:      
 succ:       58


Removing basic block 42
basic block 42, loop depth 1
 pred:      
goto <bb 58>;
 succ:       58


Removing basic block 12
basic block 12, loop depth 2
 pred:       11
goto <bb 11>;
 succ:       11


Removing basic block 11
basic block 11, loop depth 2
 pred:       43
# j_110 = PHI <99(43)>
# DEBUG j => j_110
_35 = j_110 + j_110;
_36 = x[j_110];
x[_35] = _36;
_39 = _35 + -1;
x[_39] = 0;
j_41 = j_110 + -1;
# DEBUG j => j_41
# DEBUG j => j_41
if (j_41 == 0)
 succ:       44


Removing basic block 43
basic block 43, loop depth 1
 pred:      
 succ:       47


Removing basic block 45
basic block 45, loop depth 1
 pred:      
 succ:       44


Removing basic block 50
basic block 50, loop depth 1
 pred:       47
goto <bb 48>;
 succ:       48


Removing basic block 49
basic block 49, loop depth 1
 pred:      
 succ:       48


Merging blocks 51 and 55
Removing basic block 54
basic block 54, loop depth 1
 pred:      
 succ:       48


Removing basic block 56
basic block 56, loop depth 1
 pred:      
 succ:       36


Removing basic block 57
basic block 57, loop depth 1
 pred:      
goto <bb 36>;
 succ:       36


Removing basic block 15
basic block 15, loop depth 2
 pred:       14
goto <bb 14>;
 succ:       14


Removing basic block 14
basic block 14, loop depth 2
 pred:       58
# j_111 = PHI <198(58)>
# DEBUG j => j_111
_42 = j_111 + -63;
_43 = x[_42];
_44 = x[j_111];
_45 = _43 - _44;
_46 = _45 & 1073741823;
x[_42] = _46;
_48 = j_111 + -100;
_49 = x[_48];
_50 = x[j_111];
_51 = _49 - _50;
_52 = _51 & 1073741823;
x[_48] = _52;
j_54 = j_111 + -1;
# DEBUG j => j_54
# DEBUG j => j_54
if (j_54 == 99)
 succ:       59


Removing basic block 58
basic block 58, loop depth 1
 pred:      
 succ:       62


Removing basic block 60
basic block 60, loop depth 1
 pred:      
 succ:       59


Removing basic block 65
basic block 65, loop depth 1
 pred:       62
goto <bb 63>;
 succ:       63


Removing basic block 64
basic block 64, loop depth 1
 pred:      
 succ:       63


Merging blocks 66 and 70
Removing basic block 69
basic block 69, loop depth 1
 pred:      
 succ:       63


Merging blocks 10 and 47
Merging blocks 35 and 30
Merging blocks 48 and 44
Merging blocks 48 and 62
Merging blocks 51 and 53
Merging blocks 63 and 59
Merging blocks 63 and 36
Merging blocks 66 and 68
fix_loop_structure: removing loop 4
fix_loop_structure: removing loop 3
Analyzing # of iterations of loop 8
  exit condition [1, + , 1](no_overflow) != 10
  bounds on difference of bases: 9 ... 9
  result:
    # of iterations 9, bounded by 9
Analyzing # of iterations of loop 10
  exit condition [0, + , 1](no_overflow) < 98
  bounds on difference of bases: 98 ... 98
  result:
    # of iterations 98, bounded by 98
Analyzing # of iterations of loop 9
  exit condition [0, + , 1](no_overflow) < 98
  bounds on difference of bases: 98 ... 98
  result:
    # of iterations 98, bounded by 98
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 100
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
1 edges in bb 2 predicted to even probabilities
Predictions for bb 3
  no prediction heuristics: 50.0%
  combined heuristics: 50.0%
1 edges in bb 4 predicted to even probabilities
Predictions for bb 5
  DS theory heuristics (ignored): 0.4%
  first match heuristics: 1.0%
  combined heuristics: 1.0%
  opcode values nonequal (on trees) heuristics (ignored): 28.0%
  loop iterations heuristics: 1.0%
1 edges in bb 6 predicted to even probabilities
1 edges in bb 7 predicted to even probabilities
Predictions for bb 8
  DS theory heuristics (ignored): 9.0%
  first match heuristics: 9.0%
  combined heuristics: 9.0%
  loop exit heuristics: 9.0%
1 edges in bb 9 predicted to even probabilities
1 edges in bb 10 predicted to even probabilities
Predictions for bb 11
  DS theory heuristics (ignored): 99.0%
  first match heuristics: 99.0%
  combined heuristics: 99.0%
  loop iterations heuristics: 99.0%
1 edges in bb 12 predicted to even probabilities
1 edges in bb 13 predicted to even probabilities
Predictions for bb 14
  DS theory heuristics (ignored): 99.0%
  first match heuristics: 99.0%
  combined heuristics: 99.0%
  loop iterations heuristics: 99.0%
1 edges in bb 15 predicted to even probabilities
Predictions for bb 16
  DS theory heuristics: 29.0%
  first match heuristics (ignored): 29.0%
  combined heuristics: 29.0%
  call heuristics: 29.0%
1 edges in bb 17 predicted to even probabilities
Predictions for bb 18
  no prediction heuristics: 50.0%
  combined heuristics: 50.0%
1 edges in bb 19 predicted to even probabilities
1 edges in bb 20 predicted to even probabilities
1 edges in bb 21 predicted to even probabilities
Predictions for bb 22
  DS theory heuristics (ignored): 2.7%
  first match heuristics: 10.0%
  combined heuristics: 10.0%
  opcode values nonequal (on trees) heuristics (ignored): 28.0%
  early return (on trees) heuristics (ignored): 39.0%
  loop iterations heuristics: 10.0%
1 edges in bb 23 predicted to even probabilities
1 edges in bb 24 predicted to even probabilities
loop_0 (header = 0, latch = 1, niter = )
{
  bb_2 (preds = {bb_0 }, succs = {bb_3 })
  {
    <bb 2>:
    _22 = seed_21(D) + 2;
    ss_23 = _22 & 1073741822;
    # DEBUG ss => ss_23
    # DEBUG j => 0
    # DEBUG ss => ss_23
    # DEBUG j => 0

  }
  bb_7 (preds = {bb_5 }, succs = {bb_10 })
  {
    <bb 7>:
    # VUSE <.MEM_26>
    _30 = x[1];
    _31 = _30 + 1;
    # .MEM_32 = VDEF <.MEM_26>
    x[1] = _31;
    ss_33 = seed_21(D) & 1073741823;
    # DEBUG ss => ss_33
    # DEBUG t => 69
    # DEBUG ss => ss_33
    # DEBUG t => 69
    goto <bb 10>;

  }
  bb_21 (preds = {bb_8 }, succs = {bb_22 })
  {
    <bb 21>:
    _122 = &ran_x + 504;
    # .MEM_114 = VDEF <.MEM_89>
    __builtin_memcpy (_122, &x, 296);
    _124 = &x + 296;
    # .MEM_73 = VDEF <.MEM_114>
    __builtin_memcpy (&ran_x, _124, 504);

  }
  bb_24 (preds = {bb_22 }, succs = {bb_1 })
  {
    <bb 24>:
    # .MEM_80 = VDEF <.MEM_78>
    ran_arr_ptr = &ran_arr_started;
    # .MEM_81 = VDEF <.MEM_80>
    x ={v} {CLOBBER};
    # VUSE <.MEM_81>
    return;

  }
  loop_8 (header = 22, latch = 23, niter = , upper_bound = 9, estimate = 9)
  {
    bb_22 (preds = {bb_21 bb_23 }, succs = {bb_24 bb_23 })
    {
      <bb 22>:
      # j_115 = PHI <0(21), j_79(23)>
      # .MEM_126 = PHI <.MEM_73(21), .MEM_78(23)>
      # DEBUG j => j_115
      # .MEM_78 = VDEF <.MEM_126>
      ran_array (&x, 199);
      j_79 = j_115 + 1;
      # DEBUG j => j_79
      # DEBUG j => j_79
      if (j_79 == 10)
        goto <bb 24>;
      else
        goto <bb 23>;

    }
    bb_23 (preds = {bb_22 }, succs = {bb_22 })
    {
      <bb 23>:
      goto <bb 22>;

    }
  }
  loop_2 (header = 10, latch = 9, niter = )
  {
    bb_8 (preds = {bb_20 bb_19 }, succs = {bb_21 bb_9 })
    {
      <bb 8>:
      # t_60 = PHI <t_67(20), t_90(19)>
      # ss_38 = PHI <0(20), ss_68(19)>
      # .MEM_89 = PHI <.MEM_77(20), .MEM_123(19)>
      # DEBUG ss => ss_38
      # DEBUG t => t_60
      if (t_60 == 0)
        goto <bb 21>;
      else
        goto <bb 9>;

    }
    bb_9 (preds = {bb_8 }, succs = {bb_10 })
    {
      <bb 9>:

    }
    bb_10 (preds = {bb_9 bb_7 }, succs = {bb_11 })
    {
      <bb 10>:
      # t_90 = PHI <t_60(9), 69(7)>
      # ss_117 = PHI <ss_38(9), ss_33(7)>
      # .MEM_119 = PHI <.MEM_89(9), .MEM_32(7)>
      # DEBUG ss => ss_117
      # DEBUG t => t_90
      # DEBUG j => 99

    }
    bb_13 (preds = {bb_11 }, succs = {bb_14 })
    {
      <bb 13>:
      # .MEM_98 = PHI <.MEM_59(11)>

    }
    bb_16 (preds = {bb_14 }, succs = {bb_17 bb_18 })
    {
      <bb 16>:
      # .MEM_77 = PHI <.MEM_19(14)>
      _55 = ss_117 & 1;
      if (_55 != 0)
        goto <bb 17>;
      else
        goto <bb 18>;

    }
    bb_17 (preds = {bb_16 }, succs = {bb_19 })
    {
      <bb 17>:
      _105 = &x + 8;
      # .MEM_125 = VDEF <.MEM_77>
      __builtin_memmove (_105, &x, 800);
      # VUSE <.MEM_125>
      _61 = x[100];
      # .MEM_62 = VDEF <.MEM_125>
      x[0] = _61;
      # VUSE <.MEM_62>
      _63 = x[37];
      _64 = _63 - _61;
      _65 = _64 & 1073741823;
      # .MEM_66 = VDEF <.MEM_62>
      x[37] = _65;
      goto <bb 19>;

    }
    bb_18 (preds = {bb_16 }, succs = {bb_19 bb_20 })
    {
      <bb 18>:
      if (ss_117 != 0)
        goto <bb 19>;
      else
        goto <bb 20>;

    }
    bb_19 (preds = {bb_18 bb_17 }, succs = {bb_8 })
    {
      <bb 19>:
      # .MEM_123 = PHI <.MEM_77(18), .MEM_66(17)>
      ss_68 = ss_117 >> 1;
      # DEBUG ss => ss_68
      goto <bb 8>;

    }
    bb_20 (preds = {bb_18 }, succs = {bb_8 })
    {
      <bb 20>:
      t_67 = t_90 + -1;
      # DEBUG t => t_67
      goto <bb 8>;

    }
    loop_10 (header = 14, latch = 15, niter = )
    {
      bb_14 (preds = {bb_13 bb_15 }, succs = {bb_15 bb_16 })
      {
        <bb 14>:
        # graphite_IV.240_106 = PHI <0(13), graphite_IV.240_102(15)>
        # .MEM_85 = PHI <.MEM_98(13), .MEM_19(15)>
        # DEBUG j => NULL
        _92 = (int) graphite_IV.240_106;
        _91 = 135 - _92;
        # VUSE <.MEM_85>
        _94 = x[_91];
        _9 = (int) graphite_IV.240_106;
        _5 = 198 - _9;
        # VUSE <.MEM_85>
        _11 = x[_5];
        _2 = _94 - _11;
        _1 = _2 & 1073741823;
        # .MEM_95 = VDEF <.MEM_85>
        x[_91] = _1;
        _97 = (int) graphite_IV.240_106;
        _99 = 98 - _97;
        # VUSE <.MEM_95>
        _101 = x[_99];
        # VUSE <.MEM_95>
        _20 = x[_5];
        _87 = _101 - _20;
        _24 = _87 & 1073741823;
        # .MEM_19 = VDEF <.MEM_95>
        x[_99] = _24;
        # DEBUG j => NULL
        # DEBUG j => NULL
        graphite_IV.240_102 = graphite_IV.240_106 + 1;
        if (graphite_IV.240_106 < 98)
          goto <bb 15>;
        else
          goto <bb 16>;

      }
      bb_15 (preds = {bb_14 }, succs = {bb_14 })
      {
        <bb 15>:
        goto <bb 14>;

      }
    }
    loop_9 (header = 11, latch = 12, niter = )
    {
      bb_11 (preds = {bb_10 bb_12 }, succs = {bb_12 bb_13 })
      {
        <bb 11>:
        # graphite_IV.239_76 = PHI <0(10), graphite_IV.239_113(12)>
        # .MEM_96 = PHI <.MEM_119(10), .MEM_59(12)>
        # DEBUG j => NULL
        _70 = (int) graphite_IV.239_76;
        _71 = 99 - _70;
        # VUSE <.MEM_96>
        _69 = x[_71];
        _112 = (int) graphite_IV.239_76;
        _57 = 99 - _112;
        _58 = _57 * 2;
        # .MEM_72 = VDEF <.MEM_96>
        x[_58] = _69;
        _104 = (int) graphite_IV.239_76;
        _103 = _104 * -2;
        _100 = _103 + 197;
        # .MEM_59 = VDEF <.MEM_72>
        x[_100] = 0;
        # DEBUG j => NULL
        # DEBUG j => NULL
        graphite_IV.239_113 = graphite_IV.239_76 + 1;
        if (graphite_IV.239_76 < 98)
          goto <bb 12>;
        else
          goto <bb 13>;

      }
      bb_12 (preds = {bb_11 }, succs = {bb_11 })
      {
        <bb 12>:
        goto <bb 11>;

      }
    }
  }
  loop_1 (header = 3, latch = 6, niter = , upper_bound = 99, estimate = 99)
  {
    bb_3 (preds = {bb_6 bb_2 }, succs = {bb_4 bb_5 })
    {
      <bb 3>:
      # j_34 = PHI <j_29(6), 0(2)>
      # ss_116 = PHI <ss_10(6), ss_23(2)>
      # .MEM_118 = PHI <.MEM_26(6), .MEM_25(D)(2)>
      # DEBUG ss => ss_116
      # DEBUG j => j_34
      # .MEM_26 = VDEF <.MEM_118>
      x[j_34] = ss_116;
      ss_27 = ss_116 << 1;
      # DEBUG ss => ss_27
      if (ss_27 > 1073741823)
        goto <bb 4>;
      else
        goto <bb 5>;

    }
    bb_4 (preds = {bb_3 }, succs = {bb_5 })
    {
      <bb 4>:
      ss_28 = ss_27 + -1073741822;
      # DEBUG ss => ss_28

    }
    bb_5 (preds = {bb_3 bb_4 }, succs = {bb_7 bb_6 })
    {
      <bb 5>:
      # ss_10 = PHI <ss_27(3), ss_28(4)>
      # DEBUG ss => ss_10
      j_29 = j_34 + 1;
      # DEBUG j => j_29
      # DEBUG ss => ss_10
      # DEBUG j => j_29
      if (j_29 == 100)
        goto <bb 7>;
      else
        goto <bb 6>;

    }
    bb_6 (preds = {bb_5 }, succs = {bb_3 })
    {
      <bb 6>:
      goto <bb 3>;

    }
  }
}

Pass statistics:
----------------

void ran_start(long int) (long intD.12 seedD.2837)
{
  signed long graphite_IV.240D.4081;
  long intD.12 D.4080;
  long intD.12 D.4079;
  long intD.12 D.4078;
  long intD.12 D.4077;
  long intD.12 D.4076;
  long intD.12 D.4075;
  long intD.12 D.4074;
  long intD.12 D.4073;
  signed long graphite_IV.239D.4072;
  long intD.12 D.4071;
  register long intD.12 ssD.2843;
  long intD.12 xD.2842[199];
  register intD.9 jD.2841;
  register intD.9 tD.2840;
  long intD.12 _1;
  long intD.12 _2;
  intD.9 _5;
  intD.9 _9;
  long intD.12 _11;
  long intD.12 _20;
  long intD.12 _22;
  long intD.12 _24;
  long intD.12 _30;
  long intD.12 _31;
  long intD.12 _55;
  intD.9 _57;
  intD.9 _58;
  long intD.12 _61;
  long intD.12 _63;
  long intD.12 _64;
  long intD.12 _65;
  long intD.12 _69;
  intD.9 _70;
  intD.9 _71;
  long intD.12 _87;
  intD.9 _91;
  intD.9 _92;
  long intD.12 _94;
  intD.9 _97;
  intD.9 _99;
  intD.9 _100;
  long intD.12 _101;
  intD.9 _103;
  intD.9 _104;
  long intD.12[199] * _105;
  intD.9 _112;
  long intD.12[100] * _122;
  long intD.12[199] * _124;

;;   basic block 2, loop depth 0, count 0, freq 9, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY [100.0%]  (FALLTHRU,EXECUTABLE)
  _22 = seed_21(D) + 2;
  # RANGE [0, 1073741822] NONZERO 1073741822
  ss_23 = _22 & 1073741822;
  # DEBUG ssD.2843 => ss_23
  # DEBUG jD.2841 => 0
  # DEBUG ssD.2843 => ss_23
  # DEBUG jD.2841 => 0
;;    succ:       3 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 3, loop depth 1, count 0, freq 909, maybe hot
;;    prev block 2, next block 4, flags: (NEW, REACHABLE)
;;    pred:       6 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                2 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 100] NONZERO 127
  # j_34 = PHI <j_29(6), 0(2)>
  # RANGE [-9223372036854775808, 9223372036854775806] NONZERO 18446744073709551614
  # ss_116 = PHI <ss_10(6), ss_23(2)>
  # .MEM_118 = PHI <.MEM_26(6), .MEM_25(D)(2)>
  # DEBUG ssD.2843 => ss_116
  # DEBUG jD.2841 => j_34
  # .MEM_26 = VDEF <.MEM_118>
  xD.2842[j_34] = ss_116;
  # RANGE [-9223372036854775808, 9223372036854775807] NONZERO 18446744073709551612
  ss_27 = ss_116 << 1;
  # DEBUG ssD.2843 => ss_27
  if (ss_27 > 1073741823)
    goto <bb 4>;
  else
    goto <bb 5>;
;;    succ:       4 [50.0%]  (TRUE_VALUE,EXECUTABLE)
;;                5 [50.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 4, loop depth 1, count 0, freq 454, maybe hot
;;    prev block 3, next block 5, flags: (NEW, REACHABLE)
;;    pred:       3 [50.0%]  (TRUE_VALUE,EXECUTABLE)
  # RANGE [2, 9223372035781033985] NONZERO 9223372036854775806
  ss_28 = ss_27 + -1073741822;
  # DEBUG ssD.2843 => ss_28
;;    succ:       5 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 5, loop depth 1, count 0, freq 909, maybe hot
;;    prev block 4, next block 6, flags: (NEW, REACHABLE)
;;    pred:       3 [50.0%]  (FALSE_VALUE,EXECUTABLE)
;;                4 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [-9223372036854775808, 9223372036854775806] NONZERO 18446744073709551614
  # ss_10 = PHI <ss_27(3), ss_28(4)>
  # DEBUG ssD.2843 => ss_10
  # RANGE [1, 100] NONZERO 127
  j_29 = j_34 + 1;
  # DEBUG jD.2841 => j_29
  # DEBUG ssD.2843 => ss_10
  # DEBUG jD.2841 => j_29
  if (j_29 == 100)
    goto <bb 7>;
  else
    goto <bb 6>;
;;    succ:       7 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                6 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 6, loop depth 1, count 0, freq 900, maybe hot
;;    prev block 5, next block 7, flags: (NEW)
;;    pred:       5 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 7, loop depth 0, count 0, freq 9, maybe hot
;;    prev block 6, next block 8, flags: (NEW)
;;    pred:       5 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # VUSE <.MEM_26>
  _30 = xD.2842[1];
  _31 = _30 + 1;
  # .MEM_32 = VDEF <.MEM_26>
  xD.2842[1] = _31;
  # RANGE [0, 1073741823] NONZERO 1073741823
  ss_33 = seed_21(D) & 1073741823;
  # DEBUG ssD.2843 => ss_33
  # DEBUG tD.2840 => 69
  # DEBUG ssD.2843 => ss_33
  # DEBUG tD.2840 => 69
  goto <bb 10>;
;;    succ:       10 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 8, loop depth 1, count 0, freq 101, maybe hot
;;    prev block 7, next block 9, flags: (NEW, REACHABLE)
;;    pred:       20 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                19 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [-2147483648, 69]
  # t_60 = PHI <t_67(20), t_90(19)>
  # RANGE [0, 536870911] NONZERO 536870911
  # ss_38 = PHI <0(20), ss_68(19)>
  # .MEM_89 = PHI <.MEM_77(20), .MEM_123(19)>
  # DEBUG ssD.2843 => ss_38
  # DEBUG tD.2840 => t_60
  if (t_60 == 0)
    goto <bb 21>;
  else
    goto <bb 9>;
;;    succ:       21 [9.0%]  (TRUE_VALUE,EXECUTABLE)
;;                9 [91.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 9, loop depth 1, count 0, freq 92, maybe hot
;;    prev block 8, next block 10, flags: (NEW)
;;    pred:       8 [91.0%]  (FALSE_VALUE,EXECUTABLE)
;;    succ:       10 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 10, loop depth 1, count 0, freq 101, maybe hot
;;    prev block 9, next block 11, flags: (NEW, REACHABLE)
;;    pred:       9 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                7 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [-2147483648, 69]
  # t_90 = PHI <t_60(9), 69(7)>
  # RANGE [0, 1073741823] NONZERO 1073741823
  # ss_117 = PHI <ss_38(9), ss_33(7)>
  # .MEM_119 = PHI <.MEM_89(9), .MEM_32(7)>
  # DEBUG ssD.2843 => ss_117
  # DEBUG tD.2840 => t_90
  # DEBUG jD.2841 => 99
;;    succ:       11 [100.0%]  (FALLTHRU)

;;   basic block 11, loop depth 2, count 0, freq 10000, maybe hot
;;    prev block 10, next block 12, flags: (NEW)
;;    pred:       10 [100.0%]  (FALLTHRU)
;;                12 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.239_76 = PHI <0(10), graphite_IV.239_113(12)>
  # .MEM_96 = PHI <.MEM_119(10), .MEM_59(12)>
  # DEBUG jD.2841 => NULL
  _70 = (intD.9) graphite_IV.239_76;
  _71 = 99 - _70;
  # VUSE <.MEM_96>
  _69 = xD.2842[_71];
  _112 = (intD.9) graphite_IV.239_76;
  _57 = 99 - _112;
  _58 = _57 * 2;
  # .MEM_72 = VDEF <.MEM_96>
  xD.2842[_58] = _69;
  _104 = (intD.9) graphite_IV.239_76;
  _103 = _104 * -2;
  _100 = _103 + 197;
  # .MEM_59 = VDEF <.MEM_72>
  xD.2842[_100] = 0;
  # DEBUG jD.2841 => NULL
  # DEBUG jD.2841 => NULL
  graphite_IV.239_113 = graphite_IV.239_76 + 1;
  if (graphite_IV.239_76 < 98)
    goto <bb 12>;
  else
    goto <bb 13>;
;;    succ:       12 [99.0%]  (TRUE_VALUE)
;;                13 [1.0%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 12, loop depth 2, count 0, freq 9899, maybe hot
;;    prev block 11, next block 13, flags: (NEW)
;;    pred:       11 [99.0%]  (TRUE_VALUE)
  goto <bb 11>;
;;    succ:       11 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 13, loop depth 1, count 0, freq 101, maybe hot
;;    prev block 12, next block 14, flags: (NEW)
;;    pred:       11 [1.0%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_98 = PHI <.MEM_59(11)>
;;    succ:       14 [100.0%]  (FALLTHRU)

;;   basic block 14, loop depth 2, count 0, freq 10000, maybe hot
;;    prev block 13, next block 15, flags: (NEW)
;;    pred:       13 [100.0%]  (FALLTHRU)
;;                15 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.240_106 = PHI <0(13), graphite_IV.240_102(15)>
  # .MEM_85 = PHI <.MEM_98(13), .MEM_19(15)>
  # DEBUG jD.2841 => NULL
  _92 = (intD.9) graphite_IV.240_106;
  _91 = 135 - _92;
  # VUSE <.MEM_85>
  _94 = xD.2842[_91];
  _9 = (intD.9) graphite_IV.240_106;
  _5 = 198 - _9;
  # VUSE <.MEM_85>
  _11 = xD.2842[_5];
  _2 = _94 - _11;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _1 = _2 & 1073741823;
  # .MEM_95 = VDEF <.MEM_85>
  xD.2842[_91] = _1;
  _97 = (intD.9) graphite_IV.240_106;
  _99 = 98 - _97;
  # VUSE <.MEM_95>
  _101 = xD.2842[_99];
  # VUSE <.MEM_95>
  _20 = xD.2842[_5];
  _87 = _101 - _20;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _24 = _87 & 1073741823;
  # .MEM_19 = VDEF <.MEM_95>
  xD.2842[_99] = _24;
  # DEBUG jD.2841 => NULL
  # DEBUG jD.2841 => NULL
  graphite_IV.240_102 = graphite_IV.240_106 + 1;
  if (graphite_IV.240_106 < 98)
    goto <bb 15>;
  else
    goto <bb 16>;
;;    succ:       15 [99.0%]  (TRUE_VALUE)
;;                16 [1.0%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 15, loop depth 2, count 0, freq 9899, maybe hot
;;    prev block 14, next block 16, flags: (NEW)
;;    pred:       14 [99.0%]  (TRUE_VALUE)
  goto <bb 14>;
;;    succ:       14 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 16, loop depth 1, count 0, freq 101, maybe hot
;;    prev block 15, next block 17, flags: (NEW)
;;    pred:       14 [1.0%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_77 = PHI <.MEM_19(14)>
  # RANGE [0, 1] NONZERO 1
  _55 = ss_117 & 1;
  if (_55 != 0)
    goto <bb 17>;
  else
    goto <bb 18>;
;;    succ:       17 [29.0%]  (TRUE_VALUE,EXECUTABLE)
;;                18 [71.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 17, loop depth 1, count 0, freq 29, maybe hot
;;    prev block 16, next block 18, flags: (NEW, REACHABLE)
;;    pred:       16 [29.0%]  (TRUE_VALUE,EXECUTABLE)
  _105 = &xD.2842 + 8;
  # .MEM_125 = VDEF <.MEM_77>
  # USE = anything 
  # CLB = anything 
  memmoveD.995 (_105, &xD.2842, 800);
  # VUSE <.MEM_125>
  _61 = xD.2842[100];
  # .MEM_62 = VDEF <.MEM_125>
  xD.2842[0] = _61;
  # VUSE <.MEM_62>
  _63 = xD.2842[37];
  _64 = _63 - _61;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _65 = _64 & 1073741823;
  # .MEM_66 = VDEF <.MEM_62>
  xD.2842[37] = _65;
  goto <bb 19>;
;;    succ:       19 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 18, loop depth 1, count 0, freq 72, maybe hot
;;    prev block 17, next block 19, flags: (NEW, REACHABLE)
;;    pred:       16 [71.0%]  (FALSE_VALUE,EXECUTABLE)
  if (ss_117 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;
;;    succ:       19 [50.0%]  (TRUE_VALUE,EXECUTABLE)
;;                20 [50.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 19, loop depth 1, count 0, freq 65, maybe hot
;;    prev block 18, next block 20, flags: (NEW, REACHABLE)
;;    pred:       18 [50.0%]  (TRUE_VALUE,EXECUTABLE)
;;                17 [100.0%]  (FALLTHRU,EXECUTABLE)
  # .MEM_123 = PHI <.MEM_77(18), .MEM_66(17)>
  # RANGE [0, 536870911] NONZERO 536870911
  ss_68 = ss_117 >> 1;
  # DEBUG ssD.2843 => ss_68
  goto <bb 8>;
;;    succ:       8 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 20, loop depth 1, count 0, freq 36, maybe hot
;;    prev block 19, next block 21, flags: (NEW, REACHABLE)
;;    pred:       18 [50.0%]  (FALSE_VALUE,EXECUTABLE)
  # RANGE [-2147483648, 68]
  t_67 = t_90 + -1;
  # DEBUG tD.2840 => t_67
  goto <bb 8>;
;;    succ:       8 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 21, loop depth 0, count 0, freq 9, maybe hot
;;    prev block 20, next block 22, flags: (NEW)
;;    pred:       8 [9.0%]  (TRUE_VALUE,EXECUTABLE)
  _122 = &ran_xD.2818 + 504;
  # .MEM_114 = VDEF <.MEM_89>
  # USE = anything 
  # CLB = anything 
  memcpyD.992 (_122, &xD.2842, 296);
  _124 = &xD.2842 + 296;
  # .MEM_73 = VDEF <.MEM_114>
  # USE = anything 
  # CLB = anything 
  memcpyD.992 (&ran_xD.2818, _124, 504);
;;    succ:       22 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 22, loop depth 1, count 0, freq 91, maybe hot
;;    prev block 21, next block 23, flags: (NEW, REACHABLE)
;;    pred:       21 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                23 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [0, 10] NONZERO 15
  # j_115 = PHI <0(21), j_79(23)>
  # .MEM_126 = PHI <.MEM_73(21), .MEM_78(23)>
  # DEBUG jD.2841 => j_115
  # .MEM_78 = VDEF <.MEM_126>
  # USE = nonlocal null { D.2835 D.2842 } (nonlocal, escaped)
  # CLB = nonlocal null { D.2835 D.2842 } (nonlocal, escaped)
  _Z9ran_arrayPliD.2821 (&xD.2842, 199);
  # RANGE [1, 10] NONZERO 15
  j_79 = j_115 + 1;
  # DEBUG jD.2841 => j_79
  # DEBUG jD.2841 => j_79
  if (j_79 == 10)
    goto <bb 24>;
  else
    goto <bb 23>;
;;    succ:       24 [10.0%]  (TRUE_VALUE,EXECUTABLE)
;;                23 [90.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 23, loop depth 1, count 0, freq 82, maybe hot
;;    prev block 22, next block 24, flags: (NEW)
;;    pred:       22 [90.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 22>;
;;    succ:       22 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 24, loop depth 0, count 0, freq 9, maybe hot
;;    prev block 23, next block 1, flags: (NEW)
;;    pred:       22 [10.0%]  (TRUE_VALUE,EXECUTABLE)
  # .MEM_80 = VDEF <.MEM_78>
  ran_arr_ptrD.2836 = &ran_arr_startedD.2835;
  # .MEM_81 = VDEF <.MEM_80>
  xD.2842 ={v} {CLOBBER};
  # VUSE <.MEM_81>
  return;
;;    succ:       EXIT [100.0%] 

}



;; Function int rng_main() (_Z8rng_mainv, funcdef_no=33, decl_uid=3633, cgraph_uid=33, symbol_order=38)


Pass statistics:
----------------

int rng_main() ()
{
  register intD.9 jD.4173;
  register intD.9 iD.4172;
  long intD.12 aD.3636[2009];
  register intD.9 mD.3635;
  long intD.12 _9;
  long intD.12 _13;
  long unsigned intD.14 _24;
  long unsigned intD.14 _25;
  long intD.12 * _26;
  sizetype _27;
  long intD.12 * _28;
  long intD.12 _29;
  sizetype _30;
  long intD.12 * _31;
  long intD.12 _32;
  long intD.12 _33;
  long intD.12 _34;
  long unsigned intD.14 _38;
  long unsigned intD.14 _39;
  sizetype _40;
  long intD.12 * _41;
  long intD.12 _42;
  sizetype _43;
  long intD.12 * _44;
  long intD.12 _45;
  long intD.12 _46;
  long intD.12 _47;
  long unsigned intD.14 _52;
  long unsigned intD.14 _53;
  sizetype _54;
  long intD.12 * _55;
  long intD.12 _56;
  intD.9 _57;
  long intD.12 _58;
  long intD.12 _59;
  long intD.12 _60;

;;   basic block 2, loop depth 0, count 0, freq 1, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY [100.0%]  (FALLTHRU,EXECUTABLE)
  # .MEM_6 = VDEF <.MEM_5(D)>
  # USE = nonlocal null { D.3636 } (escaped)
  # CLB = nonlocal null { D.3636 } (escaped)
  _Z9ran_startlD.2838 (310952);
  # DEBUG mD.3635 => 0
  # DEBUG mD.3635 => 0
;;    succ:       3 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 3, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 2, next block 4, flags: (NEW, REACHABLE)
;;    pred:       4 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                2 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 2010] NONZERO 2047
  # m_65 = PHI <m_8(4), 0(2)>
  # .MEM_94 = PHI <.MEM_7(4), .MEM_6(2)>
  # DEBUG mD.3635 => m_65
  # .MEM_7 = VDEF <.MEM_94>
  # USE = nonlocal null { D.3636 } (escaped)
  # CLB = nonlocal null { D.3636 } (escaped)
  _Z9ran_arrayPli.constprop.0D.3763 (&aD.3636);
  # RANGE [1, 2010] NONZERO 2047
  m_8 = m_65 + 1;
  # DEBUG mD.3635 => m_8
  # DEBUG mD.3635 => m_8
  if (m_8 == 2010)
    goto <bb 5>;
  else
    goto <bb 4>;
;;    succ:       5 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                4 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 4, loop depth 1, count 0, freq 99, maybe hot
;;    prev block 3, next block 5, flags: (NEW)
;;    pred:       3 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 5, loop depth 0, count 0, freq 1, maybe hot
;;    prev block 4, next block 6, flags: (NEW, REACHABLE)
;;    pred:       3 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # VUSE <.MEM_7>
  _9 = aD.3636[0];
  # DEBUG __fmtD.3757 => "%ld\n"
  # .MEM_14 = VDEF <.MEM_7>
  # USE = nonlocal null { D.3636 } (escaped)
  # CLB = nonlocal null { D.3636 } (escaped)
  __printf_chkD.1500 (1, "%ld\n", _9);
  # .MEM_10 = VDEF <.MEM_14>
  # USE = nonlocal null { D.3636 } (escaped)
  # CLB = nonlocal null { D.3636 } (escaped)
  _Z9ran_startlD.2838 (310952);
  # DEBUG mD.3635 => 0
  # DEBUG mD.3635 => 0
;;    succ:       6 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 6, loop depth 1, count 0, freq 100, maybe hot
;;   Invalid sum of outgoing probabilities 1.0%
;;    prev block 5, next block 9, flags: (NEW, REACHABLE)
;;    pred:       19 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                5 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 1010] NONZERO 1023
  # m_63 = PHI <m_12(19), 0(5)>
  # .MEM_95 = PHI <.MEM_74(19), .MEM_10(5)>
  # DEBUG mD.3635 => m_63
  # DEBUG jD.4173 => 0
  # .MEM_97 = VDEF <.MEM_95>
  # USE = anything 
  # CLB = anything 
  memcpyD.992 (&aD.3636, &ran_xD.2818, 800);
;;    succ:       9 [1.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 9, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 6, next block 10, flags: (NEW)
;;    pred:       6 [1.0%]  (FALLTHRU,EXECUTABLE)
;;    succ:       10 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 10, loop depth 2, count 0, freq 1011, maybe hot
;;    prev block 9, next block 11, flags: (NEW, REACHABLE)
;;    pred:       9 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                11 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [100, 2147483646] NONZERO 2047
  # j_98 = PHI <100(9), j_35(11)>
  # .MEM_103 = PHI <.MEM_97(9), .MEM_72(11)>
  # DEBUG jD.4173 => j_98
  # RANGE [100, 2008] NONZERO 2047
  _24 = (long unsigned intD.14) j_98;
  # RANGE [800, 16064] NONZERO 16376
  _25 = _24 * 8;
  # PT = { D.3636 } (escaped)
  # ALIGN = 8, MISALIGN = 0
  _26 = &aD.3636 + _25;
  # RANGE [0, 15264] NONZERO 16376
  _27 = _25 + 18446744073709550816;
  # PT = { D.3636 } (escaped)
  # ALIGN = 8, MISALIGN = 0
  _28 = &aD.3636 + _27;
  # VUSE <.MEM_103>
  _29 = *_28;
  # RANGE [504, 15768] NONZERO 16376
  _30 = _25 + 18446744073709551320;
  # PT = { D.3636 } (escaped)
  # ALIGN = 8, MISALIGN = 0
  _31 = &aD.3636 + _30;
  # VUSE <.MEM_103>
  _32 = *_31;
  _33 = _29 - _32;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _34 = _33 & 1073741823;
  # .MEM_72 = VDEF <.MEM_103>
  *_26 = _34;
  # RANGE [101, 2009] NONZERO 2047
  j_35 = j_98 + 1;
  # DEBUG jD.4173 => j_35
  # DEBUG jD.4173 => j_35
  if (j_35 > 2008)
    goto <bb 12>;
  else
    goto <bb 11>;
;;    succ:       12 [9.9%]  (TRUE_VALUE,EXECUTABLE)
;;                11 [90.1%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 11, loop depth 2, count 0, freq 911, maybe hot
;;    prev block 10, next block 12, flags: (NEW)
;;    pred:       10 [90.1%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 10>;
;;    succ:       10 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 12, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 11, next block 13, flags: (NEW)
;;    pred:       10 [9.9%]  (TRUE_VALUE,EXECUTABLE)
;;    succ:       13 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 13, loop depth 2, count 0, freq 3702, maybe hot
;;    prev block 12, next block 14, flags: (NEW, REACHABLE)
;;    pred:       12 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                14 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [0, 37] NONZERO 63
  # i_99 = PHI <0(12), i_48(14)>
  # RANGE [2009, 2147483647] NONZERO 2147483647
  # j_100 = PHI <2009(12), j_49(14)>
  # .MEM_104 = PHI <.MEM_72(12), .MEM_73(14)>
  # DEBUG jD.4173 => j_100
  # DEBUG iD.4172 => i_99
  # RANGE [0, 18446744073709551615] NONZERO 2147483647
  _38 = (long unsigned intD.14) j_100;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _39 = _38 * 8;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _40 = _39 + 18446744073709550816;
  # PT = { D.3636 } (escaped)
  # ALIGN = 8, MISALIGN = 0
  _41 = &aD.3636 + _40;
  # VUSE <.MEM_104>
  _42 = *_41;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _43 = _39 + 18446744073709551320;
  # PT = { D.3636 } (escaped)
  # ALIGN = 8, MISALIGN = 0
  _44 = &aD.3636 + _43;
  # VUSE <.MEM_104>
  _45 = *_44;
  _46 = _42 - _45;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _47 = _46 & 1073741823;
  # .MEM_73 = VDEF <.MEM_104>
  ran_xD.2818[i_99] = _47;
  # RANGE [1, 37] NONZERO 63
  i_48 = i_99 + 1;
  # DEBUG iD.4172 => i_48
  # RANGE [2010, 2147483647] NONZERO 2147483647
  j_49 = j_100 + 1;
  # DEBUG jD.4173 => j_49
  # DEBUG jD.4173 => j_49
  # DEBUG iD.4172 => i_48
  if (i_48 == 37)
    goto <bb 15>;
  else
    goto <bb 14>;
;;    succ:       15 [2.7%]  (TRUE_VALUE,EXECUTABLE)
;;                14 [97.3%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 14, loop depth 2, count 0, freq 3602, maybe hot
;;    prev block 13, next block 15, flags: (NEW)
;;    pred:       13 [97.3%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 13>;
;;    succ:       13 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 15, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 14, next block 16, flags: (NEW)
;;    pred:       13 [2.7%]  (TRUE_VALUE,EXECUTABLE)
;;    succ:       16 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 16, loop depth 2, count 0, freq 9900, maybe hot
;;    prev block 15, next block 17, flags: (NEW, REACHABLE)
;;    pred:       15 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                17 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [37, 137] NONZERO 127
  # i_101 = PHI <37(15), i_61(17)>
  # RANGE [2009, 2147483647] NONZERO 2147483647
  # j_102 = PHI <2046(15), j_62(17)>
  # .MEM_105 = PHI <.MEM_73(15), .MEM_74(17)>
  # DEBUG jD.4173 => j_102
  # DEBUG iD.4172 => i_101
  # RANGE [0, 18446744073709551615] NONZERO 2147483647
  _52 = (long unsigned intD.14) j_102;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _53 = _52 * 8;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _54 = _53 + 18446744073709550816;
  # PT = { D.3636 } (escaped)
  # ALIGN = 8, MISALIGN = 0
  _55 = &aD.3636 + _54;
  # VUSE <.MEM_105>
  _56 = *_55;
  # RANGE [0, 62] NONZERO 63
  _57 = i_101 + -37;
  # VUSE <.MEM_105>
  _58 = ran_xD.2818[_57];
  _59 = _56 - _58;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _60 = _59 & 1073741823;
  # .MEM_74 = VDEF <.MEM_105>
  ran_xD.2818[i_101] = _60;
  # RANGE [38, 100] NONZERO 127
  i_61 = i_101 + 1;
  # DEBUG iD.4172 => i_61
  # RANGE [2010, 2147483647] NONZERO 2147483647
  j_62 = j_102 + 1;
  # DEBUG jD.4173 => j_62
  # DEBUG jD.4173 => j_62
  # DEBUG iD.4172 => i_61
  if (i_61 > 99)
    goto <bb 18>;
  else
    goto <bb 17>;
;;    succ:       18 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                17 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 17, loop depth 2, count 0, freq 9800, maybe hot
;;    prev block 16, next block 18, flags: (NEW)
;;    pred:       16 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 16>;
;;    succ:       16 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 18, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 17, next block 19, flags: (NEW, REACHABLE)
;;    pred:       16 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # RANGE [1, 1010] NONZERO 1023
  m_12 = m_63 + 1;
  # DEBUG mD.3635 => m_12
  # DEBUG mD.3635 => m_12
  if (m_12 == 1010)
    goto <bb 20>;
  else
    goto <bb 19>;
;;    succ:       20 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                19 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 19, loop depth 1, count 0, freq 99, maybe hot
;;    prev block 18, next block 20, flags: (NEW)
;;    pred:       18 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 6>;
;;    succ:       6 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 20, loop depth 0, count 0, freq 1, maybe hot
;;    prev block 19, next block 1, flags: (NEW, REACHABLE)
;;    pred:       18 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # VUSE <.MEM_74>
  _13 = aD.3636[0];
  # DEBUG __fmtD.3759 => "%ld\n"
  # .MEM_16 = VDEF <.MEM_74>
  # USE = nonlocal null { D.3636 } (escaped)
  # CLB = nonlocal null { D.3636 } (escaped)
  __printf_chkD.1500 (1, "%ld\n", _13);
  # .MEM_15 = VDEF <.MEM_16>
  aD.3636 ={v} {CLOBBER};
  # VUSE <.MEM_15>
  return 0;
;;    succ:       EXIT [100.0%] 

}


Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 2010
  bounds on difference of bases: 2009 ... 2009
  result:
    # of iterations 2009, bounded by 2009
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 2010
  bounds on difference of bases: 2009 ... 2009
  result:
    # of iterations 2009, bounded by 2009
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 2010
  bounds on difference of bases: 2009 ... 2009
  result:
    # of iterations 2009, bounded by 2009
Creating dr for a[0]
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 0
	aligned to: 256
	base_object: a
	Access function 0: 0
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {800B, +, 8}_5
Analyzing # of iterations of loop 5
  exit condition [101, + , 1](no_overflow) <= 2008
  bounds on difference of bases: 1907 ... 1907
  result:
    # of iterations 1908, bounded by 1908
Analyzing # of iterations of loop 5
  exit condition [101, + , 1](no_overflow) <= 2008
  bounds on difference of bases: 1907 ... 1907
  result:
    # of iterations 1908, bounded by 1908
Creating dr for *_41
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_41
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_41
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for ran_x[i_99]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for ran_x[i_99]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for ran_x[i_99]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for *_41
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_41
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_41
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for ran_x[i_99]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for ran_x[i_99]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for ran_x[i_99]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Analyzing # of iterations of loop 4
  exit condition [1, + , 1](no_overflow) != 37
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Analyzing # of iterations of loop 4
  exit condition [1, + , 1](no_overflow) != 37
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Creating dr for *_55
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for *_55
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for *_55
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for ran_x[_57]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_3
Creating dr for ran_x[_57]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_3
Creating dr for ran_x[_57]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_3
Creating dr for ran_x[i_101]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_3
Creating dr for ran_x[i_101]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_3
Creating dr for ran_x[i_101]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_3
Creating dr for *_55
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for *_55
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for *_55
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for ran_x[_57]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_3
Creating dr for ran_x[_57]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_3
Creating dr for ran_x[_57]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_3
Creating dr for ran_x[i_101]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_3
Creating dr for ran_x[i_101]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_3
Creating dr for ran_x[i_101]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_3
Analyzing # of iterations of loop 3
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62
Analyzing # of iterations of loop 3
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62
Analyzing # of iterations of loop 2
  exit condition [1, + , 1](no_overflow) != 1010
  bounds on difference of bases: 1009 ... 1009
  result:
    # of iterations 1009, bounded by 1009
Analyzing # of iterations of loop 2
  exit condition [1, + , 1](no_overflow) != 1010
  bounds on difference of bases: 1009 ... 1009
  result:
    # of iterations 1009, bounded by 1009
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {800B, +, 8}_5
Analyzing # of iterations of loop 5
  exit condition [101, + , 1](no_overflow) <= 2008
  bounds on difference of bases: 1907 ... 1907
  result:
    # of iterations 1908, bounded by 1908
Creating dr for *_41
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_41
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_41
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for ran_x[i_99]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for ran_x[i_99]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for ran_x[i_99]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for *_41
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_41
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_41
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for ran_x[i_99]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for ran_x[i_99]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Creating dr for ran_x[i_99]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4
Analyzing # of iterations of loop 4
  exit condition [1, + , 1](no_overflow) != 37
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Creating dr for *_55
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for *_55
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for *_55
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for ran_x[_57]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_3
Creating dr for ran_x[_57]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_3
Creating dr for ran_x[_57]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_3
Creating dr for ran_x[i_101]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_3
Creating dr for ran_x[i_101]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_3
Creating dr for ran_x[i_101]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_3
Creating dr for *_55
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for *_55
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for *_55
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for ran_x[_57]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_3
Creating dr for ran_x[_57]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_3
Creating dr for ran_x[_57]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_3
Creating dr for ran_x[i_101]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_3
Creating dr for ran_x[i_101]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_3
Creating dr for ran_x[i_101]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_3
Analyzing # of iterations of loop 3
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62
Analyzing # of iterations of loop 2
  exit condition [1, + , 1](no_overflow) != 1010
  bounds on difference of bases: 1009 ... 1009
  result:
    # of iterations 1009, bounded by 1009
Creating dr for a[0]
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 0
	aligned to: 256
	base_object: a
	Access function 0: 0

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:12, LOOPS:3, CONDITIONS:3, STMTS:56)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

number of SCoPs: 3

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:20)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:19)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:17)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Global statistics (BBS:24, LOOPS:5, CONDITIONS:5, STMTS:83)

Global profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)
Creating dr for *_41
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for ran_x[i_99]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_4

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 36; c1 += 1)
  S_13(c1);


Removing basic block 31
basic block 31, loop depth 1
 pred:      
goto <bb 29>;
 succ:       29



Updating SSA:
Registering new PHI nodes in block #28
Registering new PHI nodes in block #30
Registering new PHI nodes in block #13
Updating SSA information for statement ran_x[i_99] = _47;
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #16
Registering new PHI nodes in block #17
Registering new PHI nodes in block #18
Registering new PHI nodes in block #22
Registering new PHI nodes in block #19
Registering new PHI nodes in block #20
Registering new PHI nodes in block #21

DFA Statistics for int rng_main()

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                             74        592b
DEF operands                             39        312b
VUSE operands                            19        152b
VDEF operands                            10         80b
PHI nodes                                13       1352b
PHI arguments                            26       1248b
---------------------------------------------------------
Total memory used by DFA/SSA data                 3736b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_21 -> { .MEM_73 }
Incremental SSA update started at block: 28
Number of blocks in CFG: 32
Number of blocks to update: 8 ( 25%)
Affected blocks: 13 14 15 16 23 28 29 30


Applying pattern match.pd:397, generic-match.c:4039
Applying pattern match.pd:397, generic-match.c:4039

Updating SSA:
creating PHI node in block #33 for .MEM
creating PHI node in block #36 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Updating SSA information for statement ran_start (310952);
Registering new PHI nodes in block #3
Updating SSA information for statement ran_array.constprop (&a);
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #25
Updating SSA information for statement _9 = a[0];
Updating SSA information for statement __printf_chk (1, "%ld\n", _9);
Updating SSA information for statement ran_start (310952);
Registering new PHI nodes in block #6
Updating SSA information for statement __builtin_memcpy (&a, &ran_x, 800);
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Updating SSA information for statement _29 = *_28;
Updating SSA information for statement _32 = *_31;
Updating SSA information for statement *_26 = _34;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #24
Registering new PHI nodes in block #28
Registering new PHI nodes in block #32
Registering new PHI nodes in block #36
Registering new PHI nodes in block #40
Updating SSA information for statement _149 = *_145;
Updating SSA information for statement _143 = *_118;
Updating SSA information for statement _117 = _149 - _143;
Updating SSA information for statement _116 = _117 & 1073741823;
Updating SSA information for statement ran_x[_114] = _116;
Registering new PHI nodes in block #38
Registering new PHI nodes in block #37
Registering new PHI nodes in block #39
Registering new PHI nodes in block #34
Registering new PHI nodes in block #35
Registering new PHI nodes in block #33
Registering new PHI nodes in block #30
Registering new PHI nodes in block #13
Updating SSA information for statement _42 = *_41;
Updating SSA information for statement _45 = *_44;
Updating SSA information for statement _46 = _42 - _45;
Updating SSA information for statement _47 = _46 & 1073741823;
Updating SSA information for statement ran_x[i_99] = _47;
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #16
Updating SSA information for statement _56 = *_55;
Updating SSA information for statement _58 = ran_x[_57];
Updating SSA information for statement ran_x[i_101] = _60;
Registering new PHI nodes in block #17
Registering new PHI nodes in block #18
Registering new PHI nodes in block #22
Registering new PHI nodes in block #19
Registering new PHI nodes in block #20
Registering new PHI nodes in block #21
Updating SSA information for statement _13 = a[0];
Updating SSA information for statement __printf_chk (1, "%ld\n", _13);
Updating SSA information for statement a ={v} {CLOBBER};
Updating SSA information for statement return 0;

DFA Statistics for int rng_main()

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                             92        736b
DEF operands                             53        424b
VUSE operands                            22        176b
VDEF operands                            11         88b
PHI nodes                                16       1664b
PHI arguments                            32       1536b
---------------------------------------------------------
Total memory used by DFA/SSA data                 4624b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_115 -> { .MEM_73 }
_116 -> { _47 }
_117 -> { _46 }
_143 -> { _45 }
_149 -> { _42 }

Symbols to be put in SSA form
{ D.3750 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 41
Number of blocks to update: 37 ( 90%)
Affected blocks: 0 2 3 4 5 6 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 32 33 34 35 36 37 38 39 40



1 loops carried no dependency.
Creating dr for *_55
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for ran_x[_57]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {0, +, 1}_3
Creating dr for ran_x[i_101]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_x
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_x
	Access function 0: {37, +, 1}_3
Analyzing # of iterations of loop 3
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 62; c1 += 1)
  S_16(c1);


Removing basic block 46
basic block 46, loop depth 1
 pred:      
goto <bb 44>;
 succ:       44



Updating SSA:
Registering new PHI nodes in block #6
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #24
Registering new PHI nodes in block #28
Registering new PHI nodes in block #32
Registering new PHI nodes in block #36
Registering new PHI nodes in block #40
Registering new PHI nodes in block #38
Registering new PHI nodes in block #37
Registering new PHI nodes in block #39
Registering new PHI nodes in block #34
Registering new PHI nodes in block #35
Registering new PHI nodes in block #33
Registering new PHI nodes in block #30
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #43
Registering new PHI nodes in block #45
Registering new PHI nodes in block #16
Updating SSA information for statement ran_x[i_101] = _60;
Registering new PHI nodes in block #17
Registering new PHI nodes in block #18
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #41
Registering new PHI nodes in block #22
Registering new PHI nodes in block #19
Registering new PHI nodes in block #20
Registering new PHI nodes in block #21
Updating SSA information for statement _13 = a[0];
Updating SSA information for statement __printf_chk (1, "%ld\n", _13);

DFA Statistics for int rng_main()

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                             92        736b
DEF operands                             53        424b
VUSE operands                            22        176b
VDEF operands                            11         88b
PHI nodes                                17       1768b
PHI arguments                            34       1632b
---------------------------------------------------------
Total memory used by DFA/SSA data                 4824b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_107 -> { .MEM_74 }
Incremental SSA update started at block: 6
Number of blocks in CFG: 47
Number of blocks to update: 9 ( 19%)
Affected blocks: 6 16 17 18 19 21 43 44 45


Applying pattern match.pd:397, generic-match.c:4039

Updating SSA:
creating PHI node in block #48 for .MEM
creating PHI node in block #51 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Updating SSA information for statement ran_start (310952);
Registering new PHI nodes in block #3
Updating SSA information for statement ran_array.constprop (&a);
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #25
Updating SSA information for statement _9 = a[0];
Updating SSA information for statement __printf_chk (1, "%ld\n", _9);
Updating SSA information for statement ran_start (310952);
Registering new PHI nodes in block #6
Updating SSA information for statement __builtin_memcpy (&a, &ran_x, 800);
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Updating SSA information for statement _29 = *_28;
Updating SSA information for statement _32 = *_31;
Updating SSA information for statement *_26 = _34;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #24
Registering new PHI nodes in block #28
Registering new PHI nodes in block #32
Registering new PHI nodes in block #36
Registering new PHI nodes in block #40
Updating SSA information for statement _149 = *_145;
Updating SSA information for statement _143 = *_118;
Updating SSA information for statement ran_x[_114] = _116;
Registering new PHI nodes in block #38
Registering new PHI nodes in block #37
Registering new PHI nodes in block #39
Registering new PHI nodes in block #34
Registering new PHI nodes in block #35
Registering new PHI nodes in block #33
Registering new PHI nodes in block #30
Registering new PHI nodes in block #13
Updating SSA information for statement _42 = *_41;
Updating SSA information for statement _45 = *_44;
Updating SSA information for statement ran_x[i_99] = _47;
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #43
Registering new PHI nodes in block #47
Registering new PHI nodes in block #51
Registering new PHI nodes in block #55
Updating SSA information for statement _92 = *_88;
Updating SSA information for statement _87 = ran_x[_86];
Updating SSA information for statement _85 = _92 - _87;
Updating SSA information for statement _84 = _85 & 1073741823;
Updating SSA information for statement ran_x[_81] = _84;
Registering new PHI nodes in block #53
Registering new PHI nodes in block #52
Registering new PHI nodes in block #54
Registering new PHI nodes in block #49
Registering new PHI nodes in block #50
Registering new PHI nodes in block #48
Registering new PHI nodes in block #45
Registering new PHI nodes in block #16
Updating SSA information for statement _56 = *_55;
Updating SSA information for statement _58 = ran_x[_57];
Updating SSA information for statement _59 = _56 - _58;
Updating SSA information for statement _60 = _59 & 1073741823;
Updating SSA information for statement ran_x[i_101] = _60;
Registering new PHI nodes in block #17
Registering new PHI nodes in block #18
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #41
Registering new PHI nodes in block #22
Registering new PHI nodes in block #19
Registering new PHI nodes in block #20
Registering new PHI nodes in block #21
Updating SSA information for statement _13 = a[0];
Updating SSA information for statement __printf_chk (1, "%ld\n", _13);
Updating SSA information for statement a ={v} {CLOBBER};
Updating SSA information for statement return 0;

DFA Statistics for int rng_main()

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            108        864b
DEF operands                             65        520b
VUSE operands                            25        200b
VDEF operands                            12         96b
PHI nodes                                20       2080b
PHI arguments                            40       1920b
---------------------------------------------------------
Total memory used by DFA/SSA data                 5680b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_83 -> { .MEM_74 }
_84 -> { _60 }
_85 -> { _59 }
_87 -> { _58 }
_92 -> { _56 }

Symbols to be put in SSA form
{ D.3750 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 56
Number of blocks to update: 51 ( 91%)
Affected blocks: 0 2 3 4 5 6 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 32 33 34 35 36 37 38 39 40 41 42 43 44 45 47 48 49 50 51 52 53 54 55



1 loops carried no dependency.
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(long int *)&a]
	Access function 0: {800B, +, 8}_5
Analyzing # of iterations of loop 5
  exit condition [101, + , 1](no_overflow) <= 2008
  bounds on difference of bases: 1907 ... 1907
  result:
    # of iterations 1908, bounded by 1908

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 1908; c1 += 1)
  S_10(c1);


Removing basic block 61
basic block 61, loop depth 1
 pred:      
goto <bb 59>;
 succ:       59



Updating SSA:
Registering new PHI nodes in block #58
Registering new PHI nodes in block #60
Registering new PHI nodes in block #10
Updating SSA information for statement *_26 = _34;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #59
Registering new PHI nodes in block #57
Registering new PHI nodes in block #56
Registering new PHI nodes in block #24
Registering new PHI nodes in block #28
Registering new PHI nodes in block #32
Registering new PHI nodes in block #36
Registering new PHI nodes in block #40
Registering new PHI nodes in block #38
Registering new PHI nodes in block #37
Registering new PHI nodes in block #39
Registering new PHI nodes in block #34
Registering new PHI nodes in block #35
Registering new PHI nodes in block #33
Registering new PHI nodes in block #30
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #43
Registering new PHI nodes in block #47
Registering new PHI nodes in block #51
Registering new PHI nodes in block #55
Registering new PHI nodes in block #53
Registering new PHI nodes in block #52
Registering new PHI nodes in block #54
Registering new PHI nodes in block #49
Registering new PHI nodes in block #50
Registering new PHI nodes in block #48
Registering new PHI nodes in block #45
Registering new PHI nodes in block #16
Registering new PHI nodes in block #17
Registering new PHI nodes in block #18
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #41
Registering new PHI nodes in block #22
Registering new PHI nodes in block #19
Registering new PHI nodes in block #20
Registering new PHI nodes in block #21

DFA Statistics for int rng_main()

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            108        864b
DEF operands                             65        520b
VUSE operands                            25        200b
VDEF operands                            12         96b
PHI nodes                                21       2184b
PHI arguments                            42       2016b
---------------------------------------------------------
Total memory used by DFA/SSA data                 5880b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_70 -> { .MEM_72 }
Incremental SSA update started at block: 58
Number of blocks in CFG: 62
Number of blocks to update: 12 ( 19%)
Affected blocks: 10 11 12 13 28 32 33 35 36 58 59 60


Applying pattern match.pd:397, generic-match.c:4039
Applying pattern match.pd:397, generic-match.c:4039

Updating SSA:
creating PHI node in block #63 for .MEM
creating PHI node in block #66 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Updating SSA information for statement ran_start (310952);
Registering new PHI nodes in block #3
Updating SSA information for statement ran_array.constprop (&a);
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #25
Updating SSA information for statement _9 = a[0];
Updating SSA information for statement __printf_chk (1, "%ld\n", _9);
Updating SSA information for statement ran_start (310952);
Registering new PHI nodes in block #6
Updating SSA information for statement __builtin_memcpy (&a, &ran_x, 800);
Registering new PHI nodes in block #9
Registering new PHI nodes in block #58
Registering new PHI nodes in block #62
Registering new PHI nodes in block #66
Registering new PHI nodes in block #70
Updating SSA information for statement _67 = MEM[(long int *)_51];
Updating SSA information for statement _50 = *_17;
Updating SSA information for statement _11 = _67 - _50;
Updating SSA information for statement _4 = _11 & 1073741823;
Updating SSA information for statement *_150 = _4;
Registering new PHI nodes in block #68
Registering new PHI nodes in block #67
Registering new PHI nodes in block #69
Registering new PHI nodes in block #64
Registering new PHI nodes in block #65
Registering new PHI nodes in block #63
Registering new PHI nodes in block #60
Registering new PHI nodes in block #10
Updating SSA information for statement _29 = *_28;
Updating SSA information for statement _32 = *_31;
Updating SSA information for statement _33 = _29 - _32;
Updating SSA information for statement _34 = _33 & 1073741823;
Updating SSA information for statement *_26 = _34;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #59
Registering new PHI nodes in block #57
Registering new PHI nodes in block #56
Registering new PHI nodes in block #24
Registering new PHI nodes in block #28
Registering new PHI nodes in block #32
Registering new PHI nodes in block #36
Registering new PHI nodes in block #40
Updating SSA information for statement _149 = *_145;
Updating SSA information for statement _143 = *_118;
Updating SSA information for statement ran_x[_114] = _116;
Registering new PHI nodes in block #38
Registering new PHI nodes in block #37
Registering new PHI nodes in block #39
Registering new PHI nodes in block #34
Registering new PHI nodes in block #35
Registering new PHI nodes in block #33
Registering new PHI nodes in block #30
Registering new PHI nodes in block #13
Updating SSA information for statement _42 = *_41;
Updating SSA information for statement _45 = *_44;
Updating SSA information for statement ran_x[i_99] = _47;
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #43
Registering new PHI nodes in block #47
Registering new PHI nodes in block #51
Registering new PHI nodes in block #55
Updating SSA information for statement _92 = *_88;
Updating SSA information for statement _87 = ran_x[_86];
Updating SSA information for statement ran_x[_81] = _84;
Registering new PHI nodes in block #53
Registering new PHI nodes in block #52
Registering new PHI nodes in block #54
Registering new PHI nodes in block #49
Registering new PHI nodes in block #50
Registering new PHI nodes in block #48
Registering new PHI nodes in block #45
Registering new PHI nodes in block #16
Updating SSA information for statement _56 = *_55;
Updating SSA information for statement _58 = ran_x[_57];
Updating SSA information for statement ran_x[i_101] = _60;
Registering new PHI nodes in block #17
Registering new PHI nodes in block #18
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #41
Registering new PHI nodes in block #22
Registering new PHI nodes in block #19
Registering new PHI nodes in block #20
Registering new PHI nodes in block #21
Updating SSA information for statement _13 = a[0];
Updating SSA information for statement __printf_chk (1, "%ld\n", _13);
Updating SSA information for statement a ={v} {CLOBBER};
Updating SSA information for statement return 0;

DFA Statistics for int rng_main()

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            128       1024b
DEF operands                             81        648b
VUSE operands                            28        224b
VDEF operands                            13        104b
PHI nodes                                24       2496b
PHI arguments                            48       2304b
---------------------------------------------------------
Total memory used by DFA/SSA data                 6800b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_3 -> { .MEM_72 }
_4 -> { _34 }
_11 -> { _33 }
_50 -> { _32 }
_67 -> { _29 }

Symbols to be put in SSA form
{ D.3750 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 71
Number of blocks to update: 65 ( 92%)
Affected blocks: 0 2 3 4 5 6 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 32 33 34 35 36 37 38 39 40 41 42 43 44 45 47 48 49 50 51 52 53 54 55 56 57 58 59 60 62 63 64 65 66 67 68 69 70



1 loops carried no dependency.
Removing basic block 5
basic block 5, loop depth 0
 pred:      
 succ:       25


Merging blocks 6 and 9
Removing basic block 12
basic block 12, loop depth 1
 pred:      
goto <bb 59>;
 succ:       59


Removing basic block 15
basic block 15, loop depth 1
 pred:      
goto <bb 29>;
 succ:       29


Removing basic block 18
basic block 18, loop depth 1
 pred:      
goto <bb 44>;
 succ:       44


Removing basic block 20
basic block 20, loop depth 0
 pred:      
 succ:       21


Removing basic block 23
basic block 23, loop depth 1
 pred:      
 succ:       43


Removing basic block 24
basic block 24, loop depth 1
 pred:      
 succ:       28


Removing basic block 26
basic block 26, loop depth 1
 pred:      
 succ:       43


Removing basic block 27
basic block 27, loop depth 1
 pred:      
goto <bb 43>;
 succ:       43


Removing basic block 14
basic block 14, loop depth 2
 pred:       13
goto <bb 13>;
 succ:       13


Removing basic block 13
basic block 13, loop depth 2
 pred:       28
# i_99 = PHI <0(28)>
# j_100 = PHI <2009(28)>
# DEBUG j => j_100
# DEBUG i => i_99
_38 = (long unsigned int) j_100;
_39 = _38 * 8;
_40 = _39 + 18446744073709550816;
_41 = &a + _40;
_42 = *_41;
_43 = _39 + 18446744073709551320;
_44 = &a + _43;
_45 = *_44;
_46 = _42 - _45;
_47 = _46 & 1073741823;
ran_x[i_99] = _47;
i_48 = i_99 + 1;
# DEBUG i => i_48
j_49 = j_100 + 1;
# DEBUG j => j_49
# DEBUG j => j_49
# DEBUG i => i_48
if (i_48 == 37)
 succ:       29


Removing basic block 28
basic block 28, loop depth 1
 pred:      
 succ:       32


Removing basic block 30
basic block 30, loop depth 1
 pred:      
 succ:       29


Removing basic block 35
basic block 35, loop depth 1
 pred:       32
goto <bb 33>;
 succ:       33


Removing basic block 34
basic block 34, loop depth 1
 pred:      
 succ:       33


Merging blocks 36 and 40
Removing basic block 39
basic block 39, loop depth 1
 pred:      
 succ:       33


Removing basic block 41
basic block 41, loop depth 1
 pred:      
 succ:       22


Removing basic block 42
basic block 42, loop depth 1
 pred:      
goto <bb 22>;
 succ:       22


Removing basic block 17
basic block 17, loop depth 2
 pred:       16
goto <bb 16>;
 succ:       16


Removing basic block 16
basic block 16, loop depth 2
 pred:       43
# i_101 = PHI <37(43)>
# j_102 = PHI <2046(43)>
# DEBUG j => j_102
# DEBUG i => i_101
_52 = (long unsigned int) j_102;
_53 = _52 * 8;
_54 = _53 + 18446744073709550816;
_55 = &a + _54;
_56 = *_55;
_57 = i_101 + -37;
_58 = ran_x[_57];
_59 = _56 - _58;
_60 = _59 & 1073741823;
ran_x[i_101] = _60;
i_61 = i_101 + 1;
# DEBUG i => i_61
j_62 = j_102 + 1;
# DEBUG j => j_62
# DEBUG j => j_62
# DEBUG i => i_61
if (i_61 > 99)
 succ:       44


Removing basic block 43
basic block 43, loop depth 1
 pred:      
 succ:       47


Removing basic block 45
basic block 45, loop depth 1
 pred:      
 succ:       44


Removing basic block 50
basic block 50, loop depth 1
 pred:       47
goto <bb 48>;
 succ:       48


Removing basic block 49
basic block 49, loop depth 1
 pred:      
 succ:       48


Merging blocks 51 and 55
Removing basic block 54
basic block 54, loop depth 1
 pred:      
 succ:       48


Removing basic block 56
basic block 56, loop depth 1
 pred:      
 succ:       32


Removing basic block 57
basic block 57, loop depth 1
 pred:      
goto <bb 32>;
 succ:       32


Removing basic block 11
basic block 11, loop depth 2
 pred:       10
goto <bb 10>;
 succ:       10


Removing basic block 10
basic block 10, loop depth 2
 pred:       58
# j_98 = PHI <100(58)>
# DEBUG j => j_98
_24 = (long unsigned int) j_98;
_25 = _24 * 8;
_26 = &a + _25;
_27 = _25 + 18446744073709550816;
_28 = &a + _27;
_29 = *_28;
_30 = _25 + 18446744073709551320;
_31 = &a + _30;
_32 = *_31;
_33 = _29 - _32;
_34 = _33 & 1073741823;
*_26 = _34;
j_35 = j_98 + 1;
# DEBUG j => j_35
# DEBUG j => j_35
if (j_35 > 2008)
 succ:       59


Removing basic block 58
basic block 58, loop depth 1
 pred:      
 succ:       62


Removing basic block 60
basic block 60, loop depth 1
 pred:      
 succ:       59


Removing basic block 65
basic block 65, loop depth 1
 pred:       62
goto <bb 63>;
 succ:       63


Removing basic block 64
basic block 64, loop depth 1
 pred:      
 succ:       63


Merging blocks 66 and 70
Removing basic block 69
basic block 69, loop depth 1
 pred:      
 succ:       63


Merging blocks 6 and 62
Merging blocks 33 and 29
Merging blocks 33 and 47
Merging blocks 36 and 38
Merging blocks 48 and 44
Merging blocks 48 and 22
Merging blocks 51 and 53
Merging blocks 63 and 59
Merging blocks 63 and 32
Merging blocks 66 and 68
fix_loop_structure: removing loop 3
fix_loop_structure: removing loop 4
fix_loop_structure: removing loop 5
Analyzing # of iterations of loop 2
  exit condition [1, + , 1](no_overflow) != 1010
  bounds on difference of bases: 1009 ... 1009
  result:
    # of iterations 1009, bounded by 1009
Analyzing # of iterations of loop 8
  exit condition [0, + , 1](no_overflow) < 62
  bounds on difference of bases: 62 ... 62
  result:
    # of iterations 62, bounded by 62
Analyzing # of iterations of loop 7
  exit condition [0, + , 1](no_overflow) < 36
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Analyzing # of iterations of loop 9
  exit condition [0, + , 1](no_overflow) < 1908
  bounds on difference of bases: 1908 ... 1908
  result:
    # of iterations 1908, bounded by 1908
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 2010
  bounds on difference of bases: 2009 ... 2009
  result:
    # of iterations 2009, bounded by 2009
1 edges in bb 2 predicted to even probabilities
Predictions for bb 3
  DS theory heuristics (ignored): 0.4%
  first match heuristics: 1.0%
  combined heuristics: 1.0%
  opcode values nonequal (on trees) heuristics (ignored): 28.0%
  loop iterations heuristics: 1.0%
1 edges in bb 4 predicted to even probabilities
1 edges in bb 5 predicted to even probabilities
1 edges in bb 6 predicted to even probabilities
Predictions for bb 7
  DS theory heuristics (ignored): 99.0%
  first match heuristics: 99.0%
  combined heuristics: 99.0%
  loop iterations heuristics: 99.0%
1 edges in bb 8 predicted to even probabilities
1 edges in bb 9 predicted to even probabilities
Predictions for bb 10
  DS theory heuristics (ignored): 97.3%
  first match heuristics: 97.3%
  combined heuristics: 97.3%
  loop iterations heuristics: 97.3%
1 edges in bb 11 predicted to even probabilities
1 edges in bb 12 predicted to even probabilities
Predictions for bb 13
  DS theory heuristics (ignored): 98.4%
  first match heuristics: 98.4%
  combined heuristics: 98.4%
  loop iterations heuristics: 98.4%
1 edges in bb 14 predicted to even probabilities
Predictions for bb 15
  DS theory heuristics (ignored): 0.2%
  first match heuristics: 1.0%
  combined heuristics: 1.0%
  opcode values nonequal (on trees) heuristics (ignored): 28.0%
  early return (on trees) heuristics (ignored): 39.0%
  loop iterations heuristics: 1.0%
1 edges in bb 16 predicted to even probabilities
1 edges in bb 17 predicted to even probabilities
loop_0 (header = 0, latch = 1, niter = )
{
  bb_2 (preds = {bb_0 }, succs = {bb_3 })
  {
    <bb 2>:
    # .MEM_6 = VDEF <.MEM_5(D)>
    ran_start (310952);
    # DEBUG m => 0
    # DEBUG m => 0

  }
  bb_5 (preds = {bb_3 }, succs = {bb_6 })
  {
    <bb 5>:
    # VUSE <.MEM_7>
    _9 = a[0];
    # DEBUG __fmt => "%ld\n"
    # .MEM_14 = VDEF <.MEM_7>
    __printf_chk (1, "%ld\n", _9);
    # .MEM_10 = VDEF <.MEM_14>
    ran_start (310952);
    # DEBUG m => 0
    # DEBUG m => 0

  }
  bb_17 (preds = {bb_15 }, succs = {bb_1 })
  {
    <bb 17>:
    # VUSE <.MEM_80>
    _13 = a[0];
    # DEBUG __fmt => "%ld\n"
    # .MEM_16 = VDEF <.MEM_80>
    __printf_chk (1, "%ld\n", _13);
    # .MEM_15 = VDEF <.MEM_16>
    a ={v} {CLOBBER};
    # VUSE <.MEM_15>
    return 0;

  }
  loop_2 (header = 6, latch = 16, niter = , upper_bound = 1009, estimate = 1009)
  {
    bb_6 (preds = {bb_16 bb_5 }, succs = {bb_7 })
    {
      <bb 6>:
      # m_63 = PHI <m_12(16), 0(5)>
      # .MEM_95 = PHI <.MEM_80(16), .MEM_10(5)>
      # DEBUG m => m_63
      # DEBUG j => 0
      # .MEM_97 = VDEF <.MEM_95>
      __builtin_memcpy (&a, &ran_x, 800);

    }
    bb_9 (preds = {bb_7 }, succs = {bb_10 })
    {
      <bb 9>:
      # .MEM_144 = PHI <.MEM_3(7)>

    }
    bb_12 (preds = {bb_10 }, succs = {bb_13 })
    {
      <bb 12>:
      # .MEM_113 = PHI <.MEM_115(10)>

    }
    bb_15 (preds = {bb_13 }, succs = {bb_17 bb_16 })
    {
      <bb 15>:
      # .MEM_80 = PHI <.MEM_83(13)>
      m_12 = m_63 + 1;
      # DEBUG m => m_12
      # DEBUG m => m_12
      if (m_12 == 1010)
        goto <bb 17>;
      else
        goto <bb 16>;

    }
    bb_16 (preds = {bb_15 }, succs = {bb_6 })
    {
      <bb 16>:
      goto <bb 6>;

    }
    loop_8 (header = 13, latch = 14, niter = )
    {
      bb_13 (preds = {bb_12 bb_14 }, succs = {bb_14 bb_15 })
      {
        <bb 13>:
        # graphite_IV.313_106 = PHI <0(12), graphite_IV.313_93(14)>
        # .MEM_79 = PHI <.MEM_113(12), .MEM_83(14)>
        # DEBUG j => NULL
        # DEBUG i => NULL
        _91 = (sizetype) graphite_IV.313_106;
        _90 = _91 + 1946;
        _89 = _90 * 8;
        _88 = &a + _89;
        # VUSE <.MEM_79>
        _92 = *_88;
        _86 = (int) graphite_IV.313_106;
        # VUSE <.MEM_79>
        _87 = ran_x[_86];
        _85 = _92 - _87;
        _84 = _85 & 1073741823;
        _82 = (int) graphite_IV.313_106;
        _81 = _82 + 37;
        # .MEM_83 = VDEF <.MEM_79>
        ran_x[_81] = _84;
        # DEBUG i => NULL
        # DEBUG j => NULL
        # DEBUG j => NULL
        # DEBUG i => NULL
        graphite_IV.313_93 = graphite_IV.313_106 + 1;
        if (graphite_IV.313_106 < 62)
          goto <bb 14>;
        else
          goto <bb 15>;

      }
      bb_14 (preds = {bb_13 }, succs = {bb_13 })
      {
        <bb 14>:
        goto <bb 13>;

      }
    }
    loop_7 (header = 10, latch = 11, niter = )
    {
      bb_10 (preds = {bb_9 bb_11 }, succs = {bb_11 bb_12 })
      {
        <bb 10>:
        # graphite_IV.312_71 = PHI <0(9), graphite_IV.312_22(11)>
        # .MEM_112 = PHI <.MEM_144(9), .MEM_115(11)>
        # DEBUG j => NULL
        # DEBUG i => NULL
        _148 = (sizetype) graphite_IV.312_71;
        _147 = _148 + 1909;
        _146 = _147 * 8;
        _145 = &a + _146;
        # VUSE <.MEM_112>
        _149 = *_145;
        _142 = (sizetype) graphite_IV.312_71;
        _126 = _142 + 1972;
        _125 = _126 * 8;
        _118 = &a + _125;
        # VUSE <.MEM_112>
        _143 = *_118;
        _117 = _149 - _143;
        _116 = _117 & 1073741823;
        _114 = (int) graphite_IV.312_71;
        # .MEM_115 = VDEF <.MEM_112>
        ran_x[_114] = _116;
        # DEBUG i => NULL
        # DEBUG j => NULL
        # DEBUG j => NULL
        # DEBUG i => NULL
        graphite_IV.312_22 = graphite_IV.312_71 + 1;
        if (graphite_IV.312_71 < 36)
          goto <bb 11>;
        else
          goto <bb 12>;

      }
      bb_11 (preds = {bb_10 }, succs = {bb_10 })
      {
        <bb 11>:
        goto <bb 10>;

      }
    }
    loop_9 (header = 7, latch = 8, niter = )
    {
      bb_7 (preds = {bb_6 bb_8 }, succs = {bb_8 bb_9 })
      {
        <bb 7>:
        # graphite_IV.314_69 = PHI <0(6), graphite_IV.314_68(8)>
        # .MEM_141 = PHI <.MEM_97(6), .MEM_3(8)>
        # DEBUG j => NULL
        _66 = (sizetype) graphite_IV.314_69;
        _64 = _66 * 8;
        _51 = &a + _64;
        # VUSE <.MEM_141>
        _67 = MEM[(long int *)_51];
        _37 = (sizetype) graphite_IV.314_69;
        _36 = _37 + 63;
        _23 = _36 * 8;
        _17 = &a + _23;
        # VUSE <.MEM_141>
        _50 = *_17;
        _11 = _67 - _50;
        _4 = _11 & 1073741823;
        _2 = (sizetype) graphite_IV.314_69;
        _1 = _2 + 100;
        _151 = _1 * 8;
        _150 = &a + _151;
        # .MEM_3 = VDEF <.MEM_141>
        *_150 = _4;
        # DEBUG j => NULL
        # DEBUG j => NULL
        graphite_IV.314_68 = graphite_IV.314_69 + 1;
        if (graphite_IV.314_69 < 1908)
          goto <bb 8>;
        else
          goto <bb 9>;

      }
      bb_8 (preds = {bb_7 }, succs = {bb_7 })
      {
        <bb 8>:
        goto <bb 7>;

      }
    }
  }
  loop_1 (header = 3, latch = 4, niter = , upper_bound = 2009, estimate = 2009)
  {
    bb_3 (preds = {bb_4 bb_2 }, succs = {bb_5 bb_4 })
    {
      <bb 3>:
      # m_65 = PHI <m_8(4), 0(2)>
      # .MEM_94 = PHI <.MEM_7(4), .MEM_6(2)>
      # DEBUG m => m_65
      # .MEM_7 = VDEF <.MEM_94>
      ran_array.constprop (&a);
      m_8 = m_65 + 1;
      # DEBUG m => m_8
      # DEBUG m => m_8
      if (m_8 == 2010)
        goto <bb 5>;
      else
        goto <bb 4>;

    }
    bb_4 (preds = {bb_3 }, succs = {bb_3 })
    {
      <bb 4>:
      goto <bb 3>;

    }
  }
}

Pass statistics:
----------------

int rng_main() ()
{
  signed long graphite_IV.314D.4191;
  long intD.12 D.4190;
  long intD.12 D.4189;
  long intD.12 D.4188;
  long intD.12 D.4187;
  signed long graphite_IV.313D.4186;
  long intD.12 D.4185;
  long intD.12 D.4184;
  long intD.12 D.4183;
  long intD.12 D.4182;
  signed long graphite_IV.312D.4181;
  long intD.12 D.4180;
  long intD.12 D.4179;
  long intD.12 D.4178;
  long intD.12 D.4177;
  register intD.9 jD.4173;
  register intD.9 iD.4172;
  long intD.12 aD.3636[2009];
  register intD.9 mD.3635;
  sizetype _1;
  sizetype _2;
  long intD.12 _4;
  long intD.12 _9;
  long intD.12 _11;
  long intD.12 _13;
  long intD.12 * _17;
  sizetype _23;
  sizetype _36;
  sizetype _37;
  long intD.12 _50;
  long intD.12[2009] * _51;
  sizetype _64;
  sizetype _66;
  long intD.12 _67;
  intD.9 _81;
  intD.9 _82;
  long intD.12 _84;
  long intD.12 _85;
  intD.9 _86;
  long intD.12 _87;
  long intD.12 * _88;
  sizetype _89;
  sizetype _90;
  sizetype _91;
  long intD.12 _92;
  intD.9 _114;
  long intD.12 _116;
  long intD.12 _117;
  long intD.12 * _118;
  sizetype _125;
  sizetype _126;
  sizetype _142;
  long intD.12 _143;
  long intD.12 * _145;
  sizetype _146;
  sizetype _147;
  sizetype _148;
  long intD.12 _149;
  long intD.12 * _150;
  sizetype _151;

;;   basic block 2, loop depth 0, count 0, freq 1, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY [100.0%]  (FALLTHRU,EXECUTABLE)
  # .MEM_6 = VDEF <.MEM_5(D)>
  # USE = nonlocal null { D.3636 } (escaped)
  # CLB = nonlocal null { D.3636 } (escaped)
  _Z9ran_startlD.2838 (310952);
  # DEBUG mD.3635 => 0
  # DEBUG mD.3635 => 0
;;    succ:       3 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 3, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 2, next block 4, flags: (NEW, REACHABLE)
;;    pred:       4 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                2 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 2010] NONZERO 2047
  # m_65 = PHI <m_8(4), 0(2)>
  # .MEM_94 = PHI <.MEM_7(4), .MEM_6(2)>
  # DEBUG mD.3635 => m_65
  # .MEM_7 = VDEF <.MEM_94>
  # USE = nonlocal null { D.3636 } (escaped)
  # CLB = nonlocal null { D.3636 } (escaped)
  _Z9ran_arrayPli.constprop.0D.3763 (&aD.3636);
  # RANGE [1, 2010] NONZERO 2047
  m_8 = m_65 + 1;
  # DEBUG mD.3635 => m_8
  # DEBUG mD.3635 => m_8
  if (m_8 == 2010)
    goto <bb 5>;
  else
    goto <bb 4>;
;;    succ:       5 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                4 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 4, loop depth 1, count 0, freq 99, maybe hot
;;    prev block 3, next block 5, flags: (NEW)
;;    pred:       3 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 5, loop depth 0, count 0, freq 1, maybe hot
;;    prev block 4, next block 6, flags: (NEW)
;;    pred:       3 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # VUSE <.MEM_7>
  _9 = aD.3636[0];
  # DEBUG __fmtD.3757 => "%ld\n"
  # .MEM_14 = VDEF <.MEM_7>
  # USE = nonlocal null { D.3636 } (escaped)
  # CLB = nonlocal null { D.3636 } (escaped)
  __printf_chkD.1500 (1, "%ld\n", _9);
  # .MEM_10 = VDEF <.MEM_14>
  # USE = nonlocal null { D.3636 } (escaped)
  # CLB = nonlocal null { D.3636 } (escaped)
  _Z9ran_startlD.2838 (310952);
  # DEBUG mD.3635 => 0
  # DEBUG mD.3635 => 0
;;    succ:       6 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 6, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 5, next block 7, flags: (NEW, REACHABLE)
;;    pred:       16 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                5 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 1010] NONZERO 1023
  # m_63 = PHI <m_12(16), 0(5)>
  # .MEM_95 = PHI <.MEM_80(16), .MEM_10(5)>
  # DEBUG mD.3635 => m_63
  # DEBUG jD.4173 => 0
  # .MEM_97 = VDEF <.MEM_95>
  # USE = anything 
  # CLB = anything 
  memcpyD.992 (&aD.3636, &ran_xD.2818, 800);
;;    succ:       7 [100.0%]  (FALLTHRU)

;;   basic block 7, loop depth 2, count 0, freq 10000, maybe hot
;;    prev block 6, next block 8, flags: (NEW)
;;    pred:       6 [100.0%]  (FALLTHRU)
;;                8 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.314_69 = PHI <0(6), graphite_IV.314_68(8)>
  # .MEM_141 = PHI <.MEM_97(6), .MEM_3(8)>
  # DEBUG jD.4173 => NULL
  _66 = (sizetype) graphite_IV.314_69;
  _64 = _66 * 8;
  _51 = &aD.3636 + _64;
  # VUSE <.MEM_141>
  _67 = MEM[(long intD.12 *)_51];
  _37 = (sizetype) graphite_IV.314_69;
  _36 = _37 + 63;
  _23 = _36 * 8;
  _17 = &aD.3636 + _23;
  # VUSE <.MEM_141>
  _50 = *_17;
  _11 = _67 - _50;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _4 = _11 & 1073741823;
  _2 = (sizetype) graphite_IV.314_69;
  _1 = _2 + 100;
  _151 = _1 * 8;
  _150 = &aD.3636 + _151;
  # .MEM_3 = VDEF <.MEM_141>
  *_150 = _4;
  # DEBUG jD.4173 => NULL
  # DEBUG jD.4173 => NULL
  graphite_IV.314_68 = graphite_IV.314_69 + 1;
  if (graphite_IV.314_69 < 1908)
    goto <bb 8>;
  else
    goto <bb 9>;
;;    succ:       8 [99.0%]  (TRUE_VALUE)
;;                9 [1.0%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 8, loop depth 2, count 0, freq 9900, maybe hot
;;    prev block 7, next block 9, flags: (NEW)
;;    pred:       7 [99.0%]  (TRUE_VALUE)
  goto <bb 7>;
;;    succ:       7 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 9, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 8, next block 10, flags: (NEW)
;;    pred:       7 [1.0%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_144 = PHI <.MEM_3(7)>
;;    succ:       10 [100.0%]  (FALLTHRU)

;;   basic block 10, loop depth 2, count 0, freq 3704, maybe hot
;;    prev block 9, next block 11, flags: (NEW)
;;    pred:       9 [100.0%]  (FALLTHRU)
;;                11 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.312_71 = PHI <0(9), graphite_IV.312_22(11)>
  # .MEM_112 = PHI <.MEM_144(9), .MEM_115(11)>
  # DEBUG jD.4173 => NULL
  # DEBUG iD.4172 => NULL
  _148 = (sizetype) graphite_IV.312_71;
  _147 = _148 + 1909;
  _146 = _147 * 8;
  _145 = &aD.3636 + _146;
  # VUSE <.MEM_112>
  _149 = *_145;
  _142 = (sizetype) graphite_IV.312_71;
  _126 = _142 + 1972;
  _125 = _126 * 8;
  _118 = &aD.3636 + _125;
  # VUSE <.MEM_112>
  _143 = *_118;
  _117 = _149 - _143;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _116 = _117 & 1073741823;
  _114 = (intD.9) graphite_IV.312_71;
  # .MEM_115 = VDEF <.MEM_112>
  ran_xD.2818[_114] = _116;
  # DEBUG iD.4172 => NULL
  # DEBUG jD.4173 => NULL
  # DEBUG jD.4173 => NULL
  # DEBUG iD.4172 => NULL
  graphite_IV.312_22 = graphite_IV.312_71 + 1;
  if (graphite_IV.312_71 < 36)
    goto <bb 11>;
  else
    goto <bb 12>;
;;    succ:       11 [97.3%]  (TRUE_VALUE)
;;                12 [2.7%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 11, loop depth 2, count 0, freq 3604, maybe hot
;;    prev block 10, next block 12, flags: (NEW)
;;    pred:       10 [97.3%]  (TRUE_VALUE)
  goto <bb 10>;
;;    succ:       10 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 12, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 11, next block 13, flags: (NEW)
;;    pred:       10 [2.7%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_113 = PHI <.MEM_115(10)>
;;    succ:       13 [100.0%]  (FALLTHRU)

;;   basic block 13, loop depth 2, count 0, freq 6289, maybe hot
;;    prev block 12, next block 14, flags: (NEW)
;;    pred:       12 [100.0%]  (FALLTHRU)
;;                14 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.313_106 = PHI <0(12), graphite_IV.313_93(14)>
  # .MEM_79 = PHI <.MEM_113(12), .MEM_83(14)>
  # DEBUG jD.4173 => NULL
  # DEBUG iD.4172 => NULL
  _91 = (sizetype) graphite_IV.313_106;
  _90 = _91 + 1946;
  _89 = _90 * 8;
  _88 = &aD.3636 + _89;
  # VUSE <.MEM_79>
  _92 = *_88;
  _86 = (intD.9) graphite_IV.313_106;
  # VUSE <.MEM_79>
  _87 = ran_xD.2818[_86];
  _85 = _92 - _87;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _84 = _85 & 1073741823;
  _82 = (intD.9) graphite_IV.313_106;
  _81 = _82 + 37;
  # .MEM_83 = VDEF <.MEM_79>
  ran_xD.2818[_81] = _84;
  # DEBUG iD.4172 => NULL
  # DEBUG jD.4173 => NULL
  # DEBUG jD.4173 => NULL
  # DEBUG iD.4172 => NULL
  graphite_IV.313_93 = graphite_IV.313_106 + 1;
  if (graphite_IV.313_106 < 62)
    goto <bb 14>;
  else
    goto <bb 15>;
;;    succ:       14 [98.4%]  (TRUE_VALUE)
;;                15 [1.6%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 14, loop depth 2, count 0, freq 6189, maybe hot
;;    prev block 13, next block 15, flags: (NEW)
;;    pred:       13 [98.4%]  (TRUE_VALUE)
  goto <bb 13>;
;;    succ:       13 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 15, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 14, next block 16, flags: (NEW)
;;    pred:       13 [1.6%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_80 = PHI <.MEM_83(13)>
  # RANGE [1, 1010] NONZERO 1023
  m_12 = m_63 + 1;
  # DEBUG mD.3635 => m_12
  # DEBUG mD.3635 => m_12
  if (m_12 == 1010)
    goto <bb 17>;
  else
    goto <bb 16>;
;;    succ:       17 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                16 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 16, loop depth 1, count 0, freq 99, maybe hot
;;    prev block 15, next block 17, flags: (NEW)
;;    pred:       15 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 6>;
;;    succ:       6 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 17, loop depth 0, count 0, freq 1, maybe hot
;;    prev block 16, next block 1, flags: (NEW)
;;    pred:       15 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # VUSE <.MEM_80>
  _13 = aD.3636[0];
  # DEBUG __fmtD.3759 => "%ld\n"
  # .MEM_16 = VDEF <.MEM_80>
  # USE = nonlocal null { D.3636 } (escaped)
  # CLB = nonlocal null { D.3636 } (escaped)
  __printf_chkD.1500 (1, "%ld\n", _13);
  # .MEM_15 = VDEF <.MEM_16>
  aD.3636 ={v} {CLOBBER};
  # VUSE <.MEM_15>
  return 0;
;;    succ:       EXIT [100.0%] 

}



;; Function <built-in> (void_ran_array_long_int___int_._loopfn.0, funcdef_no=37, decl_uid=3803, cgraph_uid=4, symbol_order=46)


Pass statistics:
----------------


Pass statistics:
----------------

<built-in> (voidD.45 * .paral_data_paramD.3805)
{
  signed long graphite_IV.18D.3813;
  unsigned long tt.24D.3812;
  unsigned long q.23D.3811;
  long intD.12 * aa.19D.3810;
  struct  * .paral_data_load.22D.3809;
  long intD.12[100] * ran_x_5;
  intD.9 _6;
  unsigned long _7;
  intD.9 _8;
  unsigned long _9;
  unsigned long _16;
  unsigned long _17;
  unsigned long _18;
  unsigned long ivtmp_20;
  unsigned long ivtmp_21;
  sizetype _26;
  sizetype _27;
  long intD.12 * _28;
  long intD.12 _29;
  sizetype _31;
  sizetype _32;
  long intD.12 * _33;
  long intD.12 _34;
  long intD.12 _35;
  long intD.12 _36;
  intD.9 _37;

;;   basic block 2, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY (FALLTHRU,EXECUTABLE)
  # VUSE <.MEM_42(D)>
  # PT = nonlocal escaped 
  aa.19_4 = MEM[(struct  *).paral_data_param_1(D)].aaD.3799;
  # VUSE <.MEM_42(D)>
  # PT = nonlocal escaped 
  ran_x_5 = MEM[(struct  *).paral_data_param_1(D)].ran_xD.3800;
  _6 = omp_get_num_threadsD.1718 ();
  # RANGE ~[2147483648, 18446744071562067967]
  _7 = (unsigned long) _6;
  _8 = omp_get_thread_numD.1717 ();
  # RANGE ~[2147483648, 18446744071562067967]
  _9 = (unsigned long) _8;
  # RANGE [0, 36] NONZERO 63
  q.23_10 = 36 / _7;
  # RANGE [0, 18446744073709551615]
  tt.24_11 = 36 % _7;
  if (_9 < tt.24_11)
    goto <bb 9>;
  else
    goto <bb 3>;
;;    succ:       9 [25.0%]  (TRUE_VALUE,EXECUTABLE)
;;                3 [75.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 3, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 2, next block 4, flags: (NEW, REACHABLE)
;;    pred:       9 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                2 [75.0%]  (FALSE_VALUE,EXECUTABLE)
  # RANGE [0, 37] NONZERO 63
  # q.23_12 = PHI <q.23_13(9), q.23_10(2)>
  # tt.24_14 = PHI <0(9), tt.24_11(2)>
  # RANGE ~[79456894940, 18446743994252656639]
  _16 = _9 * q.23_12;
  # RANGE [0, 18446744073709551615]
  _17 = tt.24_14 + _16;
  # RANGE [0, 18446744073709551615]
  _18 = q.23_12 + _17;
  if (_17 >= _18)
    goto <bb 4>;
  else
    goto <bb 5>;
;;    succ:       5 [100.0%]  (FALSE_VALUE,EXECUTABLE)
;;                4 (TRUE_VALUE,EXECUTABLE)

;;   basic block 4, loop depth 0, count 0, freq 0, maybe hot
;;    prev block 3, next block 5, flags: (NEW, REACHABLE)
;;    pred:       3 (TRUE_VALUE,EXECUTABLE)
;;                7 [100.0%]  (FALLTHRU,EXECUTABLE)
  # .MEM_68 = PHI <.MEM_42(D)(3), .MEM_41(7)>
  # VUSE <.MEM_68>
  return;
;;    succ:       EXIT

;;   basic block 5, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 4, next block 6, flags: (NEW)
;;    pred:       3 [100.0%]  (FALSE_VALUE,EXECUTABLE)
;;    succ:       6 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 6, loop depth 1, count 0, freq 2963, maybe hot
;;    prev block 5, next block 7, flags: (NEW)
;;    pred:       5 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                8 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [0, 18446744073709551614]
  # ivtmp_20 = PHI <_17(5), ivtmp_21(8)>
  # .MEM_40 = PHI <.MEM_42(D)(5), .MEM_43(8)>
  # RANGE ~[908, 908]
  _26 = ivtmp_20 + 909;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _27 = _26 * 8;
  # PT = nonlocal escaped 
  _28 = aa.19_4 + _27;
  # VUSE <.MEM_40>
  _29 = *_28;
  # RANGE ~[971, 971]
  _31 = ivtmp_20 + 972;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _32 = _31 * 8;
  # PT = nonlocal escaped 
  _33 = aa.19_4 + _32;
  # VUSE <.MEM_40>
  _34 = *_33;
  _35 = _29 - _34;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _36 = _35 & 1073741823;
  _37 = (intD.9) ivtmp_20;
  # .MEM_43 = VDEF <.MEM_40>
  *ran_x_5[_37] = _36;
  # RANGE [1, 18446744073709551615]
  ivtmp_21 = ivtmp_20 + 1;
  if (_18 > ivtmp_21)
    goto <bb 8>;
  else
    goto <bb 7>;
;;    succ:       8 [100.0%]  (TRUE_VALUE,EXECUTABLE)
;;                7 (FALSE_VALUE,EXECUTABLE)

;;   basic block 7, loop depth 0, count 0, freq 0, maybe hot
;;    prev block 6, next block 8, flags: (NEW)
;;    pred:       6 (FALSE_VALUE,EXECUTABLE)
  # .MEM_41 = PHI <.MEM_43(6)>
  goto <bb 4>;
;;    succ:       4 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 8, loop depth 1, count 0, freq 2963, maybe hot
;;    prev block 7, next block 9, flags: (NEW)
;;    pred:       6 [100.0%]  (TRUE_VALUE,EXECUTABLE)
  goto <bb 6>;
;;    succ:       6 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 9, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 8, next block 1, flags: (NEW, REACHABLE)
;;    pred:       2 [25.0%]  (TRUE_VALUE,EXECUTABLE)
  # RANGE [1, 37] NONZERO 63
  q.23_13 = q.23_10 + 1;
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,EXECUTABLE)

}



;; Function <built-in> (void_ran_array_long_int___int_._loopfn.1, funcdef_no=38, decl_uid=3949, cgraph_uid=7, symbol_order=49)


Pass statistics:
----------------


Pass statistics:
----------------

<built-in> (voidD.45 * .paral_data_paramD.3951)
{
  signed long graphite_IV.130D.3960;
  unsigned long tt.137D.3959;
  unsigned long q.136D.3958;
  long intD.12 * aa.132D.3957;
  intD.9 j.131D.3956;
  struct  * .paral_data_load.135D.3955;
  long intD.12[100] * ran_x_6;
  intD.9 _7;
  unsigned long _8;
  intD.9 _9;
  unsigned long _10;
  unsigned long _17;
  unsigned long _18;
  unsigned long _19;
  unsigned long ivtmp_21;
  unsigned long ivtmp_22;
  sizetype _28;
  sizetype _29;
  sizetype _30;
  long intD.12 * _31;
  long intD.12 _32;
  sizetype _37;
  long intD.12 * _38;
  long intD.12 _39;
  long intD.12 _40;
  long intD.12 _41;
  intD.9 _42;
  sizetype pretmp_66;

;;   basic block 2, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY (FALLTHRU,EXECUTABLE)
  # VUSE <.MEM_47(D)>
  j.131_4 = MEM[(struct  *).paral_data_param_1(D)].jD.3944;
  # VUSE <.MEM_47(D)>
  # PT = nonlocal escaped 
  aa.132_5 = MEM[(struct  *).paral_data_param_1(D)].aaD.3945;
  # VUSE <.MEM_47(D)>
  # PT = nonlocal escaped 
  ran_x_6 = MEM[(struct  *).paral_data_param_1(D)].ran_xD.3946;
  _7 = omp_get_num_threadsD.1718 ();
  # RANGE ~[2147483648, 18446744071562067967]
  _8 = (unsigned long) _7;
  _9 = omp_get_thread_numD.1717 ();
  # RANGE ~[2147483648, 18446744071562067967]
  _10 = (unsigned long) _9;
  # RANGE [0, 36] NONZERO 63
  q.136_11 = 36 / _8;
  # RANGE [0, 18446744073709551615]
  tt.137_12 = 36 % _8;
  if (_10 < tt.137_12)
    goto <bb 8>;
  else
    goto <bb 3>;
;;    succ:       8 [25.0%]  (TRUE_VALUE,EXECUTABLE)
;;                3 [75.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 3, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 2, next block 4, flags: (NEW, REACHABLE)
;;    pred:       8 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                2 [75.0%]  (FALSE_VALUE,EXECUTABLE)
  # RANGE [0, 37] NONZERO 63
  # q.136_13 = PHI <q.136_14(8), q.136_11(2)>
  # tt.137_15 = PHI <0(8), tt.137_12(2)>
  # RANGE ~[79456894940, 18446743994252656639]
  _17 = _10 * q.136_13;
  # RANGE [0, 18446744073709551615]
  _18 = tt.137_15 + _17;
  # RANGE [0, 18446744073709551615]
  _19 = q.136_13 + _18;
  if (_18 >= _19)
    goto <bb 4>;
  else
    goto <bb 5>;
;;    succ:       5 [100.0%]  (FALSE_VALUE,EXECUTABLE)
;;                4 (TRUE_VALUE,EXECUTABLE)

;;   basic block 4, loop depth 0, count 0, freq 0, maybe hot
;;    prev block 3, next block 5, flags: (NEW, REACHABLE)
;;    pred:       3 (TRUE_VALUE,EXECUTABLE)
;;                6 (FALSE_VALUE,EXECUTABLE)
  # .MEM_71 = PHI <.MEM_47(D)(3), .MEM_48(6)>
  # VUSE <.MEM_71>
  return;
;;    succ:       EXIT

;;   basic block 5, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 4, next block 6, flags: (NEW)
;;    pred:       3 [100.0%]  (FALSE_VALUE,EXECUTABLE)
  pretmp_66 = (sizetype) j.131_4;
;;    succ:       6 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 6, loop depth 1, count 0, freq 2963, maybe hot
;;    prev block 5, next block 7, flags: (NEW)
;;    pred:       5 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                7 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 18446744073709551614]
  # ivtmp_21 = PHI <_18(5), ivtmp_22(7)>
  # .MEM_45 = PHI <.MEM_47(D)(5), .MEM_48(7)>
  # DEBUG j.131D.3956 => NULL
  # RANGE [0, 18446744073709551615]
  _28 = ivtmp_21 + pretmp_66;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _29 = _28 * 8;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _30 = _29 + 18446744073709550816;
  # PT = nonlocal escaped 
  _31 = aa.132_5 + _30;
  # VUSE <.MEM_45>
  _32 = *_31;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _37 = _29 + 18446744073709551320;
  # PT = nonlocal escaped 
  _38 = aa.132_5 + _37;
  # VUSE <.MEM_45>
  _39 = *_38;
  _40 = _32 - _39;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _41 = _40 & 1073741823;
  _42 = (intD.9) ivtmp_21;
  # .MEM_48 = VDEF <.MEM_45>
  *ran_x_6[_42] = _41;
  # DEBUG j.131D.3956 => NULL
  # DEBUG j.131D.3956 => NULL
  # RANGE [1, 18446744073709551615]
  ivtmp_22 = ivtmp_21 + 1;
  if (_19 > ivtmp_22)
    goto <bb 7>;
  else
    goto <bb 4>;
;;    succ:       7 [100.0%]  (TRUE_VALUE,EXECUTABLE)
;;                4 (FALSE_VALUE,EXECUTABLE)

;;   basic block 7, loop depth 1, count 0, freq 2963, maybe hot
;;    prev block 6, next block 8, flags: (NEW)
;;    pred:       6 [100.0%]  (TRUE_VALUE,EXECUTABLE)
  goto <bb 6>;
;;    succ:       6 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 8, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 7, next block 1, flags: (NEW, REACHABLE)
;;    pred:       2 [25.0%]  (TRUE_VALUE,EXECUTABLE)
  # RANGE [1, 37] NONZERO 63
  q.136_14 = q.136_11 + 1;
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,EXECUTABLE)

}



;; Function <built-in> (int_rng_main__._loopfn.2, funcdef_no=40, decl_uid=4198, cgraph_uid=3, symbol_order=52)


Pass statistics:
----------------


Pass statistics:
----------------

<built-in> (voidD.45 * .paral_data_paramD.4200)
{
  signed long graphite_IV.315D.4207;
  unsigned long tt.320D.4206;
  unsigned long q.319D.4205;
  struct  * .paral_data_load.318D.4204;
  long intD.12[100] * ran_x_4;
  long intD.12[2009] * a_5;
  intD.9 _6;
  unsigned long _7;
  intD.9 _8;
  unsigned long _9;
  unsigned long _16;
  unsigned long _17;
  unsigned long _18;
  unsigned long ivtmp_20;
  unsigned long ivtmp_21;
  sizetype _26;
  sizetype _27;
  long intD.12 * _28;
  long intD.12 _29;
  sizetype _31;
  sizetype _32;
  long intD.12 * _33;
  long intD.12 _34;
  long intD.12 _35;
  long intD.12 _36;
  intD.9 _37;

;;   basic block 2, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY (FALLTHRU,EXECUTABLE)
  # VUSE <.MEM_42(D)>
  # PT = nonlocal escaped 
  ran_x_4 = MEM[(struct  *).paral_data_param_1(D)].ran_xD.4194;
  # VUSE <.MEM_42(D)>
  # PT = nonlocal escaped 
  a_5 = MEM[(struct  *).paral_data_param_1(D)].aD.4195;
  _6 = omp_get_num_threadsD.1718 ();
  # RANGE ~[2147483648, 18446744071562067967]
  _7 = (unsigned long) _6;
  _8 = omp_get_thread_numD.1717 ();
  # RANGE ~[2147483648, 18446744071562067967]
  _9 = (unsigned long) _8;
  # RANGE [0, 36] NONZERO 63
  q.319_10 = 36 / _7;
  # RANGE [0, 18446744073709551615]
  tt.320_11 = 36 % _7;
  if (_9 < tt.320_11)
    goto <bb 9>;
  else
    goto <bb 3>;
;;    succ:       9 [25.0%]  (TRUE_VALUE,EXECUTABLE)
;;                3 [75.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 3, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 2, next block 4, flags: (NEW, REACHABLE)
;;    pred:       9 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                2 [75.0%]  (FALSE_VALUE,EXECUTABLE)
  # RANGE [0, 37] NONZERO 63
  # q.319_12 = PHI <q.319_13(9), q.319_10(2)>
  # tt.320_14 = PHI <0(9), tt.320_11(2)>
  # RANGE ~[79456894940, 18446743994252656639]
  _16 = _9 * q.319_12;
  # RANGE [0, 18446744073709551615]
  _17 = tt.320_14 + _16;
  # RANGE [0, 18446744073709551615]
  _18 = q.319_12 + _17;
  if (_17 >= _18)
    goto <bb 4>;
  else
    goto <bb 5>;
;;    succ:       5 [100.0%]  (FALSE_VALUE,EXECUTABLE)
;;                4 (TRUE_VALUE,EXECUTABLE)

;;   basic block 4, loop depth 0, count 0, freq 0, maybe hot
;;    prev block 3, next block 5, flags: (NEW, REACHABLE)
;;    pred:       3 (TRUE_VALUE,EXECUTABLE)
;;                7 [100.0%]  (FALLTHRU,EXECUTABLE)
  # .MEM_68 = PHI <.MEM_42(D)(3), .MEM_41(7)>
  # VUSE <.MEM_68>
  return;
;;    succ:       EXIT

;;   basic block 5, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 4, next block 6, flags: (NEW)
;;    pred:       3 [100.0%]  (FALSE_VALUE,EXECUTABLE)
;;    succ:       6 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 6, loop depth 1, count 0, freq 2963, maybe hot
;;    prev block 5, next block 7, flags: (NEW)
;;    pred:       5 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                8 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [0, 18446744073709551614]
  # ivtmp_20 = PHI <_17(5), ivtmp_21(8)>
  # .MEM_40 = PHI <.MEM_42(D)(5), .MEM_43(8)>
  # RANGE ~[1908, 1908]
  _26 = ivtmp_20 + 1909;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _27 = _26 * 8;
  # PT = nonlocal escaped 
  _28 = a_5 + _27;
  # VUSE <.MEM_40>
  _29 = *_28;
  # RANGE ~[1971, 1971]
  _31 = ivtmp_20 + 1972;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _32 = _31 * 8;
  # PT = nonlocal escaped 
  _33 = a_5 + _32;
  # VUSE <.MEM_40>
  _34 = *_33;
  _35 = _29 - _34;
  # RANGE [0, 1073741823] NONZERO 1073741823
  _36 = _35 & 1073741823;
  _37 = (intD.9) ivtmp_20;
  # .MEM_43 = VDEF <.MEM_40>
  *ran_x_4[_37] = _36;
  # RANGE [1, 18446744073709551615]
  ivtmp_21 = ivtmp_20 + 1;
  if (_18 > ivtmp_21)
    goto <bb 8>;
  else
    goto <bb 7>;
;;    succ:       8 [100.0%]  (TRUE_VALUE,EXECUTABLE)
;;                7 (FALSE_VALUE,EXECUTABLE)

;;   basic block 7, loop depth 0, count 0, freq 0, maybe hot
;;    prev block 6, next block 8, flags: (NEW)
;;    pred:       6 (FALSE_VALUE,EXECUTABLE)
  # .MEM_41 = PHI <.MEM_43(6)>
  goto <bb 4>;
;;    succ:       4 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 8, loop depth 1, count 0, freq 2963, maybe hot
;;    prev block 7, next block 9, flags: (NEW)
;;    pred:       6 [100.0%]  (TRUE_VALUE,EXECUTABLE)
  goto <bb 6>;
;;    succ:       6 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 9, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 8, next block 1, flags: (NEW, REACHABLE)
;;    pred:       2 [25.0%]  (TRUE_VALUE,EXECUTABLE)
  # RANGE [1, 37] NONZERO 63
  q.319_13 = q.319_10 + 1;
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,EXECUTABLE)

}


