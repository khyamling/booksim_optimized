
;; Function void ranf_array(double*, int) (_Z10ranf_arrayPdi.constprop.0, funcdef_no=36, decl_uid=3862, cgraph_uid=35, symbol_order=43)


Pass statistics:
----------------

void ranf_array(double*, int) (doubleD.39 * aaD.3872)
{
  register intD.9 iD.3873;
  register intD.9 jD.3874;
  intD.9 nD.3871;
  long unsigned intD.14 _2;
  long unsigned intD.14 _3;
  doubleD.39 * _5;
  doubleD.39 _6;
  long unsigned intD.14 _9;
  long unsigned intD.14 _10;
  doubleD.39 * _11;
  sizetype _12;
  doubleD.39 * _13;
  doubleD.39 _14;
  sizetype _15;
  doubleD.39 * _16;
  doubleD.39 _17;
  doubleD.39 _18;
  intD.9 _19;
  doubleD.39 _20;
  doubleD.39 _21;
  long unsigned intD.14 _25;
  long unsigned intD.14 _26;
  sizetype _27;
  doubleD.39 * _28;
  doubleD.39 _29;
  sizetype _30;
  doubleD.39 * _31;
  doubleD.39 _32;
  doubleD.39 _33;
  intD.9 _34;
  doubleD.39 _35;
  doubleD.39 _36;
  long unsigned intD.14 _41;
  long unsigned intD.14 _42;
  sizetype _43;
  doubleD.39 * _44;
  doubleD.39 _45;
  intD.9 _46;
  doubleD.39 _47;
  doubleD.39 _48;
  intD.9 _49;
  doubleD.39 _50;
  doubleD.39 _51;

;;   basic block 2, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY [100.0%]  (FALLTHRU,EXECUTABLE)
  # DEBUG nD.3871 => 1009
  # DEBUG jD.3874 => 0
;;    succ:       3 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 3, loop depth 1, count 0, freq 9900, maybe hot
;;    prev block 2, next block 4, flags: (NEW, REACHABLE)
;;    pred:       4 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                2 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 100] NONZERO 127
  # j_81 = PHI <j_7(4), 0(2)>
  # .MEM_87 = PHI <.MEM_64(4), .MEM_63(D)(2)>
  # DEBUG jD.3874 => j_81
  # RANGE [0, 99] NONZERO 127
  _2 = (long unsigned intD.14) j_81;
  # RANGE [0, 792] NONZERO 1016
  _3 = _2 * 8;
  # PT = nonlocal 
  _5 = aa_4(D) + _3;
  # VUSE <.MEM_87>
  _6 = ran_uD.2900[j_81];
  # .MEM_64 = VDEF <.MEM_87>
  *_5 = _6;
  # RANGE [1, 100] NONZERO 127
  j_7 = j_81 + 1;
  # DEBUG jD.3874 => j_7
  # DEBUG jD.3874 => j_7
  if (j_7 == 100)
    goto <bb 5>;
  else
    goto <bb 4>;
;;    succ:       5 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                4 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 4, loop depth 1, count 0, freq 9800, maybe hot
;;    prev block 3, next block 5, flags: (NEW)
;;    pred:       3 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 5, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 4, next block 6, flags: (NEW)
;;    pred:       3 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;    succ:       6 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 6, loop depth 1, count 0, freq 1011, maybe hot
;;    prev block 5, next block 7, flags: (NEW, REACHABLE)
;;    pred:       5 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                7 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [100, 2147483646] NONZERO 1023
  # j_82 = PHI <100(5), j_22(7)>
  # .MEM_88 = PHI <.MEM_64(5), .MEM_65(7)>
  # DEBUG jD.3874 => j_82
  # RANGE [100, 1008] NONZERO 1023
  _9 = (long unsigned intD.14) j_82;
  # RANGE [800, 8064] NONZERO 8184
  _10 = _9 * 8;
  # PT = nonlocal 
  _11 = aa_4(D) + _10;
  # RANGE [0, 7264] NONZERO 8184
  _12 = _10 + 18446744073709550816;
  # PT = nonlocal 
  _13 = aa_4(D) + _12;
  # VUSE <.MEM_88>
  _14 = *_13;
  # RANGE [504, 7768] NONZERO 8184
  _15 = _10 + 18446744073709551320;
  # PT = nonlocal 
  _16 = aa_4(D) + _15;
  # VUSE <.MEM_88>
  _17 = *_16;
  _18 = _14 + _17;
  _19 = (intD.9) _18;
  _20 = (doubleD.39) _19;
  _21 = _18 - _20;
  # .MEM_65 = VDEF <.MEM_88>
  *_11 = _21;
  # RANGE [101, 1009] NONZERO 1023
  j_22 = j_82 + 1;
  # DEBUG jD.3874 => j_22
  # DEBUG jD.3874 => j_22
  if (j_22 > 1008)
    goto <bb 8>;
  else
    goto <bb 7>;
;;    succ:       8 [9.9%]  (TRUE_VALUE,EXECUTABLE)
;;                7 [90.1%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 7, loop depth 1, count 0, freq 911, maybe hot
;;    prev block 6, next block 8, flags: (NEW)
;;    pred:       6 [90.1%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 6>;
;;    succ:       6 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 8, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 7, next block 9, flags: (NEW)
;;    pred:       6 [9.9%]  (TRUE_VALUE,EXECUTABLE)
;;    succ:       9 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 9, loop depth 1, count 0, freq 3702, maybe hot
;;    prev block 8, next block 10, flags: (NEW, REACHABLE)
;;    pred:       8 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                10 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [0, 37] NONZERO 63
  # i_83 = PHI <0(8), i_37(10)>
  # RANGE [1009, 2147483647] NONZERO 2147483647
  # j_84 = PHI <1009(8), j_38(10)>
  # .MEM_89 = PHI <.MEM_65(8), .MEM_66(10)>
  # DEBUG jD.3874 => j_84
  # DEBUG iD.3873 => i_83
  # RANGE [0, 18446744073709551615] NONZERO 2147483647
  _25 = (long unsigned intD.14) j_84;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _26 = _25 * 8;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _27 = _26 + 18446744073709550816;
  # PT = nonlocal 
  _28 = aa_4(D) + _27;
  # VUSE <.MEM_89>
  _29 = *_28;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _30 = _26 + 18446744073709551320;
  # PT = nonlocal 
  _31 = aa_4(D) + _30;
  # VUSE <.MEM_89>
  _32 = *_31;
  _33 = _29 + _32;
  _34 = (intD.9) _33;
  _35 = (doubleD.39) _34;
  _36 = _33 - _35;
  # .MEM_66 = VDEF <.MEM_89>
  ran_uD.2900[i_83] = _36;
  # RANGE [1, 37] NONZERO 63
  i_37 = i_83 + 1;
  # DEBUG iD.3873 => i_37
  # RANGE [1010, 2147483647] NONZERO 2147483647
  j_38 = j_84 + 1;
  # DEBUG jD.3874 => j_38
  # DEBUG jD.3874 => j_38
  # DEBUG iD.3873 => i_37
  if (i_37 == 37)
    goto <bb 11>;
  else
    goto <bb 10>;
;;    succ:       11 [2.7%]  (TRUE_VALUE,EXECUTABLE)
;;                10 [97.3%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 10, loop depth 1, count 0, freq 3602, maybe hot
;;    prev block 9, next block 11, flags: (NEW)
;;    pred:       9 [97.3%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 9>;
;;    succ:       9 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 11, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 10, next block 12, flags: (NEW)
;;    pred:       9 [2.7%]  (TRUE_VALUE,EXECUTABLE)
;;    succ:       12 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 12, loop depth 1, count 0, freq 9900, maybe hot
;;    prev block 11, next block 13, flags: (NEW, REACHABLE)
;;    pred:       11 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                13 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [37, 137] NONZERO 127
  # i_85 = PHI <37(11), i_52(13)>
  # RANGE [1009, 2147483647] NONZERO 2147483647
  # j_86 = PHI <1046(11), j_53(13)>
  # .MEM_90 = PHI <.MEM_66(11), .MEM_67(13)>
  # DEBUG jD.3874 => j_86
  # DEBUG iD.3873 => i_85
  # RANGE [0, 18446744073709551615] NONZERO 2147483647
  _41 = (long unsigned intD.14) j_86;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _42 = _41 * 8;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _43 = _42 + 18446744073709550816;
  # PT = nonlocal 
  _44 = aa_4(D) + _43;
  # VUSE <.MEM_90>
  _45 = *_44;
  # RANGE [0, 62] NONZERO 63
  _46 = i_85 + -37;
  # VUSE <.MEM_90>
  _47 = ran_uD.2900[_46];
  _48 = _45 + _47;
  _49 = (intD.9) _48;
  _50 = (doubleD.39) _49;
  _51 = _48 - _50;
  # .MEM_67 = VDEF <.MEM_90>
  ran_uD.2900[i_85] = _51;
  # RANGE [38, 100] NONZERO 127
  i_52 = i_85 + 1;
  # DEBUG iD.3873 => i_52
  # RANGE [1010, 2147483647] NONZERO 2147483647
  j_53 = j_86 + 1;
  # DEBUG jD.3874 => j_53
  # DEBUG jD.3874 => j_53
  # DEBUG iD.3873 => i_52
  if (i_52 > 99)
    goto <bb 14>;
  else
    goto <bb 13>;
;;    succ:       14 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                13 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 13, loop depth 1, count 0, freq 9800, maybe hot
;;    prev block 12, next block 14, flags: (NEW)
;;    pred:       12 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 12>;
;;    succ:       12 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 14, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 13, next block 1, flags: (NEW, REACHABLE)
;;    pred:       12 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # VUSE <.MEM_67>
  return;
;;    succ:       EXIT [100.0%] 

}


Creating dr for ran_u[j_81]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for ran_u[j_81]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for *_5
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_4
Creating dr for *_5
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_4
Creating dr for ran_u[j_81]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for ran_u[j_81]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for *_5
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_4
Creating dr for *_5
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_4
Analyzing # of iterations of loop 4
  exit condition [1, + , 1](no_overflow) != 100
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
Analyzing # of iterations of loop 4
  exit condition [1, + , 1](no_overflow) != 100
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
Creating dr for *_13
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_3
Creating dr for *_13
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_3
Creating dr for *_16
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {504B, +, 8}_3
Creating dr for *_16
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {504B, +, 8}_3
Creating dr for *_11
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {800B, +, 8}_3
Creating dr for *_11
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {800B, +, 8}_3
Creating dr for *_13
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_3
Creating dr for *_13
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_3
Creating dr for *_16
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {504B, +, 8}_3
Creating dr for *_16
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {504B, +, 8}_3
Creating dr for *_11
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {800B, +, 8}_3
Creating dr for *_11
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {800B, +, 8}_3
Analyzing # of iterations of loop 3
  exit condition [101, + , 1](no_overflow) <= 1008
  bounds on difference of bases: 907 ... 907
  result:
    # of iterations 908, bounded by 908
Analyzing # of iterations of loop 3
  exit condition [101, + , 1](no_overflow) <= 1008
  bounds on difference of bases: 907 ... 907
  result:
    # of iterations 908, bounded by 908
Creating dr for *_28
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7272
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7272B, +, 8}_2
Creating dr for *_28
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7272
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7272B, +, 8}_2
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7776
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7776B, +, 8}_2
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7776
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7776B, +, 8}_2
Creating dr for ran_u[i_83]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_2
Creating dr for ran_u[i_83]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_2
Creating dr for *_28
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7272
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7272B, +, 8}_2
Creating dr for *_28
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7272
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7272B, +, 8}_2
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7776
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7776B, +, 8}_2
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7776
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7776B, +, 8}_2
Creating dr for ran_u[i_83]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_2
Creating dr for ran_u[i_83]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_2
Analyzing # of iterations of loop 2
  exit condition [1, + , 1](no_overflow) != 37
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Analyzing # of iterations of loop 2
  exit condition [1, + , 1](no_overflow) != 37
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7568
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7568B, +, 8}_1
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7568
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7568B, +, 8}_1
Creating dr for ran_u[_46]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_1
Creating dr for ran_u[_46]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_1
Creating dr for ran_u[i_85]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_1
Creating dr for ran_u[i_85]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_1
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7568
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7568B, +, 8}_1
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7568
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7568B, +, 8}_1
Creating dr for ran_u[_46]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_1
Creating dr for ran_u[_46]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_1
Creating dr for ran_u[i_85]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_1
Creating dr for ran_u[i_85]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_1
Analyzing # of iterations of loop 1
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62
Analyzing # of iterations of loop 1
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62

Before limit_scops SCoP statistics (BBS:17, LOOPS:4, CONDITIONS:4, STMTS:75)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

number of SCoPs: 4

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:19)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:22)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:21)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:10)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Global statistics (BBS:19, LOOPS:4, CONDITIONS:4, STMTS:75)

Global profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)
Creating dr for *_13
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_3
Creating dr for *_16
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {504B, +, 8}_3
Creating dr for *_11
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {800B, +, 8}_3

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 908; c1 += 1)
  S_6(c1);


Removing basic block 24
basic block 24, loop depth 0
 pred:      
goto <bb 22>;
 succ:       22



Updating SSA:
Registering new PHI nodes in block #21
Registering new PHI nodes in block #23
Registering new PHI nodes in block #6
Updating SSA information for statement *_11 = _21;
Registering new PHI nodes in block #7
Registering new PHI nodes in block #8
Registering new PHI nodes in block #22
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #17
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #16
Registering new PHI nodes in block #12
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15

DFA Statistics for void ranf_array(double*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                             89        712b
DEF operands                             46        368b
VUSE operands                            12         96b
VDEF operands                             4         32b
PHI nodes                                11       1144b
PHI arguments                            22       1056b
---------------------------------------------------------
Total memory used by DFA/SSA data                 3408b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_118 -> { .MEM_65 }
Incremental SSA update started at block: 21
Number of blocks in CFG: 25
Number of blocks to update: 8 ( 32%)
Affected blocks: 6 7 8 9 17 21 22 23


Applying pattern match.pd:397, generic-match.c:4039
gimple_simplified to _106 = _111 + _115;
Applying pattern match.pd:397, generic-match.c:4039

Updating SSA:
creating PHI node in block #26 for .MEM
creating PHI node in block #29 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #3
Updating SSA information for statement _6 = ran_u[j_81];
Updating SSA information for statement *_5 = _6;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #18
Registering new PHI nodes in block #21
Registering new PHI nodes in block #25
Registering new PHI nodes in block #29
Registering new PHI nodes in block #33
Updating SSA information for statement _115 = *_112;
Updating SSA information for statement _111 = *_107;
Updating SSA information for statement _106 = _111 + _115;
Updating SSA information for statement _105 = (int) _106;
Updating SSA information for statement _104 = (double) _105;
Updating SSA information for statement _103 = _106 - _104;
Updating SSA information for statement *_98 = _103;
Registering new PHI nodes in block #31
Registering new PHI nodes in block #30
Registering new PHI nodes in block #32
Registering new PHI nodes in block #27
Registering new PHI nodes in block #28
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #6
Updating SSA information for statement _14 = *_13;
Updating SSA information for statement _17 = *_16;
Updating SSA information for statement _18 = _14 + _17;
Updating SSA information for statement _19 = (int) _18;
Updating SSA information for statement _20 = (double) _19;
Updating SSA information for statement _21 = _18 - _20;
Updating SSA information for statement *_11 = _21;
Registering new PHI nodes in block #7
Registering new PHI nodes in block #8
Registering new PHI nodes in block #22
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #17
Registering new PHI nodes in block #9
Updating SSA information for statement _29 = *_28;
Updating SSA information for statement _32 = *_31;
Updating SSA information for statement ran_u[i_83] = _36;
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #16
Registering new PHI nodes in block #12
Updating SSA information for statement _45 = *_44;
Updating SSA information for statement _47 = ran_u[_46];
Updating SSA information for statement ran_u[i_85] = _51;
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Updating SSA information for statement return;

DFA Statistics for void ranf_array(double*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            115        920b
DEF operands                             64        512b
VUSE operands                            15        120b
VDEF operands                             5         40b
PHI nodes                                14       1456b
PHI arguments                            28       1344b
---------------------------------------------------------
Total memory used by DFA/SSA data                 4392b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_102 -> { .MEM_65 }
_103 -> { _21 }
_104 -> { _20 }
_105 -> { _19 }
_106 -> { _18 }
_111 -> { _17 }
_115 -> { _14 }

Symbols to be put in SSA form
{ D.3870 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 34
Number of blocks to update: 32 ( 94%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 31 32 33



0 loops carried no dependency.
Creating dr for *_28
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7272
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7272B, +, 8}_2
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7776
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7776B, +, 8}_2
Creating dr for ran_u[i_83]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_2
Analyzing # of iterations of loop 2
  exit condition [1, + , 1](no_overflow) != 37
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 36; c1 += 1)
  S_9(c1);


Removing basic block 39
basic block 39, loop depth 0
 pred:      
goto <bb 37>;
 succ:       37



Updating SSA:
Registering new PHI nodes in block #36
Registering new PHI nodes in block #38
Registering new PHI nodes in block #9
Updating SSA information for statement ran_u[i_83] = _36;
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #37
Registering new PHI nodes in block #35
Registering new PHI nodes in block #34
Registering new PHI nodes in block #16
Registering new PHI nodes in block #12
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15

DFA Statistics for void ranf_array(double*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            115        920b
DEF operands                             64        512b
VUSE operands                            15        120b
VDEF operands                             5         40b
PHI nodes                                15       1560b
PHI arguments                            30       1440b
---------------------------------------------------------
Total memory used by DFA/SSA data                 4592b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_79 -> { .MEM_66 }
Incremental SSA update started at block: 36
Number of blocks in CFG: 40
Number of blocks to update: 8 ( 20%)
Affected blocks: 9 10 11 12 16 36 37 38


Applying pattern match.pd:397, generic-match.c:4039
Applying pattern match.pd:397, generic-match.c:4039
gimple_simplified to _61 = _71 + _76;

Updating SSA:
creating PHI node in block #41 for .MEM
creating PHI node in block #44 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #3
Updating SSA information for statement _6 = ran_u[j_81];
Updating SSA information for statement *_5 = _6;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #18
Registering new PHI nodes in block #21
Registering new PHI nodes in block #25
Registering new PHI nodes in block #29
Registering new PHI nodes in block #33
Updating SSA information for statement _115 = *_112;
Updating SSA information for statement _111 = *_107;
Updating SSA information for statement *_98 = _103;
Registering new PHI nodes in block #31
Registering new PHI nodes in block #30
Registering new PHI nodes in block #32
Registering new PHI nodes in block #27
Registering new PHI nodes in block #28
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #6
Updating SSA information for statement _14 = *_13;
Updating SSA information for statement _17 = *_16;
Updating SSA information for statement *_11 = _21;
Registering new PHI nodes in block #7
Registering new PHI nodes in block #8
Registering new PHI nodes in block #22
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #17
Registering new PHI nodes in block #36
Registering new PHI nodes in block #40
Registering new PHI nodes in block #44
Registering new PHI nodes in block #48
Updating SSA information for statement _76 = *_72;
Updating SSA information for statement _71 = *_62;
Updating SSA information for statement _61 = _71 + _76;
Updating SSA information for statement _60 = (int) _61;
Updating SSA information for statement _59 = (double) _60;
Updating SSA information for statement _58 = _61 - _59;
Updating SSA information for statement ran_u[_56] = _58;
Registering new PHI nodes in block #46
Registering new PHI nodes in block #45
Registering new PHI nodes in block #47
Registering new PHI nodes in block #42
Registering new PHI nodes in block #43
Registering new PHI nodes in block #41
Registering new PHI nodes in block #38
Registering new PHI nodes in block #9
Updating SSA information for statement _29 = *_28;
Updating SSA information for statement _32 = *_31;
Updating SSA information for statement _33 = _29 + _32;
Updating SSA information for statement _34 = (int) _33;
Updating SSA information for statement _35 = (double) _34;
Updating SSA information for statement _36 = _33 - _35;
Updating SSA information for statement ran_u[i_83] = _36;
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #37
Registering new PHI nodes in block #35
Registering new PHI nodes in block #34
Registering new PHI nodes in block #16
Registering new PHI nodes in block #12
Updating SSA information for statement _45 = *_44;
Updating SSA information for statement _47 = ran_u[_46];
Updating SSA information for statement ran_u[i_85] = _51;
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Updating SSA information for statement return;

DFA Statistics for void ranf_array(double*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            138       1104b
DEF operands                             80        640b
VUSE operands                            18        144b
VDEF operands                             6         48b
PHI nodes                                18       1872b
PHI arguments                            36       1728b
---------------------------------------------------------
Total memory used by DFA/SSA data                 5536b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_57 -> { .MEM_66 }
_58 -> { _36 }
_59 -> { _35 }
_60 -> { _34 }
_61 -> { _33 }
_71 -> { _32 }
_76 -> { _29 }

Symbols to be put in SSA form
{ D.3870 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 49
Number of blocks to update: 46 ( 94%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 31 32 33 34 35 36 37 38 40 41 42 43 44 45 46 47 48



1 loops carried no dependency.
Creating dr for *_44
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 7568
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {7568B, +, 8}_1
Creating dr for ran_u[_46]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_1
Creating dr for ran_u[i_85]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_1
Analyzing # of iterations of loop 1
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 62; c1 += 1)
  S_12(c1);


Removing basic block 54
basic block 54, loop depth 0
 pred:      
goto <bb 52>;
 succ:       52



Updating SSA:
Registering new PHI nodes in block #51
Registering new PHI nodes in block #53
Registering new PHI nodes in block #12
Updating SSA information for statement ran_u[i_85] = _51;
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #52
Registering new PHI nodes in block #50
Registering new PHI nodes in block #49
Registering new PHI nodes in block #15
Updating SSA information for statement return;

DFA Statistics for void ranf_array(double*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            138       1104b
DEF operands                             80        640b
VUSE operands                            18        144b
VDEF operands                             6         48b
PHI nodes                                19       1976b
PHI arguments                            38       1824b
---------------------------------------------------------
Total memory used by DFA/SSA data                 5736b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_144 -> { .MEM_67 }
Incremental SSA update started at block: 51
Number of blocks in CFG: 55
Number of blocks to update: 7 ( 13%)
Affected blocks: 12 13 14 15 51 52 53


Applying pattern match.pd:397, generic-match.c:4039
gimple_simplified to _132 = _134 + _139;

Updating SSA:
creating PHI node in block #56 for .MEM
creating PHI node in block #59 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #3
Updating SSA information for statement _6 = ran_u[j_81];
Updating SSA information for statement *_5 = _6;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #18
Registering new PHI nodes in block #21
Registering new PHI nodes in block #25
Registering new PHI nodes in block #29
Registering new PHI nodes in block #33
Updating SSA information for statement _115 = *_112;
Updating SSA information for statement _111 = *_107;
Updating SSA information for statement *_98 = _103;
Registering new PHI nodes in block #31
Registering new PHI nodes in block #30
Registering new PHI nodes in block #32
Registering new PHI nodes in block #27
Registering new PHI nodes in block #28
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #6
Updating SSA information for statement _14 = *_13;
Updating SSA information for statement _17 = *_16;
Updating SSA information for statement *_11 = _21;
Registering new PHI nodes in block #7
Registering new PHI nodes in block #8
Registering new PHI nodes in block #22
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #17
Registering new PHI nodes in block #36
Registering new PHI nodes in block #40
Registering new PHI nodes in block #44
Registering new PHI nodes in block #48
Updating SSA information for statement _76 = *_72;
Updating SSA information for statement _71 = *_62;
Updating SSA information for statement ran_u[_56] = _58;
Registering new PHI nodes in block #46
Registering new PHI nodes in block #45
Registering new PHI nodes in block #47
Registering new PHI nodes in block #42
Registering new PHI nodes in block #43
Registering new PHI nodes in block #41
Registering new PHI nodes in block #38
Registering new PHI nodes in block #9
Updating SSA information for statement _29 = *_28;
Updating SSA information for statement _32 = *_31;
Updating SSA information for statement ran_u[i_83] = _36;
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #37
Registering new PHI nodes in block #35
Registering new PHI nodes in block #34
Registering new PHI nodes in block #16
Registering new PHI nodes in block #51
Registering new PHI nodes in block #55
Registering new PHI nodes in block #59
Registering new PHI nodes in block #63
Updating SSA information for statement _139 = *_135;
Updating SSA information for statement _134 = ran_u[_133];
Updating SSA information for statement _132 = _134 + _139;
Updating SSA information for statement _131 = (int) _132;
Updating SSA information for statement _130 = (double) _131;
Updating SSA information for statement _129 = _132 - _130;
Updating SSA information for statement ran_u[_126] = _129;
Registering new PHI nodes in block #61
Registering new PHI nodes in block #60
Registering new PHI nodes in block #62
Registering new PHI nodes in block #57
Registering new PHI nodes in block #58
Registering new PHI nodes in block #56
Registering new PHI nodes in block #53
Registering new PHI nodes in block #12
Updating SSA information for statement _45 = *_44;
Updating SSA information for statement _47 = ran_u[_46];
Updating SSA information for statement _48 = _45 + _47;
Updating SSA information for statement _49 = (int) _48;
Updating SSA information for statement _50 = (double) _49;
Updating SSA information for statement _51 = _48 - _50;
Updating SSA information for statement ran_u[i_85] = _51;
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #52
Registering new PHI nodes in block #50
Registering new PHI nodes in block #49
Registering new PHI nodes in block #15
Updating SSA information for statement return;

DFA Statistics for void ranf_array(double*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            158       1264b
DEF operands                             94        752b
VUSE operands                            21        168b
VDEF operands                             7         56b
PHI nodes                                22       2288b
PHI arguments                            44       2112b
---------------------------------------------------------
Total memory used by DFA/SSA data                 6640b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_128 -> { .MEM_67 }
_129 -> { _51 }
_130 -> { _50 }
_131 -> { _49 }
_132 -> { _48 }
_134 -> { _47 }
_139 -> { _45 }

Symbols to be put in SSA form
{ D.3870 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 64
Number of blocks to update: 60 ( 94%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 31 32 33 34 35 36 37 38 40 41 42 43 44 45 46 47 48 49 50 51 52 53 55 56 57 58 59 60 61 62 63



1 loops carried no dependency.
Creating dr for ran_u[j_81]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for *_5
analyze_innermost: success.
	base_address: aa_4(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_4(D)
	Access function 0: {0B, +, 8}_4
Analyzing # of iterations of loop 4
  exit condition [1, + , 1](no_overflow) != 100
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 99; c1 += 1)
  S_3(c1);


Removing basic block 69
basic block 69, loop depth 0
 pred:      
goto <bb 67>;
 succ:       67



Updating SSA:
Registering new PHI nodes in block #66
Registering new PHI nodes in block #68
Registering new PHI nodes in block #3
Updating SSA information for statement *_5 = _6;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #67
Registering new PHI nodes in block #65
Registering new PHI nodes in block #64
Registering new PHI nodes in block #18
Registering new PHI nodes in block #21
Registering new PHI nodes in block #25
Registering new PHI nodes in block #29
Registering new PHI nodes in block #33
Registering new PHI nodes in block #31
Registering new PHI nodes in block #30
Registering new PHI nodes in block #32
Registering new PHI nodes in block #27
Registering new PHI nodes in block #28
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #6
Registering new PHI nodes in block #7
Registering new PHI nodes in block #8
Registering new PHI nodes in block #22
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #17
Registering new PHI nodes in block #36
Registering new PHI nodes in block #40
Registering new PHI nodes in block #44
Registering new PHI nodes in block #48
Registering new PHI nodes in block #46
Registering new PHI nodes in block #45
Registering new PHI nodes in block #47
Registering new PHI nodes in block #42
Registering new PHI nodes in block #43
Registering new PHI nodes in block #41
Registering new PHI nodes in block #38
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #37
Registering new PHI nodes in block #35
Registering new PHI nodes in block #34
Registering new PHI nodes in block #16
Registering new PHI nodes in block #51
Registering new PHI nodes in block #55
Registering new PHI nodes in block #59
Registering new PHI nodes in block #63
Registering new PHI nodes in block #61
Registering new PHI nodes in block #60
Registering new PHI nodes in block #62
Registering new PHI nodes in block #57
Registering new PHI nodes in block #58
Registering new PHI nodes in block #56
Registering new PHI nodes in block #53
Registering new PHI nodes in block #12
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #52
Registering new PHI nodes in block #50
Registering new PHI nodes in block #49
Registering new PHI nodes in block #15

DFA Statistics for void ranf_array(double*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            158       1264b
DEF operands                             94        752b
VUSE operands                            21        168b
VDEF operands                             7         56b
PHI nodes                                23       2392b
PHI arguments                            46       2208b
---------------------------------------------------------
Total memory used by DFA/SSA data                 6840b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_145 -> { .MEM_64 }
Incremental SSA update started at block: 66
Number of blocks in CFG: 70
Number of blocks to update: 12 ( 17%)
Affected blocks: 3 4 5 6 21 25 26 28 29 66 67 68



Updating SSA:
creating PHI node in block #71 for .MEM
creating PHI node in block #74 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #66
Registering new PHI nodes in block #70
Registering new PHI nodes in block #74
Registering new PHI nodes in block #78
Updating SSA information for statement _148 = ran_u[_149];
Updating SSA information for statement *_153 = _148;
Registering new PHI nodes in block #76
Registering new PHI nodes in block #75
Registering new PHI nodes in block #77
Registering new PHI nodes in block #72
Registering new PHI nodes in block #73
Registering new PHI nodes in block #71
Registering new PHI nodes in block #68
Registering new PHI nodes in block #3
Updating SSA information for statement _6 = ran_u[j_81];
Updating SSA information for statement *_5 = _6;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #67
Registering new PHI nodes in block #65
Registering new PHI nodes in block #64
Registering new PHI nodes in block #18
Registering new PHI nodes in block #21
Registering new PHI nodes in block #25
Registering new PHI nodes in block #29
Registering new PHI nodes in block #33
Updating SSA information for statement _115 = *_112;
Updating SSA information for statement _111 = *_107;
Updating SSA information for statement *_98 = _103;
Registering new PHI nodes in block #31
Registering new PHI nodes in block #30
Registering new PHI nodes in block #32
Registering new PHI nodes in block #27
Registering new PHI nodes in block #28
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #6
Updating SSA information for statement _14 = *_13;
Updating SSA information for statement _17 = *_16;
Updating SSA information for statement *_11 = _21;
Registering new PHI nodes in block #7
Registering new PHI nodes in block #8
Registering new PHI nodes in block #22
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #17
Registering new PHI nodes in block #36
Registering new PHI nodes in block #40
Registering new PHI nodes in block #44
Registering new PHI nodes in block #48
Updating SSA information for statement _76 = *_72;
Updating SSA information for statement _71 = *_62;
Updating SSA information for statement ran_u[_56] = _58;
Registering new PHI nodes in block #46
Registering new PHI nodes in block #45
Registering new PHI nodes in block #47
Registering new PHI nodes in block #42
Registering new PHI nodes in block #43
Registering new PHI nodes in block #41
Registering new PHI nodes in block #38
Registering new PHI nodes in block #9
Updating SSA information for statement _29 = *_28;
Updating SSA information for statement _32 = *_31;
Updating SSA information for statement ran_u[i_83] = _36;
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #37
Registering new PHI nodes in block #35
Registering new PHI nodes in block #34
Registering new PHI nodes in block #16
Registering new PHI nodes in block #51
Registering new PHI nodes in block #55
Registering new PHI nodes in block #59
Registering new PHI nodes in block #63
Updating SSA information for statement _139 = *_135;
Updating SSA information for statement _134 = ran_u[_133];
Updating SSA information for statement ran_u[_126] = _129;
Registering new PHI nodes in block #61
Registering new PHI nodes in block #60
Registering new PHI nodes in block #62
Registering new PHI nodes in block #57
Registering new PHI nodes in block #58
Registering new PHI nodes in block #56
Registering new PHI nodes in block #53
Registering new PHI nodes in block #12
Updating SSA information for statement _45 = *_44;
Updating SSA information for statement _47 = ran_u[_46];
Updating SSA information for statement ran_u[i_85] = _51;
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #52
Registering new PHI nodes in block #50
Registering new PHI nodes in block #49
Registering new PHI nodes in block #15
Updating SSA information for statement return;

DFA Statistics for void ranf_array(double*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            168       1344b
DEF operands                            100        800b
VUSE operands                            23        184b
VDEF operands                             8         64b
PHI nodes                                26       2704b
PHI arguments                            52       2496b
---------------------------------------------------------
Total memory used by DFA/SSA data                 7592b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

_148 -> { _6 }
.MEM_150 -> { .MEM_64 }

Symbols to be put in SSA form
{ D.3870 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 79
Number of blocks to update: 74 ( 94%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 31 32 33 34 35 36 37 38 40 41 42 43 44 45 46 47 48 49 50 51 52 53 55 56 57 58 59 60 61 62 63 64 65 66 67 68 70 71 72 73 74 75 76 77 78



1 loops carried no dependency.
Merging blocks 2 and 66
Removing basic block 5
basic block 5, loop depth 0
 pred:      
goto <bb 67>;
 succ:       67


Removing basic block 8
basic block 8, loop depth 0
 pred:      
goto <bb 22>;
 succ:       22


Removing basic block 11
basic block 11, loop depth 0
 pred:      
goto <bb 37>;
 succ:       37


Removing basic block 14
basic block 14, loop depth 0
 pred:      
goto <bb 52>;
 succ:       52


Removing basic block 16
basic block 16, loop depth 0
 pred:      
 succ:       51


Removing basic block 17
basic block 17, loop depth 0
 pred:      
 succ:       36


Removing basic block 18
basic block 18, loop depth 0
 pred:      
 succ:       21


Removing basic block 19
basic block 19, loop depth 0
 pred:      
 succ:       36


Removing basic block 20
basic block 20, loop depth 0
 pred:      
goto <bb 36>;
 succ:       36


Removing basic block 7
basic block 7, loop depth 1
 pred:       6
goto <bb 6>;
 succ:       6


Removing basic block 6
basic block 6, loop depth 1
 pred:       21
# j_82 = PHI <100(21)>
# DEBUG j => j_82
_9 = (long unsigned int) j_82;
_10 = _9 * 8;
_11 = aa_4(D) + _10;
_12 = _10 + 18446744073709550816;
_13 = aa_4(D) + _12;
_14 = *_13;
_15 = _10 + 18446744073709551320;
_16 = aa_4(D) + _15;
_17 = *_16;
_18 = _14 + _17;
_19 = (int) _18;
_20 = (double) _19;
_21 = _18 - _20;
*_11 = _21;
j_22 = j_82 + 1;
# DEBUG j => j_22
# DEBUG j => j_22
if (j_22 > 1008)
 succ:       22


Removing basic block 21
basic block 21, loop depth 0
 pred:      
 succ:       25


Removing basic block 23
basic block 23, loop depth 0
 pred:      
 succ:       22


Removing basic block 28
basic block 28, loop depth 0
 pred:       25
goto <bb 26>;
 succ:       26


Removing basic block 27
basic block 27, loop depth 0
 pred:      
 succ:       26


Merging blocks 29 and 33
Removing basic block 32
basic block 32, loop depth 0
 pred:      
 succ:       26


Removing basic block 34
basic block 34, loop depth 0
 pred:      
 succ:       51


Removing basic block 35
basic block 35, loop depth 0
 pred:      
goto <bb 51>;
 succ:       51


Removing basic block 10
basic block 10, loop depth 1
 pred:       9
goto <bb 9>;
 succ:       9


Removing basic block 9
basic block 9, loop depth 1
 pred:       36
# i_83 = PHI <0(36)>
# j_84 = PHI <1009(36)>
# DEBUG j => j_84
# DEBUG i => i_83
_25 = (long unsigned int) j_84;
_26 = _25 * 8;
_27 = _26 + 18446744073709550816;
_28 = aa_4(D) + _27;
_29 = *_28;
_30 = _26 + 18446744073709551320;
_31 = aa_4(D) + _30;
_32 = *_31;
_33 = _29 + _32;
_34 = (int) _33;
_35 = (double) _34;
_36 = _33 - _35;
ran_u[i_83] = _36;
i_37 = i_83 + 1;
# DEBUG i => i_37
j_38 = j_84 + 1;
# DEBUG j => j_38
# DEBUG j => j_38
# DEBUG i => i_37
if (i_37 == 37)
 succ:       37


Removing basic block 36
basic block 36, loop depth 0
 pred:      
 succ:       40


Removing basic block 38
basic block 38, loop depth 0
 pred:      
 succ:       37


Removing basic block 43
basic block 43, loop depth 0
 pred:       40
goto <bb 41>;
 succ:       41


Removing basic block 42
basic block 42, loop depth 0
 pred:      
 succ:       41


Merging blocks 44 and 48
Removing basic block 47
basic block 47, loop depth 0
 pred:      
 succ:       41


Removing basic block 49
basic block 49, loop depth 0
 pred:      
 succ:       15


Removing basic block 50
basic block 50, loop depth 0
 pred:      
goto <bb 15>;
 succ:       15


Removing basic block 13
basic block 13, loop depth 1
 pred:       12
goto <bb 12>;
 succ:       12


Removing basic block 12
basic block 12, loop depth 1
 pred:       51
# i_85 = PHI <37(51)>
# j_86 = PHI <1046(51)>
# DEBUG j => j_86
# DEBUG i => i_85
_41 = (long unsigned int) j_86;
_42 = _41 * 8;
_43 = _42 + 18446744073709550816;
_44 = aa_4(D) + _43;
_45 = *_44;
_46 = i_85 + -37;
_47 = ran_u[_46];
_48 = _45 + _47;
_49 = (int) _48;
_50 = (double) _49;
_51 = _48 - _50;
ran_u[i_85] = _51;
i_52 = i_85 + 1;
# DEBUG i => i_52
j_53 = j_86 + 1;
# DEBUG j => j_53
# DEBUG j => j_53
# DEBUG i => i_52
if (i_52 > 99)
 succ:       52


Removing basic block 51
basic block 51, loop depth 0
 pred:      
 succ:       55


Removing basic block 53
basic block 53, loop depth 0
 pred:      
 succ:       52


Removing basic block 58
basic block 58, loop depth 0
 pred:       55
goto <bb 56>;
 succ:       56


Removing basic block 57
basic block 57, loop depth 0
 pred:      
 succ:       56


Merging blocks 59 and 63
Removing basic block 62
basic block 62, loop depth 0
 pred:      
 succ:       56


Removing basic block 64
basic block 64, loop depth 0
 pred:      
 succ:       25


Removing basic block 65
basic block 65, loop depth 0
 pred:      
goto <bb 25>;
 succ:       25


Merging blocks 67 and 25
Removing basic block 68
basic block 68, loop depth 0
 pred:      
 succ:       67


Removing basic block 73
basic block 73, loop depth 0
 pred:       70
goto <bb 71>;
 succ:       71


Removing basic block 72
basic block 72, loop depth 0
 pred:      
 succ:       71


Merging blocks 74 and 78
Removing basic block 77
basic block 77, loop depth 0
 pred:      
 succ:       71


Removing basic block 4
basic block 4, loop depth 1
 pred:       3
goto <bb 3>;
 succ:       3


Removing basic block 3
basic block 3, loop depth 1
 pred:       2
# j_81 = PHI <0(2)>
# DEBUG j => j_81
_2 = (long unsigned int) j_81;
_3 = _2 * 8;
_5 = aa_4(D) + _3;
_6 = ran_u[j_81];
*_5 = _6;
j_7 = j_81 + 1;
# DEBUG j => j_7
# DEBUG j => j_7
if (j_7 == 100)
 succ:       67


Merging blocks 2 and 70
Merging blocks 26 and 22
Merging blocks 26 and 40
Merging blocks 29 and 31
Merging blocks 41 and 37
Merging blocks 41 and 55
Merging blocks 44 and 46
Merging blocks 56 and 52
Merging blocks 56 and 15
Merging blocks 59 and 61
Merging blocks 71 and 67
Merging blocks 74 and 76
fix_loop_structure: removing loop 1
fix_loop_structure: removing loop 2
fix_loop_structure: removing loop 3
fix_loop_structure: removing loop 4
Analyzing # of iterations of loop 7
  exit condition [0, + , 1](no_overflow) < 62
  bounds on difference of bases: 62 ... 62
  result:
    # of iterations 62, bounded by 62
Analyzing # of iterations of loop 6
  exit condition [0, + , 1](no_overflow) < 36
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Analyzing # of iterations of loop 5
  exit condition [0, + , 1](no_overflow) < 908
  bounds on difference of bases: 908 ... 908
  result:
    # of iterations 908, bounded by 908
Analyzing # of iterations of loop 8
  exit condition [0, + , 1](no_overflow) < 99
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
1 edges in bb 2 predicted to even probabilities
Predictions for bb 3
  DS theory heuristics (ignored): 99.0%
  first match heuristics: 99.0%
  combined heuristics: 99.0%
  loop iterations heuristics: 99.0%
1 edges in bb 4 predicted to even probabilities
1 edges in bb 5 predicted to even probabilities
Predictions for bb 6
  DS theory heuristics (ignored): 99.0%
  first match heuristics: 99.0%
  combined heuristics: 99.0%
  loop iterations heuristics: 99.0%
1 edges in bb 7 predicted to even probabilities
1 edges in bb 8 predicted to even probabilities
Predictions for bb 9
  DS theory heuristics (ignored): 97.3%
  first match heuristics: 97.3%
  combined heuristics: 97.3%
  loop iterations heuristics: 97.3%
1 edges in bb 10 predicted to even probabilities
1 edges in bb 11 predicted to even probabilities
Predictions for bb 12
  DS theory heuristics (ignored): 99.0%
  first match heuristics: 98.4%
  combined heuristics: 98.4%
  early return (on trees) heuristics (ignored): 61.0%
  loop iterations heuristics: 98.4%
1 edges in bb 13 predicted to even probabilities
1 edges in bb 14 predicted to even probabilities
loop_0 (header = 0, latch = 1, niter = )
{
  bb_2 (preds = {bb_0 }, succs = {bb_3 })
  {
    <bb 2>:
    # DEBUG n => 1009
    # DEBUG j => 0

  }
  bb_5 (preds = {bb_3 }, succs = {bb_6 })
  {
    <bb 5>:
    # .MEM_154 = PHI <.MEM_150(3)>

  }
  bb_8 (preds = {bb_6 }, succs = {bb_9 })
  {
    <bb 8>:
    # .MEM_97 = PHI <.MEM_102(6)>

  }
  bb_11 (preds = {bb_9 }, succs = {bb_12 })
  {
    <bb 11>:
    # .MEM_55 = PHI <.MEM_57(9)>

  }
  bb_14 (preds = {bb_12 }, succs = {bb_1 })
  {
    <bb 14>:
    # .MEM_123 = PHI <.MEM_128(12)>
    # VUSE <.MEM_123>
    return;

  }
  loop_7 (header = 12, latch = 13, niter = )
  {
    bb_12 (preds = {bb_11 bb_13 }, succs = {bb_13 bb_14 })
    {
      <bb 12>:
      # graphite_IV.16_143 = PHI <0(11), graphite_IV.16_142(13)>
      # .MEM_122 = PHI <.MEM_55(11), .MEM_128(13)>
      # DEBUG j => NULL
      # DEBUG i => NULL
      _138 = (sizetype) graphite_IV.16_143;
      _137 = _138 + 946;
      _136 = _137 * 8;
      _135 = aa_4(D) + _136;
      # VUSE <.MEM_122>
      _139 = *_135;
      _133 = (int) graphite_IV.16_143;
      # VUSE <.MEM_122>
      _134 = ran_u[_133];
      _132 = _134 + _139;
      _131 = (int) _132;
      _130 = (double) _131;
      _129 = _132 - _130;
      _127 = (int) graphite_IV.16_143;
      _126 = _127 + 37;
      # .MEM_128 = VDEF <.MEM_122>
      ran_u[_126] = _129;
      # DEBUG i => NULL
      # DEBUG j => NULL
      # DEBUG j => NULL
      # DEBUG i => NULL
      graphite_IV.16_142 = graphite_IV.16_143 + 1;
      if (graphite_IV.16_143 < 62)
        goto <bb 13>;
      else
        goto <bb 14>;

    }
    bb_13 (preds = {bb_12 }, succs = {bb_12 })
    {
      <bb 13>:
      goto <bb 12>;

    }
  }
  loop_6 (header = 9, latch = 10, niter = )
  {
    bb_9 (preds = {bb_8 bb_10 }, succs = {bb_10 bb_11 })
    {
      <bb 9>:
      # graphite_IV.15_78 = PHI <0(8), graphite_IV.15_77(10)>
      # .MEM_54 = PHI <.MEM_97(8), .MEM_57(10)>
      # DEBUG j => NULL
      # DEBUG i => NULL
      _75 = (sizetype) graphite_IV.15_78;
      _74 = _75 + 909;
      _73 = _74 * 8;
      _72 = aa_4(D) + _73;
      # VUSE <.MEM_54>
      _76 = *_72;
      _70 = (sizetype) graphite_IV.15_78;
      _69 = _70 + 972;
      _68 = _69 * 8;
      _62 = aa_4(D) + _68;
      # VUSE <.MEM_54>
      _71 = *_62;
      _61 = _71 + _76;
      _60 = (int) _61;
      _59 = (double) _60;
      _58 = _61 - _59;
      _56 = (int) graphite_IV.15_78;
      # .MEM_57 = VDEF <.MEM_54>
      ran_u[_56] = _58;
      # DEBUG i => NULL
      # DEBUG j => NULL
      # DEBUG j => NULL
      # DEBUG i => NULL
      graphite_IV.15_77 = graphite_IV.15_78 + 1;
      if (graphite_IV.15_78 < 36)
        goto <bb 10>;
      else
        goto <bb 11>;

    }
    bb_10 (preds = {bb_9 }, succs = {bb_9 })
    {
      <bb 10>:
      goto <bb 9>;

    }
  }
  loop_5 (header = 6, latch = 7, niter = )
  {
    bb_6 (preds = {bb_5 bb_7 }, succs = {bb_7 bb_8 })
    {
      <bb 6>:
      # graphite_IV.14_117 = PHI <0(5), graphite_IV.14_116(7)>
      # .MEM_96 = PHI <.MEM_154(5), .MEM_102(7)>
      # DEBUG j => NULL
      _114 = (sizetype) graphite_IV.14_117;
      _113 = _114 * 8;
      _112 = aa_4(D) + _113;
      # VUSE <.MEM_96>
      _115 = *_112;
      _110 = (sizetype) graphite_IV.14_117;
      _109 = _110 + 63;
      _108 = _109 * 8;
      _107 = aa_4(D) + _108;
      # VUSE <.MEM_96>
      _111 = *_107;
      _106 = _111 + _115;
      _105 = (int) _106;
      _104 = (double) _105;
      _103 = _106 - _104;
      _101 = (sizetype) graphite_IV.14_117;
      _100 = _101 + 100;
      _99 = _100 * 8;
      _98 = aa_4(D) + _99;
      # .MEM_102 = VDEF <.MEM_96>
      *_98 = _103;
      # DEBUG j => NULL
      # DEBUG j => NULL
      graphite_IV.14_116 = graphite_IV.14_117 + 1;
      if (graphite_IV.14_117 < 908)
        goto <bb 7>;
      else
        goto <bb 8>;

    }
    bb_7 (preds = {bb_6 }, succs = {bb_6 })
    {
      <bb 7>:
      goto <bb 6>;

    }
  }
  loop_8 (header = 3, latch = 4, niter = )
  {
    bb_3 (preds = {bb_2 bb_4 }, succs = {bb_4 bb_5 })
    {
      <bb 3>:
      # graphite_IV.17_146 = PHI <0(2), graphite_IV.17_147(4)>
      # .MEM_155 = PHI <.MEM_63(D)(2), .MEM_150(4)>
      # DEBUG j => NULL
      _149 = (int) graphite_IV.17_146;
      # VUSE <.MEM_155>
      _148 = ran_u[_149];
      _151 = (sizetype) graphite_IV.17_146;
      _152 = _151 * 8;
      _153 = aa_4(D) + _152;
      # .MEM_150 = VDEF <.MEM_155>
      *_153 = _148;
      # DEBUG j => NULL
      # DEBUG j => NULL
      graphite_IV.17_147 = graphite_IV.17_146 + 1;
      if (graphite_IV.17_146 < 99)
        goto <bb 4>;
      else
        goto <bb 5>;

    }
    bb_4 (preds = {bb_3 }, succs = {bb_3 })
    {
      <bb 4>:
      goto <bb 3>;

    }
  }
}

Pass statistics:
----------------

void ranf_array(double*, int) (doubleD.39 * aaD.3872)
{
  signed long graphite_IV.17D.3900;
  doubleD.39 D.3899;
  signed long graphite_IV.16D.3898;
  doubleD.39 D.3897;
  doubleD.39 D.3896;
  intD.9 D.3895;
  doubleD.39 D.3894;
  doubleD.39 D.3893;
  doubleD.39 D.3892;
  signed long graphite_IV.15D.3891;
  doubleD.39 D.3890;
  doubleD.39 D.3889;
  intD.9 D.3888;
  doubleD.39 D.3887;
  doubleD.39 D.3886;
  doubleD.39 D.3885;
  signed long graphite_IV.14D.3884;
  doubleD.39 D.3883;
  doubleD.39 D.3882;
  intD.9 D.3881;
  doubleD.39 D.3880;
  doubleD.39 D.3879;
  doubleD.39 D.3878;
  register intD.9 iD.3873;
  register intD.9 jD.3874;
  intD.9 nD.3871;
  intD.9 _56;
  doubleD.39 _58;
  doubleD.39 _59;
  intD.9 _60;
  doubleD.39 _61;
  doubleD.39 * _62;
  sizetype _68;
  sizetype _69;
  sizetype _70;
  doubleD.39 _71;
  doubleD.39 * _72;
  sizetype _73;
  sizetype _74;
  sizetype _75;
  doubleD.39 _76;
  doubleD.39 * _98;
  sizetype _99;
  sizetype _100;
  sizetype _101;
  doubleD.39 _103;
  doubleD.39 _104;
  intD.9 _105;
  doubleD.39 _106;
  doubleD.39 * _107;
  sizetype _108;
  sizetype _109;
  sizetype _110;
  doubleD.39 _111;
  doubleD.39 * _112;
  sizetype _113;
  sizetype _114;
  doubleD.39 _115;
  intD.9 _126;
  intD.9 _127;
  doubleD.39 _129;
  doubleD.39 _130;
  intD.9 _131;
  doubleD.39 _132;
  intD.9 _133;
  doubleD.39 _134;
  doubleD.39 * _135;
  sizetype _136;
  sizetype _137;
  sizetype _138;
  doubleD.39 _139;
  doubleD.39 _148;
  intD.9 _149;
  sizetype _151;
  sizetype _152;
  doubleD.39 * _153;

;;   basic block 2, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY [100.0%]  (FALLTHRU,EXECUTABLE)
  # DEBUG nD.3871 => 1009
  # DEBUG jD.3874 => 0
;;    succ:       3 [100.0%]  (FALLTHRU)

;;   basic block 3, loop depth 1, count 0, freq 10000, maybe hot
;;    prev block 2, next block 4, flags: (NEW)
;;    pred:       2 [100.0%]  (FALLTHRU)
;;                4 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.17_146 = PHI <0(2), graphite_IV.17_147(4)>
  # .MEM_155 = PHI <.MEM_63(D)(2), .MEM_150(4)>
  # DEBUG jD.3874 => NULL
  _149 = (intD.9) graphite_IV.17_146;
  # VUSE <.MEM_155>
  _148 = ran_uD.2900[_149];
  _151 = (sizetype) graphite_IV.17_146;
  _152 = _151 * 8;
  _153 = aa_4(D) + _152;
  # .MEM_150 = VDEF <.MEM_155>
  *_153 = _148;
  # DEBUG jD.3874 => NULL
  # DEBUG jD.3874 => NULL
  graphite_IV.17_147 = graphite_IV.17_146 + 1;
  if (graphite_IV.17_146 < 99)
    goto <bb 4>;
  else
    goto <bb 5>;
;;    succ:       4 [99.0%]  (TRUE_VALUE)
;;                5 [1.0%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 4, loop depth 1, count 0, freq 9900, maybe hot
;;    prev block 3, next block 5, flags: (NEW)
;;    pred:       3 [99.0%]  (TRUE_VALUE)
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 5, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 4, next block 6, flags: (NEW)
;;    pred:       3 [1.0%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_154 = PHI <.MEM_150(3)>
;;    succ:       6 [100.0%]  (FALLTHRU)

;;   basic block 6, loop depth 1, count 0, freq 10000, maybe hot
;;    prev block 5, next block 7, flags: (NEW)
;;    pred:       5 [100.0%]  (FALLTHRU)
;;                7 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.14_117 = PHI <0(5), graphite_IV.14_116(7)>
  # .MEM_96 = PHI <.MEM_154(5), .MEM_102(7)>
  # DEBUG jD.3874 => NULL
  _114 = (sizetype) graphite_IV.14_117;
  _113 = _114 * 8;
  _112 = aa_4(D) + _113;
  # VUSE <.MEM_96>
  _115 = *_112;
  _110 = (sizetype) graphite_IV.14_117;
  _109 = _110 + 63;
  _108 = _109 * 8;
  _107 = aa_4(D) + _108;
  # VUSE <.MEM_96>
  _111 = *_107;
  _106 = _111 + _115;
  _105 = (intD.9) _106;
  _104 = (doubleD.39) _105;
  _103 = _106 - _104;
  _101 = (sizetype) graphite_IV.14_117;
  _100 = _101 + 100;
  _99 = _100 * 8;
  _98 = aa_4(D) + _99;
  # .MEM_102 = VDEF <.MEM_96>
  *_98 = _103;
  # DEBUG jD.3874 => NULL
  # DEBUG jD.3874 => NULL
  graphite_IV.14_116 = graphite_IV.14_117 + 1;
  if (graphite_IV.14_117 < 908)
    goto <bb 7>;
  else
    goto <bb 8>;
;;    succ:       7 [99.0%]  (TRUE_VALUE)
;;                8 [1.0%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 7, loop depth 1, count 0, freq 9900, maybe hot
;;    prev block 6, next block 8, flags: (NEW)
;;    pred:       6 [99.0%]  (TRUE_VALUE)
  goto <bb 6>;
;;    succ:       6 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 8, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 7, next block 9, flags: (NEW)
;;    pred:       6 [1.0%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_97 = PHI <.MEM_102(6)>
;;    succ:       9 [100.0%]  (FALLTHRU)

;;   basic block 9, loop depth 1, count 0, freq 3704, maybe hot
;;    prev block 8, next block 10, flags: (NEW)
;;    pred:       8 [100.0%]  (FALLTHRU)
;;                10 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.15_78 = PHI <0(8), graphite_IV.15_77(10)>
  # .MEM_54 = PHI <.MEM_97(8), .MEM_57(10)>
  # DEBUG jD.3874 => NULL
  # DEBUG iD.3873 => NULL
  _75 = (sizetype) graphite_IV.15_78;
  _74 = _75 + 909;
  _73 = _74 * 8;
  _72 = aa_4(D) + _73;
  # VUSE <.MEM_54>
  _76 = *_72;
  _70 = (sizetype) graphite_IV.15_78;
  _69 = _70 + 972;
  _68 = _69 * 8;
  _62 = aa_4(D) + _68;
  # VUSE <.MEM_54>
  _71 = *_62;
  _61 = _71 + _76;
  _60 = (intD.9) _61;
  _59 = (doubleD.39) _60;
  _58 = _61 - _59;
  _56 = (intD.9) graphite_IV.15_78;
  # .MEM_57 = VDEF <.MEM_54>
  ran_uD.2900[_56] = _58;
  # DEBUG iD.3873 => NULL
  # DEBUG jD.3874 => NULL
  # DEBUG jD.3874 => NULL
  # DEBUG iD.3873 => NULL
  graphite_IV.15_77 = graphite_IV.15_78 + 1;
  if (graphite_IV.15_78 < 36)
    goto <bb 10>;
  else
    goto <bb 11>;
;;    succ:       10 [97.3%]  (TRUE_VALUE)
;;                11 [2.7%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 10, loop depth 1, count 0, freq 3604, maybe hot
;;    prev block 9, next block 11, flags: (NEW)
;;    pred:       9 [97.3%]  (TRUE_VALUE)
  goto <bb 9>;
;;    succ:       9 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 11, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 10, next block 12, flags: (NEW)
;;    pred:       9 [2.7%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_55 = PHI <.MEM_57(9)>
;;    succ:       12 [100.0%]  (FALLTHRU)

;;   basic block 12, loop depth 1, count 0, freq 6289, maybe hot
;;    prev block 11, next block 13, flags: (NEW)
;;    pred:       11 [100.0%]  (FALLTHRU)
;;                13 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.16_143 = PHI <0(11), graphite_IV.16_142(13)>
  # .MEM_122 = PHI <.MEM_55(11), .MEM_128(13)>
  # DEBUG jD.3874 => NULL
  # DEBUG iD.3873 => NULL
  _138 = (sizetype) graphite_IV.16_143;
  _137 = _138 + 946;
  _136 = _137 * 8;
  _135 = aa_4(D) + _136;
  # VUSE <.MEM_122>
  _139 = *_135;
  _133 = (intD.9) graphite_IV.16_143;
  # VUSE <.MEM_122>
  _134 = ran_uD.2900[_133];
  _132 = _134 + _139;
  _131 = (intD.9) _132;
  _130 = (doubleD.39) _131;
  _129 = _132 - _130;
  _127 = (intD.9) graphite_IV.16_143;
  _126 = _127 + 37;
  # .MEM_128 = VDEF <.MEM_122>
  ran_uD.2900[_126] = _129;
  # DEBUG iD.3873 => NULL
  # DEBUG jD.3874 => NULL
  # DEBUG jD.3874 => NULL
  # DEBUG iD.3873 => NULL
  graphite_IV.16_142 = graphite_IV.16_143 + 1;
  if (graphite_IV.16_143 < 62)
    goto <bb 13>;
  else
    goto <bb 14>;
;;    succ:       13 [98.4%]  (TRUE_VALUE)
;;                14 [1.6%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 13, loop depth 1, count 0, freq 6189, maybe hot
;;    prev block 12, next block 14, flags: (NEW)
;;    pred:       12 [98.4%]  (TRUE_VALUE)
  goto <bb 12>;
;;    succ:       12 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 14, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 13, next block 1, flags: (NEW)
;;    pred:       12 [1.6%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_123 = PHI <.MEM_128(12)>
  # VUSE <.MEM_123>
  return;
;;    succ:       EXIT [100.0%] 

}



;; Function void ranf_array(double*, int) (_Z10ranf_arrayPdi, funcdef_no=0, decl_uid=2903, cgraph_uid=0, symbol_order=1)


Pass statistics:
----------------

void ranf_array(double*, int) (doubleD.39 * aaD.2901, intD.9 nD.2902)
{
  register intD.9 jD.2906;
  register intD.9 iD.2905;
  long unsigned intD.14 _12;
  long unsigned intD.14 _13;
  doubleD.39 * _15;
  doubleD.39 _16;
  long unsigned intD.14 _20;
  long unsigned intD.14 _21;
  doubleD.39 * _22;
  sizetype _25;
  doubleD.39 * _26;
  doubleD.39 _27;
  sizetype _29;
  doubleD.39 * _30;
  doubleD.39 _31;
  doubleD.39 _34;
  intD.9 _35;
  doubleD.39 _36;
  doubleD.39 _37;
  long unsigned intD.14 _40;
  long unsigned intD.14 _41;
  sizetype _42;
  doubleD.39 * _43;
  doubleD.39 _44;
  sizetype _45;
  doubleD.39 * _46;
  doubleD.39 _47;
  doubleD.39 _48;
  intD.9 _49;
  doubleD.39 _50;
  doubleD.39 _51;
  long unsigned intD.14 _55;
  long unsigned intD.14 _56;
  sizetype _57;
  doubleD.39 * _58;
  doubleD.39 _59;
  intD.9 _60;
  doubleD.39 _61;
  doubleD.39 _62;
  intD.9 _63;
  doubleD.39 _64;
  doubleD.39 _65;

;;   basic block 2, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY [100.0%]  (FALLTHRU,EXECUTABLE)
  # DEBUG jD.2906 => 0
  # DEBUG jD.2906 => 0
;;    succ:       3 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 3, loop depth 1, count 0, freq 9900, maybe hot
;;    prev block 2, next block 4, flags: (NEW, REACHABLE)
;;    pred:       4 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                2 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 100] NONZERO 127
  # j_82 = PHI <j_18(4), 0(2)>
  # .MEM_85 = PHI <.MEM_17(4), .MEM_11(D)(2)>
  # DEBUG jD.2906 => j_82
  # RANGE [0, 99] NONZERO 127
  _12 = (long unsigned intD.14) j_82;
  # RANGE [0, 792] NONZERO 1016
  _13 = _12 * 8;
  # PT = nonlocal 
  _15 = aa_14(D) + _13;
  # VUSE <.MEM_85>
  _16 = ran_uD.2900[j_82];
  # .MEM_17 = VDEF <.MEM_85>
  *_15 = _16;
  # RANGE [1, 100] NONZERO 127
  j_18 = j_82 + 1;
  # DEBUG jD.2906 => j_18
  # DEBUG jD.2906 => j_18
  if (j_18 == 100)
    goto <bb 5>;
  else
    goto <bb 4>;
;;    succ:       5 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                4 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 4, loop depth 1, count 0, freq 9800, maybe hot
;;    prev block 3, next block 5, flags: (NEW)
;;    pred:       3 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 5, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 4, next block 6, flags: (NEW, REACHABLE)
;;    pred:       3 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # DEBUG jD.2906 => 100
  if (n_19(D) <= 100)
    goto <bb 9>;
  else
    goto <bb 6>;
;;    succ:       9 [9.0%]  (TRUE_VALUE,EXECUTABLE)
;;                6 [91.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 6, loop depth 0, count 0, freq 91, maybe hot
;;    prev block 5, next block 7, flags: (NEW)
;;    pred:       5 [91.0%]  (FALSE_VALUE,EXECUTABLE)
;;    succ:       7 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 7, loop depth 1, count 0, freq 1011, maybe hot
;;    prev block 6, next block 8, flags: (NEW, REACHABLE)
;;    pred:       6 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                8 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # j_78 = PHI <100(6), j_39(8)>
  # .MEM_3 = PHI <.MEM_17(6), .MEM_38(8)>
  # DEBUG jD.2906 => j_78
  # RANGE [0, 18446744073709551615]
  _20 = (long unsigned intD.14) j_78;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _21 = _20 * 8;
  # PT = nonlocal 
  _22 = aa_14(D) + _21;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _25 = _21 + 18446744073709550816;
  # PT = nonlocal 
  _26 = aa_14(D) + _25;
  # VUSE <.MEM_3>
  _27 = *_26;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _29 = _21 + 18446744073709551320;
  # PT = nonlocal 
  _30 = aa_14(D) + _29;
  # VUSE <.MEM_3>
  _31 = *_30;
  _34 = _27 + _31;
  _35 = (intD.9) _34;
  _36 = (doubleD.39) _35;
  _37 = _34 - _36;
  # .MEM_38 = VDEF <.MEM_3>
  *_22 = _37;
  j_39 = j_78 + 1;
  # DEBUG jD.2906 => j_39
  # DEBUG jD.2906 => j_39
  if (n_19(D) <= j_39)
    goto <bb 9>;
  else
    goto <bb 8>;
;;    succ:       9 [9.0%]  (TRUE_VALUE,EXECUTABLE)
;;                8 [91.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 8, loop depth 1, count 0, freq 920, maybe hot
;;    prev block 7, next block 9, flags: (NEW)
;;    pred:       7 [91.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 7>;
;;    succ:       7 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 9, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 8, next block 10, flags: (NEW, REACHABLE)
;;    pred:       7 [9.0%]  (TRUE_VALUE,EXECUTABLE)
;;                5 [9.0%]  (TRUE_VALUE,EXECUTABLE)
  # j_1 = PHI <n_19(D)(7), 100(5)>
  # .MEM_73 = PHI <.MEM_38(7), .MEM_17(5)>
;;    succ:       10 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 10, loop depth 1, count 0, freq 3702, maybe hot
;;    prev block 9, next block 11, flags: (NEW, REACHABLE)
;;    pred:       9 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                11 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [0, 37] NONZERO 63
  # i_80 = PHI <0(9), i_53(11)>
  # j_83 = PHI <j_1(9), j_54(11)>
  # .MEM_86 = PHI <.MEM_73(9), .MEM_52(11)>
  # DEBUG jD.2906 => j_83
  # DEBUG iD.2905 => i_80
  # RANGE ~[2147483648, 18446744071562067967]
  _40 = (long unsigned intD.14) j_83;
  # RANGE [0, 18446744073709551608] NONZERO 18446744073709551608
  _41 = _40 * 8;
  # RANGE ~[18446744073709550809, 18446744073709550815] NONZERO 18446744073709551608
  _42 = _41 + 18446744073709550816;
  # PT = nonlocal 
  _43 = aa_14(D) + _42;
  # VUSE <.MEM_86>
  _44 = *_43;
  # RANGE ~[18446744073709551313, 18446744073709551319] NONZERO 18446744073709551608
  _45 = _41 + 18446744073709551320;
  # PT = nonlocal 
  _46 = aa_14(D) + _45;
  # VUSE <.MEM_86>
  _47 = *_46;
  _48 = _44 + _47;
  _49 = (intD.9) _48;
  _50 = (doubleD.39) _49;
  _51 = _48 - _50;
  # .MEM_52 = VDEF <.MEM_86>
  ran_uD.2900[i_80] = _51;
  # RANGE [1, 37] NONZERO 63
  i_53 = i_80 + 1;
  # DEBUG iD.2905 => i_53
  j_54 = j_83 + 1;
  # DEBUG jD.2906 => j_54
  # DEBUG jD.2906 => j_54
  # DEBUG iD.2905 => i_53
  if (i_53 == 37)
    goto <bb 12>;
  else
    goto <bb 11>;
;;    succ:       12 [2.7%]  (TRUE_VALUE,EXECUTABLE)
;;                11 [97.3%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 11, loop depth 1, count 0, freq 3602, maybe hot
;;    prev block 10, next block 12, flags: (NEW)
;;    pred:       10 [97.3%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 10>;
;;    succ:       10 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 12, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 11, next block 13, flags: (NEW)
;;    pred:       10 [2.7%]  (TRUE_VALUE,EXECUTABLE)
  j_192 = j_1 + 37;
;;    succ:       13 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 13, loop depth 1, count 0, freq 9900, maybe hot
;;    prev block 12, next block 14, flags: (NEW, REACHABLE)
;;    pred:       12 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                14 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [37, 137] NONZERO 127
  # i_81 = PHI <37(12), i_67(14)>
  # j_84 = PHI <j_192(12), j_68(14)>
  # .MEM_87 = PHI <.MEM_52(12), .MEM_66(14)>
  # DEBUG jD.2906 => j_84
  # DEBUG iD.2905 => i_81
  # RANGE ~[2147483648, 18446744071562067967]
  _55 = (long unsigned intD.14) j_84;
  # RANGE [0, 18446744073709551608] NONZERO 18446744073709551608
  _56 = _55 * 8;
  # RANGE ~[18446744073709550809, 18446744073709550815] NONZERO 18446744073709551608
  _57 = _56 + 18446744073709550816;
  # PT = nonlocal 
  _58 = aa_14(D) + _57;
  # VUSE <.MEM_87>
  _59 = *_58;
  # RANGE [0, 62] NONZERO 63
  _60 = i_81 + -37;
  # VUSE <.MEM_87>
  _61 = ran_uD.2900[_60];
  _62 = _59 + _61;
  _63 = (intD.9) _62;
  _64 = (doubleD.39) _63;
  _65 = _62 - _64;
  # .MEM_66 = VDEF <.MEM_87>
  ran_uD.2900[i_81] = _65;
  # RANGE [38, 100] NONZERO 127
  i_67 = i_81 + 1;
  # DEBUG iD.2905 => i_67
  j_68 = j_84 + 1;
  # DEBUG jD.2906 => j_68
  # DEBUG jD.2906 => j_68
  # DEBUG iD.2905 => i_67
  if (i_67 > 99)
    goto <bb 15>;
  else
    goto <bb 14>;
;;    succ:       15 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                14 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 14, loop depth 1, count 0, freq 9800, maybe hot
;;    prev block 13, next block 15, flags: (NEW)
;;    pred:       13 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 13>;
;;    succ:       13 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 15, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 14, next block 1, flags: (NEW, REACHABLE)
;;    pred:       13 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # VUSE <.MEM_66>
  return;
;;    succ:       EXIT [100.0%] 

}



Updating SSA:
Registering new PHI nodes in block #19
Updating SSA information for statement if (n_19(D) <= 100)
Registering new PHI nodes in block #6
Registering new PHI nodes in block #7
Updating SSA information for statement *_22 = _37;
Updating SSA information for statement if (n_19(D) <= j_39)
Registering new PHI nodes in block #8
Registering new PHI nodes in block #18
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #17
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16

DFA Statistics for void ranf_array(double*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                             92        736b
DEF operands                             47        376b
VUSE operands                            12         96b
VDEF operands                             4         32b
PHI nodes                                14       1456b
PHI arguments                            26       1248b
---------------------------------------------------------
Total memory used by DFA/SSA data                 3944b
---------------------------------------------------------

Average number of arguments per PHI node: 1.9 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_144 -> { .MEM_38 }
n_193 -> { n_19(D) }
Incremental SSA update started at block: 19
Number of blocks in CFG: 20
Number of blocks to update: 4 ( 20%)
Affected blocks: 7 8 18 19


Creating dr for ran_u[j_82]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_1
Creating dr for ran_u[j_82]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_1
Creating dr for *_15
analyze_innermost: success.
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {0B, +, 8}_1
Creating dr for *_15
analyze_innermost: success.
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {0B, +, 8}_1
Creating dr for ran_u[j_82]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_1
Creating dr for ran_u[j_82]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_1
Creating dr for *_15
analyze_innermost: success.
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {0B, +, 8}_1
Creating dr for *_15
analyze_innermost: success.
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {0B, +, 8}_1
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 100
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 100
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
Creating dr for *_26
analyze_innermost: success.
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {0B, +, 8}_2
Creating dr for *_26
analyze_innermost: success.
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {0B, +, 8}_2
Creating dr for *_30
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {504B, +, 8}_2
Creating dr for *_30
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {504B, +, 8}_2
Creating dr for *_22
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {800B, +, 8}_2
Creating dr for *_22
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {800B, +, 8}_2
Creating dr for *_26
analyze_innermost: success.
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {0B, +, 8}_2
Creating dr for *_26
analyze_innermost: success.
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {0B, +, 8}_2
Creating dr for *_30
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {504B, +, 8}_2
Creating dr for *_30
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {504B, +, 8}_2
Creating dr for *_22
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {800B, +, 8}_2
Creating dr for *_22
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {800B, +, 8}_2
Analyzing # of iterations of loop 2
  exit condition [101, + , 1](no_overflow) < n_19(D)
  bounds on difference of bases: 0 ... 2147483546
  result:
    # of iterations (unsigned int) n_19(D) + 4294967195, bounded by 2147483546
Analyzing # of iterations of loop 2
  exit condition [101, + , 1](no_overflow) < n_19(D)
  bounds on difference of bases: 0 ... 2147483546
  result:
    # of iterations (unsigned int) n_19(D) + 4294967195, bounded by 2147483546
Creating dr for *_43
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -800(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-800B, +, 8}_3
Creating dr for *_43
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -800(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-800B, +, 8}_3
Creating dr for *_46
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -296(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-296B, +, 8}_3
Creating dr for *_46
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -296(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-296B, +, 8}_3
Creating dr for ran_u[i_80]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_3
Creating dr for ran_u[i_80]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_3
Creating dr for *_43
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -800(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-800B, +, 8}_3
Creating dr for *_43
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -800(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-800B, +, 8}_3
Creating dr for *_46
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -296(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-296B, +, 8}_3
Creating dr for *_46
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -296(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-296B, +, 8}_3
Creating dr for ran_u[i_80]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_3
Creating dr for ran_u[i_80]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_3
Analyzing # of iterations of loop 3
  exit condition [1, + , 1](no_overflow) != 37
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Analyzing # of iterations of loop 3
  exit condition [1, + , 1](no_overflow) != 37
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Creating dr for *_58
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -504(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-504B, +, 8}_4
Creating dr for *_58
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -504(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-504B, +, 8}_4
Creating dr for ran_u[_60]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for ran_u[_60]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for ran_u[i_81]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_4
Creating dr for ran_u[i_81]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_4
Creating dr for *_58
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -504(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-504B, +, 8}_4
Creating dr for *_58
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -504(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-504B, +, 8}_4
Creating dr for ran_u[_60]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for ran_u[_60]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for ran_u[i_81]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_4
Creating dr for ran_u[i_81]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_4
Analyzing # of iterations of loop 4
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62
Analyzing # of iterations of loop 4
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62

Before limit_scops SCoP statistics (BBS:18, LOOPS:4, CONDITIONS:5, STMTS:78)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

number of SCoPs: 4

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:10)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:19)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:22)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:21)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Global statistics (BBS:20, LOOPS:4, CONDITIONS:5, STMTS:78)

Global profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)
Creating dr for ran_u[j_82]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_1
Creating dr for *_15
analyze_innermost: success.
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {0B, +, 8}_1

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 99; c1 += 1)
  S_3(c1);


Removing basic block 25
basic block 25, loop depth 0
 pred:      
goto <bb 23>;
 succ:       23



Updating SSA:
Registering new PHI nodes in block #22
Registering new PHI nodes in block #24
Registering new PHI nodes in block #3
Updating SSA information for statement *_15 = _16;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #23
Registering new PHI nodes in block #21
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #6
Registering new PHI nodes in block #7
Registering new PHI nodes in block #8
Registering new PHI nodes in block #18
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #17
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16

DFA Statistics for void ranf_array(double*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                             92        736b
DEF operands                             47        376b
VUSE operands                            12         96b
VDEF operands                             4         32b
PHI nodes                                15       1560b
PHI arguments                            28       1344b
---------------------------------------------------------
Total memory used by DFA/SSA data                 4144b
---------------------------------------------------------

Average number of arguments per PHI node: 1.9 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_148 -> { .MEM_17 }
Incremental SSA update started at block: 22
Number of blocks in CFG: 26
Number of blocks to update: 10 ( 38%)
Affected blocks: 3 4 5 6 7 9 19 22 23 24



Updating SSA:
creating PHI node in block #27 for .MEM
creating PHI node in block #30 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #22
Registering new PHI nodes in block #26
Registering new PHI nodes in block #30
Registering new PHI nodes in block #34
Updating SSA information for statement _154 = ran_u[_156];
Updating SSA information for statement *_174 = _154;
Registering new PHI nodes in block #32
Registering new PHI nodes in block #31
Registering new PHI nodes in block #33
Registering new PHI nodes in block #28
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #24
Registering new PHI nodes in block #3
Updating SSA information for statement _16 = ran_u[j_82];
Updating SSA information for statement *_15 = _16;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #23
Registering new PHI nodes in block #21
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #6
Registering new PHI nodes in block #7
Updating SSA information for statement _27 = *_26;
Updating SSA information for statement _31 = *_30;
Updating SSA information for statement *_22 = _37;
Registering new PHI nodes in block #8
Registering new PHI nodes in block #18
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Updating SSA information for statement _44 = *_43;
Updating SSA information for statement _47 = *_46;
Updating SSA information for statement ran_u[i_80] = _51;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #17
Registering new PHI nodes in block #13
Updating SSA information for statement _59 = *_58;
Updating SSA information for statement _61 = ran_u[_60];
Updating SSA information for statement ran_u[i_81] = _65;
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16
Updating SSA information for statement return;

DFA Statistics for void ranf_array(double*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            102        816b
DEF operands                             53        424b
VUSE operands                            14        112b
VDEF operands                             5         40b
PHI nodes                                18       1872b
PHI arguments                            34       1632b
---------------------------------------------------------
Total memory used by DFA/SSA data                 4896b
---------------------------------------------------------

Average number of arguments per PHI node: 1.9 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

_154 -> { _16 }
.MEM_158 -> { .MEM_17 }

Symbols to be put in SSA form
{ D.3846 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 35
Number of blocks to update: 33 ( 94%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 26 27 28 29 30 31 32 33 34



0 loops carried no dependency.
Creating dr for *_26
analyze_innermost: success.
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {0B, +, 8}_2
Creating dr for *_30
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {504B, +, 8}_2
Creating dr for *_22
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: aa_14(D)
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: *aa_14(D)
	Access function 0: {800B, +, 8}_2
Analyzing # of iterations of loop 2
  exit condition [101, + , 1](no_overflow) < n_19(D)
  bounds on difference of bases: 0 ... 2147483546
  result:
    # of iterations (unsigned int) n_19(D) + 4294967195, bounded by 2147483546
Analyzing # of iterations of loop 2
  exit condition [101, + , 1](no_overflow) < n_19(D)
  bounds on difference of bases: 0 ... 2147483546
  result:
    # of iterations (unsigned int) n_19(D) + 4294967195, bounded by 2147483546
Statement (exit)if (n_19(D) <= j_39)
 is executed at most (unsigned int) n_19(D) + 4294967195 (bounded by 2147483546) + 1 times in loop 2.
Induction variable (double *) aa_14(D) + 800 + 8 * iteration does not wrap in statement _22 = aa_14(D) + _21;
 in loop 2.
Statement _22 = aa_14(D) + _21;
 is executed at most 2305843009213693950 (bounded by 2305843009213693950) + 1 times in loop 2.
Induction variable (double *) aa_14(D) + 8 * iteration does not wrap in statement _26 = aa_14(D) + _25;
 in loop 2.
Statement _26 = aa_14(D) + _25;
 is executed at most 2305843009213693950 (bounded by 2305843009213693950) + 1 times in loop 2.
Induction variable (double *) aa_14(D) + 504 + 8 * iteration does not wrap in statement _30 = aa_14(D) + _29;
 in loop 2.
Statement _30 = aa_14(D) + _29;
 is executed at most 2305843009213693950 (bounded by 2305843009213693950) + 1 times in loop 2.
Induction variable (int) 101 + 1 * iteration does not wrap in statement j_39 = j_78 + 1;
 in loop 2.
Statement j_39 = j_78 + 1;
 is executed at most 2147483546 (bounded by 2147483546) + 1 times in loop 2.

ISL AST generated by ISL: 
for (int c1 = 0; c1 < n - 100; c1 += 1)
  S_7(c1);


Removing basic block 40
basic block 40, loop depth 0
 pred:      
goto <bb 38>;
 succ:       38



Updating SSA:
Registering new PHI nodes in block #19
Registering new PHI nodes in block #6
Registering new PHI nodes in block #37
Registering new PHI nodes in block #39
Registering new PHI nodes in block #7
Registering new PHI nodes in block #8
Registering new PHI nodes in block #18
Registering new PHI nodes in block #38
Registering new PHI nodes in block #36
Registering new PHI nodes in block #35
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #17
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16

DFA Statistics for void ranf_array(double*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            102        816b
DEF operands                             53        424b
VUSE operands                            14        112b
VDEF operands                             5         40b
PHI nodes                                19       1976b
PHI arguments                            36       1728b
---------------------------------------------------------
Total memory used by DFA/SSA data                 5096b
---------------------------------------------------------

Average number of arguments per PHI node: 1.9 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_134 -> { .MEM_144 }
Incremental SSA update started at block: 19
Number of blocks in CFG: 41
Number of blocks to update: 5 ( 12%)
Affected blocks: 9 18 35 38 39


Applying pattern match.pd:491, generic-match.c:4667
Applying pattern match.pd:491, generic-match.c:3721
Applying pattern match.pd:397, generic-match.c:4039
gimple_simplified to _119 = _124 + _128;
Applying pattern match.pd:397, generic-match.c:4039

Updating SSA:
creating PHI node in block #42 for .MEM
creating PHI node in block #45 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #22
Registering new PHI nodes in block #26
Registering new PHI nodes in block #30
Registering new PHI nodes in block #34
Updating SSA information for statement _154 = ran_u[_156];
Updating SSA information for statement *_174 = _154;
Registering new PHI nodes in block #32
Registering new PHI nodes in block #31
Registering new PHI nodes in block #33
Registering new PHI nodes in block #28
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #24
Registering new PHI nodes in block #3
Updating SSA information for statement _16 = ran_u[j_82];
Updating SSA information for statement *_15 = _16;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #23
Registering new PHI nodes in block #21
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #6
Registering new PHI nodes in block #37
Registering new PHI nodes in block #41
Registering new PHI nodes in block #47
Registering new PHI nodes in block #45
Registering new PHI nodes in block #50
Updating SSA information for statement _128 = *_125;
Updating SSA information for statement _124 = *_120;
Updating SSA information for statement _119 = _124 + _128;
Updating SSA information for statement _118 = (int) _119;
Updating SSA information for statement _117 = (double) _118;
Updating SSA information for statement _116 = _119 - _117;
Updating SSA information for statement *_111 = _116;
Registering new PHI nodes in block #48
Registering new PHI nodes in block #46
Registering new PHI nodes in block #49
Registering new PHI nodes in block #43
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #39
Registering new PHI nodes in block #7
Updating SSA information for statement _27 = *_26;
Updating SSA information for statement _31 = *_30;
Updating SSA information for statement _34 = _27 + _31;
Updating SSA information for statement _35 = (int) _34;
Updating SSA information for statement _36 = (double) _35;
Updating SSA information for statement _37 = _34 - _36;
Updating SSA information for statement *_22 = _37;
Registering new PHI nodes in block #8
Registering new PHI nodes in block #18
Registering new PHI nodes in block #38
Registering new PHI nodes in block #36
Registering new PHI nodes in block #35
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Updating SSA information for statement _44 = *_43;
Updating SSA information for statement _47 = *_46;
Updating SSA information for statement ran_u[i_80] = _51;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #17
Registering new PHI nodes in block #13
Updating SSA information for statement _59 = *_58;
Updating SSA information for statement _61 = ran_u[_60];
Updating SSA information for statement ran_u[i_81] = _65;
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16
Updating SSA information for statement return;

DFA Statistics for void ranf_array(double*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            133       1064b
DEF operands                             74        592b
VUSE operands                            17        136b
VDEF operands                             6         48b
PHI nodes                                22       2288b
PHI arguments                            42       2016b
---------------------------------------------------------
Total memory used by DFA/SSA data                 6144b
---------------------------------------------------------

Average number of arguments per PHI node: 1.9 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_115 -> { .MEM_38 }
_116 -> { _37 }
_117 -> { _36 }
_118 -> { _35 }
_119 -> { _34 }
_124 -> { _31 }
_128 -> { _27 }

Symbols to be put in SSA form
{ D.3846 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 51
Number of blocks to update: 48 ( 94%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 26 27 28 29 30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46 47 48 49 50



0 loops carried no dependency.
Creating dr for *_43
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -800(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-800B, +, 8}_3
Creating dr for *_46
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -296(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-296B, +, 8}_3
Creating dr for ran_u[i_80]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_3
Analyzing # of iterations of loop 3
  exit condition [1, + , 1](no_overflow) != 37
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 36; c1 += 1)
  S_10(c1);


Removing basic block 56
basic block 56, loop depth 0
 pred:      
goto <bb 54>;
 succ:       54



Updating SSA:
Registering new PHI nodes in block #53
Registering new PHI nodes in block #55
Registering new PHI nodes in block #10
Updating SSA information for statement ran_u[i_80] = _51;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #54
Registering new PHI nodes in block #52
Registering new PHI nodes in block #51
Registering new PHI nodes in block #17
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16

DFA Statistics for void ranf_array(double*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            133       1064b
DEF operands                             74        592b
VUSE operands                            17        136b
VDEF operands                             6         48b
PHI nodes                                23       2392b
PHI arguments                            44       2112b
---------------------------------------------------------
Total memory used by DFA/SSA data                 6344b
---------------------------------------------------------

Average number of arguments per PHI node: 1.9 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_102 -> { .MEM_52 }
Incremental SSA update started at block: 53
Number of blocks in CFG: 57
Number of blocks to update: 8 ( 14%)
Affected blocks: 10 11 12 13 17 53 54 55


Applying pattern match.pd:397, generic-match.c:4039
Applying pattern match.pd:725, generic-match.c:1428
gimple_simplified to _96 = _97 + _98;
Applying pattern match.pd:397, generic-match.c:4039
Applying pattern match.pd:725, generic-match.c:1428
gimple_simplified to _89 = _90 + _91;
gimple_simplified to _76 = _92 + _99;

Updating SSA:
creating PHI node in block #58 for .MEM
creating PHI node in block #61 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #22
Registering new PHI nodes in block #26
Registering new PHI nodes in block #30
Registering new PHI nodes in block #34
Updating SSA information for statement _154 = ran_u[_156];
Updating SSA information for statement *_174 = _154;
Registering new PHI nodes in block #32
Registering new PHI nodes in block #31
Registering new PHI nodes in block #33
Registering new PHI nodes in block #28
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #24
Registering new PHI nodes in block #3
Updating SSA information for statement _16 = ran_u[j_82];
Updating SSA information for statement *_15 = _16;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #23
Registering new PHI nodes in block #21
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #6
Registering new PHI nodes in block #37
Registering new PHI nodes in block #41
Registering new PHI nodes in block #47
Registering new PHI nodes in block #45
Registering new PHI nodes in block #50
Updating SSA information for statement _128 = *_125;
Updating SSA information for statement _124 = *_120;
Updating SSA information for statement *_111 = _116;
Registering new PHI nodes in block #48
Registering new PHI nodes in block #46
Registering new PHI nodes in block #49
Registering new PHI nodes in block #43
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #39
Registering new PHI nodes in block #7
Updating SSA information for statement _27 = *_26;
Updating SSA information for statement _31 = *_30;
Updating SSA information for statement *_22 = _37;
Registering new PHI nodes in block #8
Registering new PHI nodes in block #18
Registering new PHI nodes in block #38
Registering new PHI nodes in block #36
Registering new PHI nodes in block #35
Registering new PHI nodes in block #9
Registering new PHI nodes in block #53
Registering new PHI nodes in block #57
Registering new PHI nodes in block #61
Registering new PHI nodes in block #65
Updating SSA information for statement _99 = *_93;
Updating SSA information for statement _92 = *_77;
Updating SSA information for statement _76 = _92 + _99;
Updating SSA information for statement _75 = (int) _76;
Updating SSA information for statement _74 = (double) _75;
Updating SSA information for statement _72 = _76 - _74;
Updating SSA information for statement ran_u[_70] = _72;
Registering new PHI nodes in block #63
Registering new PHI nodes in block #62
Registering new PHI nodes in block #64
Registering new PHI nodes in block #59
Registering new PHI nodes in block #60
Registering new PHI nodes in block #58
Registering new PHI nodes in block #55
Registering new PHI nodes in block #10
Updating SSA information for statement _44 = *_43;
Updating SSA information for statement _47 = *_46;
Updating SSA information for statement _48 = _44 + _47;
Updating SSA information for statement _49 = (int) _48;
Updating SSA information for statement _50 = (double) _49;
Updating SSA information for statement _51 = _48 - _50;
Updating SSA information for statement ran_u[i_80] = _51;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #54
Registering new PHI nodes in block #52
Registering new PHI nodes in block #51
Registering new PHI nodes in block #17
Registering new PHI nodes in block #13
Updating SSA information for statement _59 = *_58;
Updating SSA information for statement _61 = ran_u[_60];
Updating SSA information for statement ran_u[i_81] = _65;
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16
Updating SSA information for statement return;

DFA Statistics for void ranf_array(double*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            162       1296b
DEF operands                             94        752b
VUSE operands                            20        160b
VDEF operands                             7         56b
PHI nodes                                26       2704b
PHI arguments                            50       2400b
---------------------------------------------------------
Total memory used by DFA/SSA data                 7368b
---------------------------------------------------------

Average number of arguments per PHI node: 1.9 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_71 -> { .MEM_52 }
_72 -> { _51 }
_74 -> { _50 }
_75 -> { _49 }
_76 -> { _48 }
_92 -> { _47 }
_99 -> { _44 }

Symbols to be put in SSA form
{ D.3846 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 66
Number of blocks to update: 62 ( 94%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 26 27 28 29 30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 57 58 59 60 61 62 63 64 65



1 loops carried no dependency.
Creating dr for *_58
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
success.
Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
	base_address: aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	offset from base address: 0
	constant offset from base address: -504(OVF)
	step: 8
	aligned to: 256
	base_object: *aa_14(D) + (sizetype) ((long unsigned int) j_1 * 8)
	Access function 0: {-504B, +, 8}_4
Creating dr for ran_u[_60]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for ran_u[i_81]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_4
Analyzing # of iterations of loop 4
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 62; c1 += 1)
  S_13(c1);


Removing basic block 71
basic block 71, loop depth 0
 pred:      
goto <bb 69>;
 succ:       69



Updating SSA:
Registering new PHI nodes in block #68
Registering new PHI nodes in block #70
Registering new PHI nodes in block #13
Updating SSA information for statement ran_u[i_81] = _65;
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #69
Registering new PHI nodes in block #67
Registering new PHI nodes in block #66
Registering new PHI nodes in block #16
Updating SSA information for statement return;

DFA Statistics for void ranf_array(double*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            162       1296b
DEF operands                             94        752b
VUSE operands                            20        160b
VDEF operands                             7         56b
PHI nodes                                27       2808b
PHI arguments                            52       2496b
---------------------------------------------------------
Total memory used by DFA/SSA data                 7568b
---------------------------------------------------------

Average number of arguments per PHI node: 1.9 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_8 -> { .MEM_66 }
Incremental SSA update started at block: 68
Number of blocks in CFG: 72
Number of blocks to update: 7 ( 10%)
Affected blocks: 13 14 15 16 68 69 70


Applying pattern match.pd:397, generic-match.c:4039
Applying pattern match.pd:725, generic-match.c:1428
gimple_simplified to _191 = _2 + _4;

Updating SSA:
creating PHI node in block #73 for .MEM
creating PHI node in block #76 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #22
Registering new PHI nodes in block #26
Registering new PHI nodes in block #30
Registering new PHI nodes in block #34
Updating SSA information for statement _154 = ran_u[_156];
Updating SSA information for statement *_174 = _154;
Registering new PHI nodes in block #32
Registering new PHI nodes in block #31
Registering new PHI nodes in block #33
Registering new PHI nodes in block #28
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #24
Registering new PHI nodes in block #3
Updating SSA information for statement _16 = ran_u[j_82];
Updating SSA information for statement *_15 = _16;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #23
Registering new PHI nodes in block #21
Registering new PHI nodes in block #20
Registering new PHI nodes in block #19
Registering new PHI nodes in block #6
Registering new PHI nodes in block #37
Registering new PHI nodes in block #41
Registering new PHI nodes in block #47
Registering new PHI nodes in block #45
Registering new PHI nodes in block #50
Updating SSA information for statement _128 = *_125;
Updating SSA information for statement _124 = *_120;
Updating SSA information for statement *_111 = _116;
Registering new PHI nodes in block #48
Registering new PHI nodes in block #46
Registering new PHI nodes in block #49
Registering new PHI nodes in block #43
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #39
Registering new PHI nodes in block #7
Updating SSA information for statement _27 = *_26;
Updating SSA information for statement _31 = *_30;
Updating SSA information for statement *_22 = _37;
Registering new PHI nodes in block #8
Registering new PHI nodes in block #18
Registering new PHI nodes in block #38
Registering new PHI nodes in block #36
Registering new PHI nodes in block #35
Registering new PHI nodes in block #9
Registering new PHI nodes in block #53
Registering new PHI nodes in block #57
Registering new PHI nodes in block #61
Registering new PHI nodes in block #65
Updating SSA information for statement _99 = *_93;
Updating SSA information for statement _92 = *_77;
Updating SSA information for statement ran_u[_70] = _72;
Registering new PHI nodes in block #63
Registering new PHI nodes in block #62
Registering new PHI nodes in block #64
Registering new PHI nodes in block #59
Registering new PHI nodes in block #60
Registering new PHI nodes in block #58
Registering new PHI nodes in block #55
Registering new PHI nodes in block #10
Updating SSA information for statement _44 = *_43;
Updating SSA information for statement _47 = *_46;
Updating SSA information for statement ran_u[i_80] = _51;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #54
Registering new PHI nodes in block #52
Registering new PHI nodes in block #51
Registering new PHI nodes in block #17
Registering new PHI nodes in block #68
Registering new PHI nodes in block #72
Registering new PHI nodes in block #76
Registering new PHI nodes in block #80
Updating SSA information for statement _5 = *_188;
Updating SSA information for statement _187 = ran_u[_186];
Updating SSA information for statement _185 = _5 + _187;
Updating SSA information for statement _184 = (int) _185;
Updating SSA information for statement _183 = (double) _184;
Updating SSA information for statement _182 = _185 - _183;
Updating SSA information for statement ran_u[_179] = _182;
Registering new PHI nodes in block #78
Registering new PHI nodes in block #77
Registering new PHI nodes in block #79
Registering new PHI nodes in block #74
Registering new PHI nodes in block #75
Registering new PHI nodes in block #73
Registering new PHI nodes in block #70
Registering new PHI nodes in block #13
Updating SSA information for statement _59 = *_58;
Updating SSA information for statement _61 = ran_u[_60];
Updating SSA information for statement _62 = _59 + _61;
Updating SSA information for statement _63 = (int) _62;
Updating SSA information for statement _64 = (double) _63;
Updating SSA information for statement _65 = _62 - _64;
Updating SSA information for statement ran_u[i_81] = _65;
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #69
Registering new PHI nodes in block #67
Registering new PHI nodes in block #66
Registering new PHI nodes in block #16
Updating SSA information for statement return;

DFA Statistics for void ranf_array(double*, int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            185       1480b
DEF operands                            110        880b
VUSE operands                            23        184b
VDEF operands                             8         64b
PHI nodes                                30       3120b
PHI arguments                            58       2784b
---------------------------------------------------------
Total memory used by DFA/SSA data                 8512b
---------------------------------------------------------

Average number of arguments per PHI node: 1.9 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

_5 -> { _59 }
.MEM_181 -> { .MEM_66 }
_182 -> { _65 }
_183 -> { _64 }
_184 -> { _63 }
_185 -> { _62 }
_187 -> { _61 }

Symbols to be put in SSA form
{ D.3846 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 81
Number of blocks to update: 76 ( 94%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 26 27 28 29 30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 57 58 59 60 61 62 63 64 65 66 67 68 69 70 72 73 74 75 76 77 78 79 80



1 loops carried no dependency.
Merging blocks 2 and 22
Removing basic block 5
basic block 5, loop depth 0
 pred:      
goto <bb 23>;
 succ:       23


Removing basic block 6
basic block 6, loop depth 0
 pred:      
 succ:       37


Merging blocks 9 and 53
Removing basic block 12
basic block 12, loop depth 0
 pred:      
goto <bb 54>;
 succ:       54


Removing basic block 15
basic block 15, loop depth 0
 pred:      
goto <bb 69>;
 succ:       69


Removing basic block 20
basic block 20, loop depth 0
 pred:      
 succ:       19


Removing basic block 21
basic block 21, loop depth 0
 pred:      
goto <bb 19>;
 succ:       19


Merging blocks 23 and 19
Removing basic block 24
basic block 24, loop depth 0
 pred:      
 succ:       23


Removing basic block 29
basic block 29, loop depth 0
 pred:       26
goto <bb 27>;
 succ:       27


Removing basic block 28
basic block 28, loop depth 0
 pred:      
 succ:       27


Merging blocks 30 and 34
Removing basic block 33
basic block 33, loop depth 0
 pred:      
 succ:       27


Removing basic block 35
basic block 35, loop depth 0
 pred:      
 succ:       9


Removing basic block 36
basic block 36, loop depth 0
 pred:      
goto <bb 9>;
 succ:       9


Removing basic block 8
basic block 8, loop depth 1
 pred:       7
goto <bb 7>;
 succ:       7


Removing basic block 18
basic block 18, loop depth 0
 pred:       7
# n_193 = PHI <n_19(D)(7)>
goto <bb 38>;
 succ:       38


Removing basic block 7
basic block 7, loop depth 1
 pred:       37
# j_78 = PHI <100(37)>
# DEBUG j => j_78
_20 = (long unsigned int) j_78;
_21 = _20 * 8;
_22 = aa_14(D) + _21;
_25 = _21 + 18446744073709550816;
_26 = aa_14(D) + _25;
_27 = *_26;
_29 = _21 + 18446744073709551320;
_30 = aa_14(D) + _29;
_31 = *_30;
_34 = _27 + _31;
_35 = (int) _34;
_36 = (double) _35;
_37 = _34 - _36;
*_22 = _37;
j_39 = j_78 + 1;
# DEBUG j => j_39
# DEBUG j => j_39
if (n_19(D) <= j_39)
 succ:      


Removing basic block 37
basic block 37, loop depth 0
 pred:      
 succ:       41


Removing basic block 39
basic block 39, loop depth 0
 pred:      
 succ:       38


Merging blocks 42 and 38
Removing basic block 43
basic block 43, loop depth 0
 pred:      
 succ:       42


Removing basic block 44
basic block 44, loop depth 0
 pred:      
goto <bb 42>;
 succ:       42


Merging blocks 45 and 50
Removing basic block 49
basic block 49, loop depth 0
 pred:      
 succ:       42


Removing basic block 51
basic block 51, loop depth 0
 pred:      
 succ:       17


Removing basic block 52
basic block 52, loop depth 0
 pred:      
goto <bb 17>;
 succ:       17


Merging blocks 54 and 17
Removing basic block 55
basic block 55, loop depth 0
 pred:      
 succ:       54


Removing basic block 60
basic block 60, loop depth 0
 pred:       57
goto <bb 58>;
 succ:       58


Removing basic block 59
basic block 59, loop depth 0
 pred:      
 succ:       58


Merging blocks 61 and 65
Removing basic block 64
basic block 64, loop depth 0
 pred:      
 succ:       58


Removing basic block 66
basic block 66, loop depth 0
 pred:      
 succ:       16


Removing basic block 67
basic block 67, loop depth 0
 pred:      
goto <bb 16>;
 succ:       16


Removing basic block 14
basic block 14, loop depth 1
 pred:       13
goto <bb 13>;
 succ:       13


Removing basic block 13
basic block 13, loop depth 1
 pred:       68
# i_81 = PHI <37(68)>
# j_84 = PHI <j_192(68)>
# DEBUG j => j_84
# DEBUG i => i_81
_55 = (long unsigned int) j_84;
_56 = _55 * 8;
_57 = _56 + 18446744073709550816;
_58 = aa_14(D) + _57;
_59 = *_58;
_60 = i_81 + -37;
_61 = ran_u[_60];
_62 = _59 + _61;
_63 = (int) _62;
_64 = (double) _63;
_65 = _62 - _64;
ran_u[i_81] = _65;
i_67 = i_81 + 1;
# DEBUG i => i_67
j_68 = j_84 + 1;
# DEBUG j => j_68
# DEBUG j => j_68
# DEBUG i => i_67
if (i_67 > 99)
 succ:       69


Removing basic block 68
basic block 68, loop depth 0
 pred:      
 succ:       72


Removing basic block 70
basic block 70, loop depth 0
 pred:      
 succ:       69


Removing basic block 75
basic block 75, loop depth 0
 pred:       72
goto <bb 73>;
 succ:       73


Removing basic block 74
basic block 74, loop depth 0
 pred:      
 succ:       73


Merging blocks 76 and 80
Removing basic block 79
basic block 79, loop depth 0
 pred:      
 succ:       73


Removing basic block 4
basic block 4, loop depth 1
 pred:       3
goto <bb 3>;
 succ:       3


Removing basic block 3
basic block 3, loop depth 1
 pred:       2
# j_82 = PHI <0(2)>
# DEBUG j => j_82
_12 = (long unsigned int) j_82;
_13 = _12 * 8;
_15 = aa_14(D) + _13;
_16 = ran_u[j_82];
*_15 = _16;
j_18 = j_82 + 1;
# DEBUG j => j_18
# DEBUG j => j_18
if (j_18 == 100)
 succ:       23


Merging blocks 2 and 26
Removing basic block 11
basic block 11, loop depth 1
 pred:       10
goto <bb 10>;
 succ:       10


Removing basic block 10
basic block 10, loop depth 1
 pred:       9
# i_80 = PHI <0(9)>
# j_83 = PHI <j_1(9)>
# DEBUG j => j_83
# DEBUG i => i_80
_40 = (long unsigned int) j_83;
_41 = _40 * 8;
_42 = _41 + 18446744073709550816;
_43 = aa_14(D) + _42;
_44 = *_43;
_45 = _41 + 18446744073709551320;
_46 = aa_14(D) + _45;
_47 = *_46;
_48 = _44 + _47;
_49 = (int) _48;
_50 = (double) _49;
_51 = _48 - _50;
ran_u[i_80] = _51;
i_53 = i_80 + 1;
# DEBUG i => i_53
j_54 = j_83 + 1;
# DEBUG j => j_54
# DEBUG j => j_54
# DEBUG i => i_53
if (i_53 == 37)
 succ:       54


Merging blocks 9 and 57
Merging blocks 27 and 23
Merging blocks 30 and 32
Merging blocks 45 and 48
Merging blocks 58 and 54
Merging blocks 58 and 72
Merging blocks 61 and 63
Merging blocks 73 and 69
Merging blocks 73 and 16
Merging blocks 76 and 78
fix_loop_structure: removing loop 4
fix_loop_structure: removing loop 3
fix_loop_structure: removing loop 2
fix_loop_structure: removing loop 1
Analyzing # of iterations of loop 8
  exit condition [0, + , 1](no_overflow) < 62
  bounds on difference of bases: 62 ... 62
  result:
    # of iterations 62, bounded by 62
Analyzing # of iterations of loop 7
  exit condition [0, + , 1](no_overflow) < 36
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Analyzing # of iterations of loop 6
  exit condition [0, + , 1](no_overflow) < (signed long) n_19(D) + -101
  bounds on difference of bases: -9223372036854775808 ... 9223372036854775706
Applying pattern match.pd:49, generic-match.c:4253
  result:
    zero if n_19(D) <= 100
    # of iterations (unsigned long) ((signed long) n_19(D) + -101), bounded by 9223372036854775706
Analyzing # of iterations of loop 6
  exit condition [0, + , 1](no_overflow) < (signed long) n_19(D) + -101
  bounds on difference of bases: -9223372036854775808 ... 9223372036854775706
Applying pattern match.pd:49, generic-match.c:4253
  result:
    zero if n_19(D) <= 100
    # of iterations (unsigned long) ((signed long) n_19(D) + -101), bounded by 9223372036854775706
Analyzing # of iterations of loop 6
  exit condition [0, + , 1](no_overflow) < (signed long) n_19(D) + -101
  bounds on difference of bases: -9223372036854775808 ... 9223372036854775706
Applying pattern match.pd:49, generic-match.c:4253
  result:
    zero if n_19(D) <= 100
    # of iterations (unsigned long) ((signed long) n_19(D) + -101), bounded by 9223372036854775706
Statement (exit)if (graphite_IV.139_130 < _131)
 is executed at most (unsigned long) ((signed long) n_19(D) + -101) (bounded by 9223372036854775706) + 1 times in loop 6.
Induction variable (double *) aa_14(D) + 8 * iteration does not wrap in statement _125 = aa_14(D) + _126;
 in loop 6.
Statement _125 = aa_14(D) + _126;
 is executed at most 2305843009213693950 (bounded by 2305843009213693950) + 1 times in loop 6.
Induction variable (double *) aa_14(D) + 504 + 8 * iteration does not wrap in statement _120 = aa_14(D) + _121;
 in loop 6.
Statement _120 = aa_14(D) + _121;
 is executed at most 2305843009213693950 (bounded by 2305843009213693950) + 1 times in loop 6.
Induction variable (double *) aa_14(D) + 800 + 8 * iteration does not wrap in statement _111 = aa_14(D) + _112;
 in loop 6.
Statement _111 = aa_14(D) + _112;
 is executed at most 2305843009213693950 (bounded by 2305843009213693950) + 1 times in loop 6.
Induction variable (signed long) 1 + 1 * iteration does not wrap in statement graphite_IV.139_129 = graphite_IV.139_130 + 1;
 in loop 6.
Statement graphite_IV.139_129 = graphite_IV.139_130 + 1;
 is executed at most 9223372036854775806 (bounded by 9223372036854775806) + 1 times in loop 6.
Reducing loop iteration estimate by 1; undefined statement must be executed at the last iteration.
Analyzing # of iterations of loop 5
  exit condition [0, + , 1](no_overflow) < 99
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
1 edges in bb 2 predicted to even probabilities
Predictions for bb 3
  DS theory heuristics (ignored): 99.0%
  first match heuristics: 99.0%
  combined heuristics: 99.0%
  loop iterations heuristics: 99.0%
1 edges in bb 4 predicted to even probabilities
Predictions for bb 5
  no prediction heuristics: 50.0%
  combined heuristics: 50.0%
Predictions for bb 6
  no prediction heuristics: 50.0%
  combined heuristics: 50.0%
1 edges in bb 7 predicted to even probabilities
Predictions for bb 8
  DS theory heuristics (ignored): 91.0%
  first match heuristics: 91.0%
  combined heuristics: 91.0%
  loop exit heuristics: 91.0%
1 edges in bb 9 predicted to even probabilities
1 edges in bb 10 predicted to even probabilities
1 edges in bb 11 predicted to even probabilities
Predictions for bb 12
  DS theory heuristics (ignored): 97.3%
  first match heuristics: 97.3%
  combined heuristics: 97.3%
  loop iterations heuristics: 97.3%
1 edges in bb 13 predicted to even probabilities
1 edges in bb 14 predicted to even probabilities
Predictions for bb 15
  DS theory heuristics (ignored): 99.0%
  first match heuristics: 98.4%
  combined heuristics: 98.4%
  early return (on trees) heuristics (ignored): 61.0%
  loop iterations heuristics: 98.4%
1 edges in bb 16 predicted to even probabilities
1 edges in bb 17 predicted to even probabilities
loop_0 (header = 0, latch = 1, niter = )
{
  bb_2 (preds = {bb_0 }, succs = {bb_3 })
  {
    <bb 2>:
    # DEBUG j => 0
    # DEBUG j => 0

  }
  bb_5 (preds = {bb_3 }, succs = {bb_11 bb_6 })
  {
    <bb 5>:
    # .MEM_173 = PHI <.MEM_158(3)>
    # DEBUG j => 100
    if (n_19(D) <= 100)
      goto <bb 11>;
    else
      goto <bb 6>;

  }
  bb_6 (preds = {bb_5 }, succs = {bb_7 bb_10 })
  {
    <bb 6>:
    _133 = n_19(D) > 100;
    if (_133 != 0)
      goto <bb 7>;
    else
      goto <bb 10>;

  }
  bb_7 (preds = {bb_6 }, succs = {bb_8 })
  {
    <bb 7>:
    _132 = (signed long) n_19(D);
    _131 = _132 + -101;

  }
  bb_10 (preds = {bb_8 bb_6 }, succs = {bb_11 })
  {
    <bb 10>:
    # .MEM_110 = PHI <.MEM_115(8), .MEM_173(6)>

  }
  bb_11 (preds = {bb_10 bb_5 }, succs = {bb_12 })
  {
    <bb 11>:
    # j_1 = PHI <n_19(D)(10), 100(5)>
    # .MEM_73 = PHI <.MEM_110(10), .MEM_173(5)>

  }
  bb_14 (preds = {bb_12 }, succs = {bb_15 })
  {
    <bb 14>:
    # .MEM_69 = PHI <.MEM_71(12)>
    j_192 = j_1 + 37;

  }
  bb_17 (preds = {bb_15 }, succs = {bb_1 })
  {
    <bb 17>:
    # .MEM_178 = PHI <.MEM_181(15)>
    # VUSE <.MEM_178>
    return;

  }
  loop_8 (header = 15, latch = 16, niter = )
  {
    bb_15 (preds = {bb_14 bb_16 }, succs = {bb_16 bb_17 })
    {
      <bb 15>:
      # graphite_IV.141_7 = PHI <0(14), graphite_IV.141_6(16)>
      # .MEM_177 = PHI <.MEM_69(14), .MEM_181(16)>
      # DEBUG j => NULL
      # DEBUG i => NULL
      _4 = (sizetype) j_192;
      _2 = (sizetype) graphite_IV.141_7;
      _191 = _2 + _4;
      _190 = _191 * 8;
      _189 = _190 + 18446744073709550816;
      _188 = aa_14(D) + _189;
      # VUSE <.MEM_177>
      _5 = *_188;
      _186 = (int) graphite_IV.141_7;
      # VUSE <.MEM_177>
      _187 = ran_u[_186];
      _185 = _5 + _187;
      _184 = (int) _185;
      _183 = (double) _184;
      _182 = _185 - _183;
      _180 = (int) graphite_IV.141_7;
      _179 = _180 + 37;
      # .MEM_181 = VDEF <.MEM_177>
      ran_u[_179] = _182;
      # DEBUG i => NULL
      # DEBUG j => NULL
      # DEBUG j => NULL
      # DEBUG i => NULL
      graphite_IV.141_6 = graphite_IV.141_7 + 1;
      if (graphite_IV.141_7 < 62)
        goto <bb 16>;
      else
        goto <bb 17>;

    }
    bb_16 (preds = {bb_15 }, succs = {bb_15 })
    {
      <bb 16>:
      goto <bb 15>;

    }
  }
  loop_7 (header = 12, latch = 13, niter = )
  {
    bb_12 (preds = {bb_11 bb_13 }, succs = {bb_13 bb_14 })
    {
      <bb 12>:
      # graphite_IV.140_101 = PHI <0(11), graphite_IV.140_100(13)>
      # .MEM_33 = PHI <.MEM_73(11), .MEM_71(13)>
      # DEBUG j => NULL
      # DEBUG i => NULL
      _98 = (sizetype) j_1;
      _97 = (sizetype) graphite_IV.140_101;
      _96 = _97 + _98;
      _95 = _96 * 8;
      _94 = _95 + 18446744073709550816;
      _93 = aa_14(D) + _94;
      # VUSE <.MEM_33>
      _99 = *_93;
      _91 = (sizetype) j_1;
      _90 = (sizetype) graphite_IV.140_101;
      _89 = _90 + _91;
      _88 = _89 * 8;
      _79 = _88 + 18446744073709551320;
      _77 = aa_14(D) + _79;
      # VUSE <.MEM_33>
      _92 = *_77;
      _76 = _92 + _99;
      _75 = (int) _76;
      _74 = (double) _75;
      _72 = _76 - _74;
      _70 = (int) graphite_IV.140_101;
      # .MEM_71 = VDEF <.MEM_33>
      ran_u[_70] = _72;
      # DEBUG i => NULL
      # DEBUG j => NULL
      # DEBUG j => NULL
      # DEBUG i => NULL
      graphite_IV.140_100 = graphite_IV.140_101 + 1;
      if (graphite_IV.140_101 < 36)
        goto <bb 13>;
      else
        goto <bb 14>;

    }
    bb_13 (preds = {bb_12 }, succs = {bb_12 })
    {
      <bb 13>:
      goto <bb 12>;

    }
  }
  loop_6 (header = 8, latch = 9, niter = (unsigned long) ((signed long) n_19(D) + -101), upper_bound = 2305843009213693950)
  {
    bb_8 (preds = {bb_7 bb_9 }, succs = {bb_9 bb_10 })
    {
      <bb 8>:
      # graphite_IV.139_130 = PHI <0(7), graphite_IV.139_129(9)>
      # .MEM_109 = PHI <.MEM_173(7), .MEM_115(9)>
      # DEBUG j => NULL
      _127 = (sizetype) graphite_IV.139_130;
      _126 = _127 * 8;
      _125 = aa_14(D) + _126;
      # VUSE <.MEM_109>
      _128 = *_125;
      _123 = (sizetype) graphite_IV.139_130;
      _122 = _123 + 63;
      _121 = _122 * 8;
      _120 = aa_14(D) + _121;
      # VUSE <.MEM_109>
      _124 = *_120;
      _119 = _124 + _128;
      _118 = (int) _119;
      _117 = (double) _118;
      _116 = _119 - _117;
      _114 = (sizetype) graphite_IV.139_130;
      _113 = _114 + 100;
      _112 = _113 * 8;
      _111 = aa_14(D) + _112;
      # .MEM_115 = VDEF <.MEM_109>
      *_111 = _116;
      # DEBUG j => NULL
      # DEBUG j => NULL
      graphite_IV.139_129 = graphite_IV.139_130 + 1;
      if (graphite_IV.139_130 < _131)
        goto <bb 9>;
      else
        goto <bb 10>;

    }
    bb_9 (preds = {bb_8 }, succs = {bb_8 })
    {
      <bb 9>:
      goto <bb 8>;

    }
  }
  loop_5 (header = 3, latch = 4, niter = )
  {
    bb_3 (preds = {bb_2 bb_4 }, succs = {bb_4 bb_5 })
    {
      <bb 3>:
      # graphite_IV.138_150 = PHI <0(2), graphite_IV.138_152(4)>
      # .MEM_172 = PHI <.MEM_11(D)(2), .MEM_158(4)>
      # DEBUG j => NULL
      _156 = (int) graphite_IV.138_150;
      # VUSE <.MEM_172>
      _154 = ran_u[_156];
      _160 = (sizetype) graphite_IV.138_150;
      _175 = _160 * 8;
      _174 = aa_14(D) + _175;
      # .MEM_158 = VDEF <.MEM_172>
      *_174 = _154;
      # DEBUG j => NULL
      # DEBUG j => NULL
      graphite_IV.138_152 = graphite_IV.138_150 + 1;
      if (graphite_IV.138_150 < 99)
        goto <bb 4>;
      else
        goto <bb 5>;

    }
    bb_4 (preds = {bb_3 }, succs = {bb_3 })
    {
      <bb 4>:
      goto <bb 3>;

    }
  }
}

Pass statistics:
----------------

void ranf_array(double*, int) (doubleD.39 * aaD.2901, intD.9 nD.2902)
{
  signed long graphite_IV.141D.4061;
  doubleD.39 D.4060;
  doubleD.39 D.4059;
  intD.9 D.4058;
  doubleD.39 D.4057;
  doubleD.39 D.4056;
  doubleD.39 D.4055;
  signed long graphite_IV.140D.4054;
  doubleD.39 D.4053;
  doubleD.39 D.4052;
  intD.9 D.4051;
  doubleD.39 D.4050;
  doubleD.39 D.4049;
  doubleD.39 D.4048;
  signed long graphite_IV.139D.4047;
  doubleD.39 D.4046;
  doubleD.39 D.4045;
  intD.9 D.4044;
  doubleD.39 D.4043;
  doubleD.39 D.4042;
  doubleD.39 D.4041;
  signed long graphite_IV.138D.4040;
  doubleD.39 D.4039;
  register intD.9 jD.2906;
  register intD.9 iD.2905;
  sizetype _2;
  sizetype _4;
  doubleD.39 _5;
  intD.9 _70;
  doubleD.39 _72;
  doubleD.39 _74;
  intD.9 _75;
  doubleD.39 _76;
  doubleD.39 * _77;
  sizetype _79;
  sizetype _88;
  sizetype _89;
  sizetype _90;
  sizetype _91;
  doubleD.39 _92;
  doubleD.39 * _93;
  sizetype _94;
  sizetype _95;
  sizetype _96;
  sizetype _97;
  sizetype _98;
  doubleD.39 _99;
  doubleD.39 * _111;
  sizetype _112;
  sizetype _113;
  sizetype _114;
  doubleD.39 _116;
  doubleD.39 _117;
  intD.9 _118;
  doubleD.39 _119;
  doubleD.39 * _120;
  sizetype _121;
  sizetype _122;
  sizetype _123;
  doubleD.39 _124;
  doubleD.39 * _125;
  sizetype _126;
  sizetype _127;
  doubleD.39 _128;
  signed long _131;
  signed long _132;
  boolD.2757 _133;
  doubleD.39 _154;
  intD.9 _156;
  sizetype _160;
  doubleD.39 * _174;
  sizetype _175;
  intD.9 _179;
  intD.9 _180;
  doubleD.39 _182;
  doubleD.39 _183;
  intD.9 _184;
  doubleD.39 _185;
  intD.9 _186;
  doubleD.39 _187;
  doubleD.39 * _188;
  sizetype _189;
  sizetype _190;
  sizetype _191;

;;   basic block 2, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY [100.0%]  (FALLTHRU,EXECUTABLE)
  # DEBUG jD.2906 => 0
  # DEBUG jD.2906 => 0
;;    succ:       3 [100.0%]  (FALLTHRU)

;;   basic block 3, loop depth 1, count 0, freq 10000, maybe hot
;;    prev block 2, next block 4, flags: (NEW)
;;    pred:       2 [100.0%]  (FALLTHRU)
;;                4 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.138_150 = PHI <0(2), graphite_IV.138_152(4)>
  # .MEM_172 = PHI <.MEM_11(D)(2), .MEM_158(4)>
  # DEBUG jD.2906 => NULL
  _156 = (intD.9) graphite_IV.138_150;
  # VUSE <.MEM_172>
  _154 = ran_uD.2900[_156];
  _160 = (sizetype) graphite_IV.138_150;
  _175 = _160 * 8;
  _174 = aa_14(D) + _175;
  # .MEM_158 = VDEF <.MEM_172>
  *_174 = _154;
  # DEBUG jD.2906 => NULL
  # DEBUG jD.2906 => NULL
  graphite_IV.138_152 = graphite_IV.138_150 + 1;
  if (graphite_IV.138_150 < 99)
    goto <bb 4>;
  else
    goto <bb 5>;
;;    succ:       4 [99.0%]  (TRUE_VALUE)
;;                5 [1.0%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 4, loop depth 1, count 0, freq 9900, maybe hot
;;    prev block 3, next block 5, flags: (NEW)
;;    pred:       3 [99.0%]  (TRUE_VALUE)
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 5, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 4, next block 6, flags: (NEW)
;;    pred:       3 [1.0%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_173 = PHI <.MEM_158(3)>
  # DEBUG jD.2906 => 100
  if (n_19(D) <= 100)
    goto <bb 11>;
  else
    goto <bb 6>;
;;    succ:       11 [50.0%]  (TRUE_VALUE,EXECUTABLE)
;;                6 [50.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 6, loop depth 0, count 0, freq 50, maybe hot
;;    prev block 5, next block 7, flags: (NEW)
;;    pred:       5 [50.0%]  (FALSE_VALUE,EXECUTABLE)
  _133 = n_19(D) > 100;
  if (_133 != 0)
    goto <bb 7>;
  else
    goto <bb 10>;
;;    succ:       7 [50.0%]  (TRUE_VALUE)
;;                10 [50.0%]  (FALSE_VALUE)

;;   basic block 7, loop depth 0, count 0, freq 25, maybe hot
;;    prev block 6, next block 8, flags: (NEW)
;;    pred:       6 [50.0%]  (TRUE_VALUE)
  _132 = (signed long) n_19(D);
  _131 = _132 + -101;
;;    succ:       8 [100.0%]  (FALLTHRU)

;;   basic block 8, loop depth 1, count 0, freq 278, maybe hot
;;    prev block 7, next block 9, flags: (NEW)
;;    pred:       7 [100.0%]  (FALLTHRU)
;;                9 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.139_130 = PHI <0(7), graphite_IV.139_129(9)>
  # .MEM_109 = PHI <.MEM_173(7), .MEM_115(9)>
  # DEBUG jD.2906 => NULL
  _127 = (sizetype) graphite_IV.139_130;
  _126 = _127 * 8;
  _125 = aa_14(D) + _126;
  # VUSE <.MEM_109>
  _128 = *_125;
  _123 = (sizetype) graphite_IV.139_130;
  _122 = _123 + 63;
  _121 = _122 * 8;
  _120 = aa_14(D) + _121;
  # VUSE <.MEM_109>
  _124 = *_120;
  _119 = _124 + _128;
  _118 = (intD.9) _119;
  _117 = (doubleD.39) _118;
  _116 = _119 - _117;
  _114 = (sizetype) graphite_IV.139_130;
  _113 = _114 + 100;
  _112 = _113 * 8;
  _111 = aa_14(D) + _112;
  # .MEM_115 = VDEF <.MEM_109>
  *_111 = _116;
  # DEBUG jD.2906 => NULL
  # DEBUG jD.2906 => NULL
  graphite_IV.139_129 = graphite_IV.139_130 + 1;
  if (graphite_IV.139_130 < _131)
    goto <bb 9>;
  else
    goto <bb 10>;
;;    succ:       9 [91.0%]  (TRUE_VALUE)
;;                10 [9.0%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 9, loop depth 1, count 0, freq 253, maybe hot
;;    prev block 8, next block 10, flags: (NEW)
;;    pred:       8 [91.0%]  (TRUE_VALUE)
  goto <bb 8>;
;;    succ:       8 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 10, loop depth 0, count 0, freq 50, maybe hot
;;    prev block 9, next block 11, flags: (NEW)
;;    pred:       8 [9.0%]  (FALSE_VALUE,LOOP_EXIT)
;;                6 [50.0%]  (FALSE_VALUE)
  # .MEM_110 = PHI <.MEM_115(8), .MEM_173(6)>
;;    succ:       11 [100.0%]  (FALLTHRU)

;;   basic block 11, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 10, next block 12, flags: (NEW, REACHABLE)
;;    pred:       10 [100.0%]  (FALLTHRU)
;;                5 [50.0%]  (TRUE_VALUE,EXECUTABLE)
  # j_1 = PHI <n_19(D)(10), 100(5)>
  # .MEM_73 = PHI <.MEM_110(10), .MEM_173(5)>
;;    succ:       12 [100.0%]  (FALLTHRU)

;;   basic block 12, loop depth 1, count 0, freq 3704, maybe hot
;;    prev block 11, next block 13, flags: (NEW)
;;    pred:       11 [100.0%]  (FALLTHRU)
;;                13 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.140_101 = PHI <0(11), graphite_IV.140_100(13)>
  # .MEM_33 = PHI <.MEM_73(11), .MEM_71(13)>
  # DEBUG jD.2906 => NULL
  # DEBUG iD.2905 => NULL
  _98 = (sizetype) j_1;
  _97 = (sizetype) graphite_IV.140_101;
  _96 = _97 + _98;
  _95 = _96 * 8;
  _94 = _95 + 18446744073709550816;
  _93 = aa_14(D) + _94;
  # VUSE <.MEM_33>
  _99 = *_93;
  _91 = (sizetype) j_1;
  _90 = (sizetype) graphite_IV.140_101;
  _89 = _90 + _91;
  _88 = _89 * 8;
  _79 = _88 + 18446744073709551320;
  _77 = aa_14(D) + _79;
  # VUSE <.MEM_33>
  _92 = *_77;
  _76 = _92 + _99;
  _75 = (intD.9) _76;
  _74 = (doubleD.39) _75;
  _72 = _76 - _74;
  _70 = (intD.9) graphite_IV.140_101;
  # .MEM_71 = VDEF <.MEM_33>
  ran_uD.2900[_70] = _72;
  # DEBUG iD.2905 => NULL
  # DEBUG jD.2906 => NULL
  # DEBUG jD.2906 => NULL
  # DEBUG iD.2905 => NULL
  graphite_IV.140_100 = graphite_IV.140_101 + 1;
  if (graphite_IV.140_101 < 36)
    goto <bb 13>;
  else
    goto <bb 14>;
;;    succ:       13 [97.3%]  (TRUE_VALUE)
;;                14 [2.7%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 13, loop depth 1, count 0, freq 3604, maybe hot
;;    prev block 12, next block 14, flags: (NEW)
;;    pred:       12 [97.3%]  (TRUE_VALUE)
  goto <bb 12>;
;;    succ:       12 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 14, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 13, next block 15, flags: (NEW)
;;    pred:       12 [2.7%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_69 = PHI <.MEM_71(12)>
  j_192 = j_1 + 37;
;;    succ:       15 [100.0%]  (FALLTHRU)

;;   basic block 15, loop depth 1, count 0, freq 6289, maybe hot
;;    prev block 14, next block 16, flags: (NEW)
;;    pred:       14 [100.0%]  (FALLTHRU)
;;                16 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.141_7 = PHI <0(14), graphite_IV.141_6(16)>
  # .MEM_177 = PHI <.MEM_69(14), .MEM_181(16)>
  # DEBUG jD.2906 => NULL
  # DEBUG iD.2905 => NULL
  _4 = (sizetype) j_192;
  _2 = (sizetype) graphite_IV.141_7;
  _191 = _2 + _4;
  _190 = _191 * 8;
  _189 = _190 + 18446744073709550816;
  _188 = aa_14(D) + _189;
  # VUSE <.MEM_177>
  _5 = *_188;
  _186 = (intD.9) graphite_IV.141_7;
  # VUSE <.MEM_177>
  _187 = ran_uD.2900[_186];
  _185 = _5 + _187;
  _184 = (intD.9) _185;
  _183 = (doubleD.39) _184;
  _182 = _185 - _183;
  _180 = (intD.9) graphite_IV.141_7;
  _179 = _180 + 37;
  # .MEM_181 = VDEF <.MEM_177>
  ran_uD.2900[_179] = _182;
  # DEBUG iD.2905 => NULL
  # DEBUG jD.2906 => NULL
  # DEBUG jD.2906 => NULL
  # DEBUG iD.2905 => NULL
  graphite_IV.141_6 = graphite_IV.141_7 + 1;
  if (graphite_IV.141_7 < 62)
    goto <bb 16>;
  else
    goto <bb 17>;
;;    succ:       16 [98.4%]  (TRUE_VALUE)
;;                17 [1.6%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 16, loop depth 1, count 0, freq 6189, maybe hot
;;    prev block 15, next block 17, flags: (NEW)
;;    pred:       15 [98.4%]  (TRUE_VALUE)
  goto <bb 15>;
;;    succ:       15 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 17, loop depth 0, count 0, freq 100, maybe hot
;;    prev block 16, next block 1, flags: (NEW)
;;    pred:       15 [1.6%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_178 = PHI <.MEM_181(15)>
  # VUSE <.MEM_178>
  return;
;;    succ:       EXIT [100.0%] 

}



;; Function void ranf_start(long int) (_Z10ranf_startl, funcdef_no=1, decl_uid=2920, cgraph_uid=1, symbol_order=6)


Pass statistics:
----------------

void ranf_start(long int) (long intD.12 seedD.2919)
{
  doubleD.39 ssD.2927;
  doubleD.39 uD.2925[199];
  register intD.9 jD.2924;
  register intD.9 sD.2923;
  register intD.9 tD.2922;
  long intD.12 _23;
  long intD.12 _24;
  doubleD.39 _25;
  doubleD.39 _33;
  doubleD.39 _34;
  intD.9 _36;
  intD.9 _38;
  doubleD.39 _39;
  intD.9 _42;
  intD.9 _45;
  doubleD.39 _46;
  doubleD.39 _47;
  doubleD.39 _50;
  intD.9 _51;
  doubleD.39 _52;
  doubleD.39 _53;
  intD.9 _55;
  doubleD.39 _56;
  doubleD.39 _57;
  doubleD.39 _59;
  intD.9 _60;
  doubleD.39 _61;
  doubleD.39 _62;
  intD.9 _65;
  doubleD.39 _70;
  doubleD.39 _72;
  doubleD.39 _74;
  intD.9 _75;
  doubleD.39 _76;
  doubleD.39 _77;
  doubleD.39[199] * _116;
  doubleD.39[100] * _131;
  doubleD.39[199] * _133;

;;   basic block 2, loop depth 0, count 0, freq 10, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY [100.0%]  (FALLTHRU,EXECUTABLE)
  # DEBUG ulpD.2926 => 2.220446049250313080847263336181640625e-16
  # RANGE [0, 1073741823] NONZERO 1073741823
  _23 = seed_22(D) & 1073741823;
  # RANGE [2, 1073741825] NONZERO 2147483647
  _24 = _23 + 2;
  _25 = (doubleD.39) _24;
  ss_26 = _25 * 4.44089209850062616169452667236328125e-16;
  # DEBUG ssD.2927 => ss_26
  # DEBUG jD.2924 => 0
  # DEBUG ssD.2927 => ss_26
  # DEBUG jD.2924 => 0
;;    succ:       3 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 3, loop depth 1, count 0, freq 979, maybe hot
;;    prev block 2, next block 4, flags: (NEW, REACHABLE)
;;    pred:       6 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                2 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 100] NONZERO 127
  # j_119 = PHI <j_32(6), 0(2)>
  # ss_126 = PHI <ss_11(6), ss_26(2)>
  # .MEM_127 = PHI <.MEM_29(6), .MEM_28(D)(2)>
  # DEBUG ssD.2927 => ss_126
  # DEBUG jD.2924 => j_119
  # .MEM_29 = VDEF <.MEM_127>
  uD.2925[j_119] = ss_126;
  ss_30 = ss_126 * 2.0e+0;
  # DEBUG ssD.2927 => ss_30
  if (ss_30 >= 1.0e+0)
    goto <bb 4>;
  else
    goto <bb 5>;
;;    succ:       4 [73.0%]  (TRUE_VALUE,EXECUTABLE)
;;                5 [27.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 4, loop depth 1, count 0, freq 715, maybe hot
;;    prev block 3, next block 5, flags: (NEW, REACHABLE)
;;    pred:       3 [73.0%]  (TRUE_VALUE,EXECUTABLE)
  ss_31 = ss_30 - 9.99999999999999555910790149937383830547332763671875e-1;
  # DEBUG ssD.2927 => ss_31
;;    succ:       5 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 5, loop depth 1, count 0, freq 979, maybe hot
;;    prev block 4, next block 6, flags: (NEW, REACHABLE)
;;    pred:       3 [27.0%]  (FALSE_VALUE,EXECUTABLE)
;;                4 [100.0%]  (FALLTHRU,EXECUTABLE)
  # ss_11 = PHI <ss_30(3), ss_31(4)>
  # DEBUG ssD.2927 => ss_11
  # RANGE [1, 100] NONZERO 127
  j_32 = j_119 + 1;
  # DEBUG jD.2924 => j_32
  # DEBUG ssD.2927 => ss_11
  # DEBUG jD.2924 => j_32
  if (j_32 == 100)
    goto <bb 7>;
  else
    goto <bb 6>;
;;    succ:       7 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                6 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 6, loop depth 1, count 0, freq 969, maybe hot
;;    prev block 5, next block 7, flags: (NEW)
;;    pred:       5 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 7, loop depth 0, count 0, freq 10, maybe hot
;;    prev block 6, next block 8, flags: (NEW, REACHABLE)
;;    pred:       5 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # VUSE <.MEM_29>
  _33 = uD.2925[1];
  _34 = _33 + 2.220446049250313080847263336181640625e-16;
  # .MEM_35 = VDEF <.MEM_29>
  uD.2925[1] = _34;
  _36 = (intD.9) seed_22(D);
  # RANGE [0, 1073741823] NONZERO 1073741823
  s_37 = _36 & 1073741823;
  # DEBUG sD.2923 => s_37
  # DEBUG tD.2922 => 69
  # DEBUG sD.2923 => s_37
  # DEBUG tD.2922 => 69
  goto <bb 10>;
;;    succ:       10 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 8, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 7, next block 9, flags: (NEW, REACHABLE)
;;    pred:       23 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                22 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [-2147483648, 69]
  # t_48 = PHI <t_79(23), t_99(22)>
  # RANGE [0, 536870911] NONZERO 536870911
  # s_41 = PHI <0(23), s_80(22)>
  # .MEM_98 = PHI <.MEM_63(23), .MEM_132(22)>
  # DEBUG sD.2923 => s_41
  # DEBUG tD.2922 => t_48
  if (t_48 == 0)
    goto <bb 24>;
  else
    goto <bb 9>;
;;    succ:       24 [9.9%]  (TRUE_VALUE,EXECUTABLE)
;;                9 [90.1%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 9, loop depth 1, count 0, freq 90, maybe hot
;;    prev block 8, next block 10, flags: (NEW)
;;    pred:       8 [90.1%]  (FALSE_VALUE,EXECUTABLE)
;;    succ:       10 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 10, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 9, next block 11, flags: (NEW, REACHABLE)
;;    pred:       9 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                7 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [-2147483648, 69]
  # t_99 = PHI <t_48(9), 69(7)>
  # RANGE [0, 1073741823] NONZERO 1073741823
  # s_58 = PHI <s_41(9), s_37(7)>
  # .MEM_128 = PHI <.MEM_98(9), .MEM_35(7)>
  # DEBUG sD.2923 => s_58
  # DEBUG tD.2922 => t_99
  # DEBUG jD.2924 => 99
;;    succ:       11 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 11, loop depth 2, count 0, freq 9900, maybe hot
;;    prev block 10, next block 12, flags: (NEW, REACHABLE)
;;    pred:       12 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                10 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 99] NONZERO 127
  # j_120 = PHI <j_44(12), 99(10)>
  # .MEM_129 = PHI <.MEM_43(12), .MEM_128(10)>
  # DEBUG jD.2924 => j_120
  # RANGE [2, 198] NONZERO 255
  _38 = j_120 + j_120;
  # VUSE <.MEM_129>
  _39 = uD.2925[j_120];
  # .MEM_40 = VDEF <.MEM_129>
  uD.2925[_38] = _39;
  # RANGE [1, 197] NONZERO 255
  _42 = _38 + -1;
  # .MEM_43 = VDEF <.MEM_40>
  uD.2925[_42] = 0.0;
  # RANGE [0, 98] NONZERO 127
  j_44 = j_120 + -1;
  # DEBUG jD.2924 => j_44
  # DEBUG jD.2924 => j_44
  if (j_44 == 0)
    goto <bb 13>;
  else
    goto <bb 12>;
;;    succ:       13 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                12 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 12, loop depth 2, count 0, freq 9800, maybe hot
;;    prev block 11, next block 13, flags: (NEW)
;;    pred:       11 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 11>;
;;    succ:       11 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 13, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 12, next block 14, flags: (NEW)
;;    pred:       11 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;    succ:       14 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 14, loop depth 2, count 0, freq 9900, maybe hot
;;    prev block 13, next block 15, flags: (NEW, REACHABLE)
;;    pred:       13 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                15 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [99, 198] NONZERO 255
  # j_121 = PHI <198(13), j_64(15)>
  # .MEM_130 = PHI <.MEM_43(13), .MEM_63(15)>
  # DEBUG jD.2924 => j_121
  # RANGE [37, 135] NONZERO 255
  _45 = j_121 + -63;
  # VUSE <.MEM_130>
  _46 = uD.2925[_45];
  # VUSE <.MEM_130>
  _47 = uD.2925[j_121];
  _50 = _46 + _47;
  _51 = (intD.9) _50;
  _52 = (doubleD.39) _51;
  _53 = _50 - _52;
  # .MEM_54 = VDEF <.MEM_130>
  uD.2925[_45] = _53;
  # RANGE [0, 98] NONZERO 127
  _55 = j_121 + -100;
  # VUSE <.MEM_54>
  _56 = uD.2925[_55];
  # VUSE <.MEM_54>
  _57 = uD.2925[j_121];
  _59 = _56 + _57;
  _60 = (intD.9) _59;
  _61 = (doubleD.39) _60;
  _62 = _59 - _61;
  # .MEM_63 = VDEF <.MEM_54>
  uD.2925[_55] = _62;
  # RANGE [99, 197] NONZERO 255
  j_64 = j_121 + -1;
  # DEBUG jD.2924 => j_64
  # DEBUG jD.2924 => j_64
  if (j_64 == 99)
    goto <bb 16>;
  else
    goto <bb 15>;
;;    succ:       16 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                15 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 15, loop depth 2, count 0, freq 9800, maybe hot
;;    prev block 14, next block 16, flags: (NEW)
;;    pred:       14 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 14>;
;;    succ:       14 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 16, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 15, next block 17, flags: (NEW, REACHABLE)
;;    pred:       14 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # RANGE [0, 1] NONZERO 1
  _65 = s_58 & 1;
  if (_65 != 0)
    goto <bb 17>;
  else
    goto <bb 21>;
;;    succ:       17 [50.0%]  (TRUE_VALUE,EXECUTABLE)
;;                21 [50.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 17, loop depth 1, count 0, freq 50, maybe hot
;;   Invalid sum of outgoing probabilities 1.0%
;;    prev block 16, next block 20, flags: (NEW)
;;    pred:       16 [50.0%]  (TRUE_VALUE,EXECUTABLE)
  _116 = &uD.2925 + 8;
  # .MEM_134 = VDEF <.MEM_63>
  # USE = anything 
  # CLB = anything 
  memmoveD.995 (_116, &uD.2925, 800);
;;    succ:       20 [1.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 20, loop depth 1, count 0, freq 50, maybe hot
;;    prev block 17, next block 21, flags: (NEW, REACHABLE)
;;    pred:       17 [1.0%]  (FALLTHRU,EXECUTABLE)
  # VUSE <.MEM_134>
  _70 = uD.2925[100];
  # .MEM_71 = VDEF <.MEM_134>
  uD.2925[0] = _70;
  # VUSE <.MEM_71>
  _72 = uD.2925[37];
  _74 = _70 + _72;
  _75 = (intD.9) _74;
  _76 = (doubleD.39) _75;
  _77 = _74 - _76;
  # .MEM_78 = VDEF <.MEM_71>
  uD.2925[37] = _77;
  goto <bb 22>;
;;    succ:       22 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 21, loop depth 1, count 0, freq 50, maybe hot
;;    prev block 20, next block 22, flags: (NEW, REACHABLE)
;;    pred:       16 [50.0%]  (FALSE_VALUE,EXECUTABLE)
  if (s_58 != 0)
    goto <bb 22>;
  else
    goto <bb 23>;
;;    succ:       22 (TRUE_VALUE,EXECUTABLE)
;;                23 [100.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 22, loop depth 1, count 0, freq 50, maybe hot
;;    prev block 21, next block 23, flags: (NEW, REACHABLE)
;;    pred:       21 (TRUE_VALUE,EXECUTABLE)
;;                20 [100.0%]  (FALLTHRU,EXECUTABLE)
  # .MEM_132 = PHI <.MEM_63(21), .MEM_78(20)>
  # RANGE [0, 536870911] NONZERO 536870911
  s_80 = s_58 >> 1;
  # DEBUG sD.2923 => s_80
  goto <bb 8>;
;;    succ:       8 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 23, loop depth 1, count 0, freq 50, maybe hot
;;    prev block 22, next block 24, flags: (NEW, REACHABLE)
;;    pred:       21 [100.0%]  (FALSE_VALUE,EXECUTABLE)
  # RANGE [-2147483648, 68]
  t_79 = t_99 + -1;
  # DEBUG tD.2922 => t_79
  goto <bb 8>;
;;    succ:       8 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 24, loop depth 0, count 0, freq 10, maybe hot
;;   Invalid sum of outgoing probabilities 2.7%
;;    prev block 23, next block 27, flags: (NEW)
;;    pred:       8 [9.9%]  (TRUE_VALUE,EXECUTABLE)
  _131 = &ran_uD.2900 + 504;
  # .MEM_124 = VDEF <.MEM_98>
  # USE = anything 
  # CLB = anything 
  memcpyD.992 (_131, &uD.2925, 296);
;;    succ:       27 [2.7%]  (FALLTHRU,EXECUTABLE)

;;   basic block 27, loop depth 0, count 0, freq 10, maybe hot
;;   Invalid sum of outgoing probabilities 1.0%
;;    prev block 24, next block 30, flags: (NEW)
;;    pred:       24 [2.7%]  (FALLTHRU,EXECUTABLE)
  _133 = &uD.2925 + 296;
  # .MEM_85 = VDEF <.MEM_124>
  # USE = anything 
  # CLB = anything 
  memcpyD.992 (&ran_uD.2900, _133, 504);
;;    succ:       30 [1.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 30, loop depth 0, count 0, freq 10, maybe hot
;;    prev block 27, next block 31, flags: (NEW)
;;    pred:       27 [1.0%]  (FALLTHRU,EXECUTABLE)
;;    succ:       31 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 31, loop depth 1, count 0, freq 99, maybe hot
;;    prev block 30, next block 32, flags: (NEW, REACHABLE)
;;    pred:       30 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                32 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [0, 10] NONZERO 15
  # j_125 = PHI <0(30), j_90(32)>
  # .MEM_135 = PHI <.MEM_85(30), .MEM_89(32)>
  # DEBUG jD.2924 => j_125
  # .MEM_89 = VDEF <.MEM_135>
  # USE = nonlocal { D.2917 D.2925 } (nonlocal, escaped)
  # CLB = nonlocal { D.2917 D.2925 } (nonlocal, escaped)
  _Z10ranf_arrayPdiD.2903 (&uD.2925, 199);
  # RANGE [1, 10] NONZERO 15
  j_90 = j_125 + 1;
  # DEBUG jD.2924 => j_90
  # DEBUG jD.2924 => j_90
  if (j_90 == 10)
    goto <bb 33>;
  else
    goto <bb 32>;
;;    succ:       33 [10.0%]  (TRUE_VALUE,EXECUTABLE)
;;                32 [90.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 32, loop depth 1, count 0, freq 89, maybe hot
;;    prev block 31, next block 33, flags: (NEW)
;;    pred:       31 [90.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 31>;
;;    succ:       31 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 33, loop depth 0, count 0, freq 10, maybe hot
;;    prev block 32, next block 1, flags: (NEW, REACHABLE)
;;    pred:       31 [10.0%]  (TRUE_VALUE,EXECUTABLE)
  # .MEM_91 = VDEF <.MEM_89>
  ranf_arr_ptrD.2918 = &ranf_arr_startedD.2917;
  # .MEM_92 = VDEF <.MEM_91>
  uD.2925 ={v} {CLOBBER};
  # VUSE <.MEM_92>
  return;
;;    succ:       EXIT [100.0%] 

}


Creating dr for u[j_119]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: u
	Access function 0: {0, +, 1}_1
Creating dr for u[j_119]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: u
	Access function 0: {0, +, 1}_1
Creating dr for u[j_119]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: u
	Access function 0: {0, +, 1}_1
Creating dr for u[j_119]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: u
	Access function 0: {0, +, 1}_1
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 100
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 100
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
Creating dr for u[j_119]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: u
	Access function 0: {0, +, 1}_1
Creating dr for u[j_119]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: u
	Access function 0: {0, +, 1}_1
Creating dr for u[j_119]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: u
	Access function 0: {0, +, 1}_1
Creating dr for u[j_119]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: u
	Access function 0: {0, +, 1}_1
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 100
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
Creating dr for u[1]
analyze_innermost: success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 8
	step: 0
	aligned to: 256
	base_object: u
	Access function 0: 1
Creating dr for u[1]
analyze_innermost: success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 8
	step: 0
	aligned to: 256
	base_object: u
	Access function 0: 1
Creating dr for u[j_120]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {99, +, -1}_3
Creating dr for u[j_120]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {99, +, -1}_3
Creating dr for u[j_120]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {99, +, -1}_3
Creating dr for u[_38]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -2}_3
Creating dr for u[_38]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -2}_3
Creating dr for u[_38]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -2}_3
Creating dr for u[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {197, +, -2}_3
Creating dr for u[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {197, +, -2}_3
Creating dr for u[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {197, +, -2}_3
Creating dr for u[j_120]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {99, +, -1}_3
Creating dr for u[j_120]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {99, +, -1}_3
Creating dr for u[j_120]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {99, +, -1}_3
Creating dr for u[_38]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -2}_3
Creating dr for u[_38]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -2}_3
Creating dr for u[_38]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -2}_3
Creating dr for u[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {197, +, -2}_3
Creating dr for u[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {197, +, -2}_3
Creating dr for u[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {197, +, -2}_3
Analyzing # of iterations of loop 3
  exit condition [98, + , -1](no_overflow) != 0
  bounds on difference of bases: -98 ... -98
  result:
    # of iterations 98, bounded by 98
Analyzing # of iterations of loop 3
  exit condition [98, + , -1](no_overflow) != 0
  bounds on difference of bases: -98 ... -98
  result:
    # of iterations 98, bounded by 98
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Analyzing # of iterations of loop 4
  exit condition [197, + , -1](no_overflow) != 99
  bounds on difference of bases: -98 ... -98
  result:
    # of iterations 98, bounded by 98
Analyzing # of iterations of loop 4
  exit condition [197, + , -1](no_overflow) != 99
  bounds on difference of bases: -98 ... -98
  result:
    # of iterations 98, bounded by 98
Creating dr for u[100]
analyze_innermost: success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 800
	step: 0
	aligned to: 256
	base_object: u
	Access function 0: 100
Creating dr for u[100]
analyze_innermost: success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 800
	step: 0
	aligned to: 256
	base_object: u
	Access function 0: 100
Creating dr for u[0]
analyze_innermost: success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 0
	step: 0
	aligned to: 256
	base_object: u
	Access function 0: 0
Creating dr for u[0]
analyze_innermost: success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 0
	step: 0
	aligned to: 256
	base_object: u
	Access function 0: 0
Creating dr for u[37]
analyze_innermost: success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 296
	step: 0
	aligned to: 256
	base_object: u
	Access function 0: 37
Creating dr for u[37]
analyze_innermost: success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 296
	step: 0
	aligned to: 256
	base_object: u
	Access function 0: 37
Creating dr for u[37]
analyze_innermost: success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 296
	step: 0
	aligned to: 256
	base_object: u
	Access function 0: 37
Creating dr for u[37]
analyze_innermost: success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 296
	step: 0
	aligned to: 256
	base_object: u
	Access function 0: 37
Creating dr for u[j_120]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {99, +, -1}_3
Creating dr for u[j_120]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {99, +, -1}_3
Creating dr for u[j_120]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {99, +, -1}_3
Creating dr for u[_38]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -2}_3
Creating dr for u[_38]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -2}_3
Creating dr for u[_38]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -2}_3
Creating dr for u[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {197, +, -2}_3
Creating dr for u[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {197, +, -2}_3
Creating dr for u[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {197, +, -2}_3
Creating dr for u[j_120]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {99, +, -1}_3
Creating dr for u[j_120]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {99, +, -1}_3
Creating dr for u[j_120]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {99, +, -1}_3
Creating dr for u[_38]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -2}_3
Creating dr for u[_38]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -2}_3
Creating dr for u[_38]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -2}_3
Creating dr for u[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {197, +, -2}_3
Creating dr for u[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {197, +, -2}_3
Creating dr for u[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {197, +, -2}_3
Analyzing # of iterations of loop 3
  exit condition [98, + , -1](no_overflow) != 0
  bounds on difference of bases: -98 ... -98
  result:
    # of iterations 98, bounded by 98
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Analyzing # of iterations of loop 4
  exit condition [197, + , -1](no_overflow) != 99
  bounds on difference of bases: -98 ... -98
  result:
    # of iterations 98, bounded by 98
Creating dr for u[100]
analyze_innermost: success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 800
	step: 0
	aligned to: 256
	base_object: u
	Access function 0: 100
Creating dr for u[100]
analyze_innermost: success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 800
	step: 0
	aligned to: 256
	base_object: u
	Access function 0: 100
Creating dr for u[0]
analyze_innermost: success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 0
	step: 0
	aligned to: 256
	base_object: u
	Access function 0: 0
Creating dr for u[0]
analyze_innermost: success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 0
	step: 0
	aligned to: 256
	base_object: u
	Access function 0: 0
Creating dr for u[37]
analyze_innermost: success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 296
	step: 0
	aligned to: 256
	base_object: u
	Access function 0: 37
Creating dr for u[37]
analyze_innermost: success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 296
	step: 0
	aligned to: 256
	base_object: u
	Access function 0: 37
Creating dr for u[37]
analyze_innermost: success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 296
	step: 0
	aligned to: 256
	base_object: u
	Access function 0: 37
Creating dr for u[37]
analyze_innermost: success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 296
	step: 0
	aligned to: 256
	base_object: u
	Access function 0: 37
Analyzing # of iterations of loop 8
  exit condition [1, + , 1](no_overflow) != 10
  bounds on difference of bases: 9 ... 9
  result:
    # of iterations 9, bounded by 9
Analyzing # of iterations of loop 8
  exit condition [1, + , 1](no_overflow) != 10
  bounds on difference of bases: 9 ... 9
  result:
    # of iterations 9, bounded by 9
Analyzing # of iterations of loop 8
  exit condition [1, + , 1](no_overflow) != 10
  bounds on difference of bases: 9 ... 9
  result:
    # of iterations 9, bounded by 9
Creating dr for ranf_arr_ptr
analyze_innermost: success.
	base_address: &ranf_arr_ptr
	offset from base address: 0
	constant offset from base address: 0
	step: 0
	aligned to: 256
	base_object: ranf_arr_ptr

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:2)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:9)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:8)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:2)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:2)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:8, LOOPS:2, CONDITIONS:2, STMTS:34)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:2, LOOPS:0, CONDITIONS:0, STMTS:9)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

number of SCoPs: 2

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:10)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:21)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Global statistics (BBS:35, LOOPS:5, CONDITIONS:8, STMTS:99)

Global profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)
Creating dr for u[j_120]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 792
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {99, +, -1}_3
Creating dr for u[_38]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -2}_3
Creating dr for u[_42]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1576
	step: -16(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {197, +, -2}_3

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 98; c1 += 1)
  S_11(c1);


Removing basic block 46
basic block 46, loop depth 1
 pred:      
goto <bb 44>;
 succ:       44



Updating SSA:
Registering new PHI nodes in block #43
Registering new PHI nodes in block #45
Registering new PHI nodes in block #11
Updating SSA information for statement u[_42] = 0.0;
Registering new PHI nodes in block #12
Registering new PHI nodes in block #13
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #41
Registering new PHI nodes in block #37
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16
Registering new PHI nodes in block #36
Registering new PHI nodes in block #21
Registering new PHI nodes in block #23
Registering new PHI nodes in block #17
Registering new PHI nodes in block #20
Registering new PHI nodes in block #22
Registering new PHI nodes in block #39
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Registering new PHI nodes in block #24
Registering new PHI nodes in block #35
Registering new PHI nodes in block #27
Registering new PHI nodes in block #30
Registering new PHI nodes in block #31
Registering new PHI nodes in block #32
Registering new PHI nodes in block #33
Registering new PHI nodes in block #34

DFA Statistics for void ranf_start(long int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                             94        752b
DEF operands                             43        344b
VUSE operands                            23        184b
VDEF operands                            14        112b
PHI nodes                                18       1872b
PHI arguments                            36       1728b
---------------------------------------------------------
Total memory used by DFA/SSA data                 4992b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_87 -> { .MEM_43 }
Incremental SSA update started at block: 43
Number of blocks in CFG: 47
Number of blocks to update: 8 ( 17%)
Affected blocks: 11 12 13 14 37 43 44 45


Applying pattern match.pd:822, generic-match.c:7035
Applying pattern match.pd:439, generic-match.c:3611
Applying pattern match.pd:625, generic-match.c:1309

Updating SSA:
creating PHI node in block #48 for .MEM
creating PHI node in block #51 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #3
Updating SSA information for statement u[j_119] = ss_126;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #6
Registering new PHI nodes in block #7
Registering new PHI nodes in block #38
Updating SSA information for statement _33 = u[1];
Updating SSA information for statement u[1] = _34;
Registering new PHI nodes in block #10
Registering new PHI nodes in block #40
Registering new PHI nodes in block #43
Registering new PHI nodes in block #47
Registering new PHI nodes in block #51
Registering new PHI nodes in block #55
Updating SSA information for statement _81 = u[_83];
Updating SSA information for statement u[_67] = _81;
Updating SSA information for statement u[_110] = 0.0;
Registering new PHI nodes in block #53
Registering new PHI nodes in block #52
Registering new PHI nodes in block #54
Registering new PHI nodes in block #49
Registering new PHI nodes in block #50
Registering new PHI nodes in block #48
Registering new PHI nodes in block #45
Registering new PHI nodes in block #11
Updating SSA information for statement _39 = u[j_120];
Updating SSA information for statement u[_38] = _39;
Updating SSA information for statement u[_42] = 0.0;
Registering new PHI nodes in block #12
Registering new PHI nodes in block #13
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #41
Registering new PHI nodes in block #37
Registering new PHI nodes in block #14
Updating SSA information for statement _46 = u[_45];
Updating SSA information for statement _47 = u[j_121];
Updating SSA information for statement u[_45] = _53;
Updating SSA information for statement _56 = u[_55];
Updating SSA information for statement _57 = u[j_121];
Updating SSA information for statement u[_55] = _62;
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16
Registering new PHI nodes in block #36
Registering new PHI nodes in block #21
Registering new PHI nodes in block #23
Registering new PHI nodes in block #17
Updating SSA information for statement __builtin_memmove (_116, &u, 800);
Registering new PHI nodes in block #20
Updating SSA information for statement _70 = u[100];
Updating SSA information for statement u[0] = _70;
Updating SSA information for statement _72 = u[37];
Updating SSA information for statement u[37] = _77;
Registering new PHI nodes in block #22
Registering new PHI nodes in block #39
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Registering new PHI nodes in block #24
Registering new PHI nodes in block #35
Updating SSA information for statement __builtin_memcpy (_131, &u, 296);
Registering new PHI nodes in block #27
Updating SSA information for statement __builtin_memcpy (&ran_u, _133, 504);
Registering new PHI nodes in block #30
Registering new PHI nodes in block #31
Updating SSA information for statement ranf_array (&u, 199);
Registering new PHI nodes in block #32
Registering new PHI nodes in block #33
Registering new PHI nodes in block #34
Updating SSA information for statement ranf_arr_ptr = &ranf_arr_started;
Updating SSA information for statement u ={v} {CLOBBER};
Updating SSA information for statement return;

DFA Statistics for void ranf_start(long int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            108        864b
DEF operands                             53        424b
VUSE operands                            26        208b
VDEF operands                            16        128b
PHI nodes                                21       2184b
PHI arguments                            42       2016b
---------------------------------------------------------
Total memory used by DFA/SSA data                 5824b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_68 -> { .MEM_43 }
_81 -> { _39 }
.MEM_84 -> { .MEM_40 }

Symbols to be put in SSA form
{ D.3847 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 56
Number of blocks to update: 48 ( 86%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 20 21 22 23 24 27 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 47 48 49 50 51 52 53 54 55



0 loops carried no dependency.
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1080
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {135, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Creating dr for u[j_121]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 1584
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {198, +, -1}_4
Creating dr for u[_55]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &u
	offset from base address: 0
	constant offset from base address: 784
	step: -8(OVF)
	aligned to: 256
	base_object: u
	Access function 0: {98, +, -1}_4
Analyzing # of iterations of loop 4
  exit condition [197, + , -1](no_overflow) != 99
  bounds on difference of bases: -98 ... -98
  result:
    # of iterations 98, bounded by 98

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 98; c1 += 1)
  S_14(c1);


Removing basic block 61
basic block 61, loop depth 1
 pred:      
goto <bb 59>;
 succ:       59



Updating SSA:
Registering new PHI nodes in block #58
Registering new PHI nodes in block #60
Registering new PHI nodes in block #14
Updating SSA information for statement u[_55] = _62;
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16
Registering new PHI nodes in block #59
Registering new PHI nodes in block #57
Registering new PHI nodes in block #56
Registering new PHI nodes in block #36
Registering new PHI nodes in block #21
Registering new PHI nodes in block #23
Registering new PHI nodes in block #17
Updating SSA information for statement __builtin_memmove (_116, &u, 800);
Registering new PHI nodes in block #20
Registering new PHI nodes in block #22
Registering new PHI nodes in block #39
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Registering new PHI nodes in block #24
Registering new PHI nodes in block #35
Registering new PHI nodes in block #27
Registering new PHI nodes in block #30
Registering new PHI nodes in block #31
Registering new PHI nodes in block #32
Registering new PHI nodes in block #33
Registering new PHI nodes in block #34

DFA Statistics for void ranf_start(long int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            108        864b
DEF operands                             53        424b
VUSE operands                            26        208b
VDEF operands                            16        128b
PHI nodes                                22       2288b
PHI arguments                            44       2112b
---------------------------------------------------------
Total memory used by DFA/SSA data                 6024b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_115 -> { .MEM_63 }
Incremental SSA update started at block: 58
Number of blocks in CFG: 62
Number of blocks to update: 11 ( 18%)
Affected blocks: 8 14 15 16 17 21 22 23 58 59 60


Applying pattern match.pd:822, generic-match.c:7035
Applying pattern match.pd:439, generic-match.c:3611
Applying pattern match.pd:625, generic-match.c:1309
Applying pattern match.pd:822, generic-match.c:7035
Applying pattern match.pd:439, generic-match.c:3611
Applying pattern match.pd:625, generic-match.c:1309
gimple_simplified to _3 = _102 + _109;
Applying pattern match.pd:822, generic-match.c:7035
Applying pattern match.pd:439, generic-match.c:3611
Applying pattern match.pd:625, generic-match.c:1309
gimple_simplified to _17 = _18 + _19;

Updating SSA:
creating PHI node in block #63 for .MEM
creating PHI node in block #66 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #3
Updating SSA information for statement u[j_119] = ss_126;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #6
Registering new PHI nodes in block #7
Registering new PHI nodes in block #38
Updating SSA information for statement _33 = u[1];
Updating SSA information for statement u[1] = _34;
Registering new PHI nodes in block #10
Registering new PHI nodes in block #40
Registering new PHI nodes in block #43
Registering new PHI nodes in block #47
Registering new PHI nodes in block #51
Registering new PHI nodes in block #55
Updating SSA information for statement _81 = u[_83];
Updating SSA information for statement u[_67] = _81;
Updating SSA information for statement u[_110] = 0.0;
Registering new PHI nodes in block #53
Registering new PHI nodes in block #52
Registering new PHI nodes in block #54
Registering new PHI nodes in block #49
Registering new PHI nodes in block #50
Registering new PHI nodes in block #48
Registering new PHI nodes in block #45
Registering new PHI nodes in block #11
Updating SSA information for statement _39 = u[j_120];
Updating SSA information for statement u[_38] = _39;
Updating SSA information for statement u[_42] = 0.0;
Registering new PHI nodes in block #12
Registering new PHI nodes in block #13
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #41
Registering new PHI nodes in block #37
Registering new PHI nodes in block #58
Registering new PHI nodes in block #62
Registering new PHI nodes in block #66
Registering new PHI nodes in block #70
Updating SSA information for statement _109 = u[_103];
Updating SSA information for statement _102 = u[_10];
Updating SSA information for statement _3 = _102 + _109;
Updating SSA information for statement _1 = (int) _3;
Updating SSA information for statement _20 = (double) _1;
Updating SSA information for statement _96 = _3 - _20;
Updating SSA information for statement u[_103] = _96;
Updating SSA information for statement _19 = u[_94];
Updating SSA information for statement _18 = u[_10];
Updating SSA information for statement _17 = _18 + _19;
Updating SSA information for statement _16 = (int) _17;
Updating SSA information for statement _93 = (double) _16;
Updating SSA information for statement _95 = _17 - _93;
Updating SSA information for statement u[_94] = _95;
Registering new PHI nodes in block #68
Registering new PHI nodes in block #67
Registering new PHI nodes in block #69
Registering new PHI nodes in block #64
Registering new PHI nodes in block #65
Registering new PHI nodes in block #63
Registering new PHI nodes in block #60
Registering new PHI nodes in block #14
Updating SSA information for statement _46 = u[_45];
Updating SSA information for statement _47 = u[j_121];
Updating SSA information for statement _50 = _46 + _47;
Updating SSA information for statement _51 = (int) _50;
Updating SSA information for statement _52 = (double) _51;
Updating SSA information for statement _53 = _50 - _52;
Updating SSA information for statement u[_45] = _53;
Updating SSA information for statement _56 = u[_55];
Updating SSA information for statement _57 = u[j_121];
Updating SSA information for statement _59 = _56 + _57;
Updating SSA information for statement _60 = (int) _59;
Updating SSA information for statement _61 = (double) _60;
Updating SSA information for statement _62 = _59 - _61;
Updating SSA information for statement u[_55] = _62;
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16
Registering new PHI nodes in block #59
Registering new PHI nodes in block #57
Registering new PHI nodes in block #56
Registering new PHI nodes in block #36
Registering new PHI nodes in block #21
Registering new PHI nodes in block #23
Registering new PHI nodes in block #17
Updating SSA information for statement __builtin_memmove (_116, &u, 800);
Registering new PHI nodes in block #20
Updating SSA information for statement _70 = u[100];
Updating SSA information for statement u[0] = _70;
Updating SSA information for statement _72 = u[37];
Updating SSA information for statement u[37] = _77;
Registering new PHI nodes in block #22
Registering new PHI nodes in block #39
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Registering new PHI nodes in block #24
Registering new PHI nodes in block #35
Updating SSA information for statement __builtin_memcpy (_131, &u, 296);
Registering new PHI nodes in block #27
Updating SSA information for statement __builtin_memcpy (&ran_u, _133, 504);
Registering new PHI nodes in block #30
Registering new PHI nodes in block #31
Updating SSA information for statement ranf_array (&u, 199);
Registering new PHI nodes in block #32
Registering new PHI nodes in block #33
Registering new PHI nodes in block #34
Updating SSA information for statement ranf_arr_ptr = &ranf_arr_started;
Updating SSA information for statement u ={v} {CLOBBER};
Updating SSA information for statement return;

DFA Statistics for void ranf_start(long int)

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            136       1088b
DEF operands                             72        576b
VUSE operands                            32        256b
VDEF operands                            18        144b
PHI nodes                                25       2600b
PHI arguments                            50       2400b
---------------------------------------------------------
Total memory used by DFA/SSA data                 7064b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

_1 -> { _51 }
_3 -> { _50 }
.MEM_15 -> { .MEM_63 }
_16 -> { _60 }
_17 -> { _59 }
_18 -> { _57 }
_19 -> { _56 }
_20 -> { _52 }
.MEM_49 -> { .MEM_54 }
_93 -> { _61 }
_95 -> { _62 }
_96 -> { _53 }
_102 -> { _47 }
_109 -> { _46 }

Symbols to be put in SSA form
{ D.3847 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 71
Number of blocks to update: 62 ( 87%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 20 21 22 23 24 27 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 47 48 49 50 51 52 53 54 55 56 57 58 59 60 62 63 64 65 66 67 68 69 70



0 loops carried no dependency.
Removing basic block 7
basic block 7, loop depth 0
 pred:      
 succ:       38


Merging blocks 10 and 40
Removing basic block 13
basic block 13, loop depth 1
 pred:      
goto <bb 44>;
 succ:       44


Removing basic block 16
basic block 16, loop depth 1
 pred:      
goto <bb 59>;
 succ:       59


Merging blocks 17 and 20
Merging blocks 22 and 39
Removing basic block 24
basic block 24, loop depth 0
 pred:      
 succ:       35


Removing basic block 33
basic block 33, loop depth 0
 pred:      
 succ:       34


Merging blocks 35 and 27
Removing basic block 37
basic block 37, loop depth 1
 pred:      
 succ:       58


Removing basic block 41
basic block 41, loop depth 1
 pred:      
 succ:       58


Removing basic block 42
basic block 42, loop depth 1
 pred:      
goto <bb 58>;
 succ:       58


Removing basic block 12
basic block 12, loop depth 2
 pred:       11
goto <bb 11>;
 succ:       11


Removing basic block 11
basic block 11, loop depth 2
 pred:       43
# j_120 = PHI <99(43)>
# DEBUG j => j_120
_38 = j_120 + j_120;
_39 = u[j_120];
u[_38] = _39;
_42 = _38 + -1;
u[_42] = 0.0;
j_44 = j_120 + -1;
# DEBUG j => j_44
# DEBUG j => j_44
if (j_44 == 0)
 succ:       44


Removing basic block 43
basic block 43, loop depth 1
 pred:      
 succ:       47


Removing basic block 45
basic block 45, loop depth 1
 pred:      
 succ:       44


Removing basic block 50
basic block 50, loop depth 1
 pred:       47
goto <bb 48>;
 succ:       48


Removing basic block 49
basic block 49, loop depth 1
 pred:      
 succ:       48


Merging blocks 51 and 55
Removing basic block 54
basic block 54, loop depth 1
 pred:      
 succ:       48


Removing basic block 56
basic block 56, loop depth 1
 pred:      
 succ:       36


Removing basic block 57
basic block 57, loop depth 1
 pred:      
goto <bb 36>;
 succ:       36


Removing basic block 15
basic block 15, loop depth 2
 pred:       14
goto <bb 14>;
 succ:       14


Removing basic block 14
basic block 14, loop depth 2
 pred:       58
# j_121 = PHI <198(58)>
# DEBUG j => j_121
_45 = j_121 + -63;
_46 = u[_45];
_47 = u[j_121];
_50 = _46 + _47;
_51 = (int) _50;
_52 = (double) _51;
_53 = _50 - _52;
u[_45] = _53;
_55 = j_121 + -100;
_56 = u[_55];
_57 = u[j_121];
_59 = _56 + _57;
_60 = (int) _59;
_61 = (double) _60;
_62 = _59 - _61;
u[_55] = _62;
j_64 = j_121 + -1;
# DEBUG j => j_64
# DEBUG j => j_64
if (j_64 == 99)
 succ:       59


Removing basic block 58
basic block 58, loop depth 1
 pred:      
 succ:       62


Removing basic block 60
basic block 60, loop depth 1
 pred:      
 succ:       59


Removing basic block 65
basic block 65, loop depth 1
 pred:       62
goto <bb 63>;
 succ:       63


Removing basic block 64
basic block 64, loop depth 1
 pred:      
 succ:       63


Merging blocks 66 and 70
Removing basic block 69
basic block 69, loop depth 1
 pred:      
 succ:       63


Merging blocks 10 and 47
Merging blocks 35 and 30
Merging blocks 48 and 44
Merging blocks 48 and 62
Merging blocks 51 and 53
Merging blocks 63 and 59
Merging blocks 63 and 36
Merging blocks 66 and 68
fix_loop_structure: removing loop 4
fix_loop_structure: removing loop 3
Analyzing # of iterations of loop 8
  exit condition [1, + , 1](no_overflow) != 10
  bounds on difference of bases: 9 ... 9
  result:
    # of iterations 9, bounded by 9
Analyzing # of iterations of loop 10
  exit condition [0, + , 1](no_overflow) < 98
  bounds on difference of bases: 98 ... 98
  result:
    # of iterations 98, bounded by 98
Analyzing # of iterations of loop 9
  exit condition [0, + , 1](no_overflow) < 98
  bounds on difference of bases: 98 ... 98
  result:
    # of iterations 98, bounded by 98
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 100
  bounds on difference of bases: 99 ... 99
  result:
    # of iterations 99, bounded by 99
1 edges in bb 2 predicted to even probabilities
Predictions for bb 3
  DS theory heuristics: 73.0%
  first match heuristics (ignored): 73.0%
  combined heuristics: 73.0%
  opcode values positive (on trees) heuristics: 73.0%
1 edges in bb 4 predicted to even probabilities
Predictions for bb 5
  DS theory heuristics (ignored): 0.4%
  first match heuristics: 1.0%
  combined heuristics: 1.0%
  opcode values nonequal (on trees) heuristics (ignored): 28.0%
  loop iterations heuristics: 1.0%
1 edges in bb 6 predicted to even probabilities
1 edges in bb 7 predicted to even probabilities
Predictions for bb 8
  DS theory heuristics (ignored): 9.0%
  first match heuristics: 9.0%
  combined heuristics: 9.0%
  loop exit heuristics: 9.0%
1 edges in bb 9 predicted to even probabilities
1 edges in bb 10 predicted to even probabilities
Predictions for bb 11
  DS theory heuristics (ignored): 99.0%
  first match heuristics: 99.0%
  combined heuristics: 99.0%
  loop iterations heuristics: 99.0%
1 edges in bb 12 predicted to even probabilities
1 edges in bb 13 predicted to even probabilities
Predictions for bb 14
  DS theory heuristics (ignored): 99.0%
  first match heuristics: 99.0%
  combined heuristics: 99.0%
  loop iterations heuristics: 99.0%
1 edges in bb 15 predicted to even probabilities
Predictions for bb 16
  DS theory heuristics: 29.0%
  first match heuristics (ignored): 29.0%
  combined heuristics: 29.0%
  call heuristics: 29.0%
1 edges in bb 17 predicted to even probabilities
Predictions for bb 18
  no prediction heuristics: 50.0%
  combined heuristics: 50.0%
1 edges in bb 19 predicted to even probabilities
1 edges in bb 20 predicted to even probabilities
1 edges in bb 21 predicted to even probabilities
Predictions for bb 22
  DS theory heuristics (ignored): 2.7%
  first match heuristics: 10.0%
  combined heuristics: 10.0%
  opcode values nonequal (on trees) heuristics (ignored): 28.0%
  early return (on trees) heuristics (ignored): 39.0%
  loop iterations heuristics: 10.0%
1 edges in bb 23 predicted to even probabilities
1 edges in bb 24 predicted to even probabilities
loop_0 (header = 0, latch = 1, niter = )
{
  bb_2 (preds = {bb_0 }, succs = {bb_3 })
  {
    <bb 2>:
    # DEBUG ulp => 2.220446049250313080847263336181640625e-16
    _23 = seed_22(D) & 1073741823;
    _24 = _23 + 2;
    _25 = (double) _24;
    ss_26 = _25 * 4.44089209850062616169452667236328125e-16;
    # DEBUG ss => ss_26
    # DEBUG j => 0
    # DEBUG ss => ss_26
    # DEBUG j => 0

  }
  bb_7 (preds = {bb_5 }, succs = {bb_10 })
  {
    <bb 7>:
    # VUSE <.MEM_29>
    _33 = u[1];
    _34 = _33 + 2.220446049250313080847263336181640625e-16;
    # .MEM_35 = VDEF <.MEM_29>
    u[1] = _34;
    _36 = (int) seed_22(D);
    s_37 = _36 & 1073741823;
    # DEBUG s => s_37
    # DEBUG t => 69
    # DEBUG s => s_37
    # DEBUG t => 69
    goto <bb 10>;

  }
  bb_21 (preds = {bb_8 }, succs = {bb_22 })
  {
    <bb 21>:
    _131 = &ran_u + 504;
    # .MEM_124 = VDEF <.MEM_98>
    __builtin_memcpy (_131, &u, 296);
    _133 = &u + 296;
    # .MEM_85 = VDEF <.MEM_124>
    __builtin_memcpy (&ran_u, _133, 504);

  }
  bb_24 (preds = {bb_22 }, succs = {bb_1 })
  {
    <bb 24>:
    # .MEM_91 = VDEF <.MEM_89>
    ranf_arr_ptr = &ranf_arr_started;
    # .MEM_92 = VDEF <.MEM_91>
    u ={v} {CLOBBER};
    # VUSE <.MEM_92>
    return;

  }
  loop_8 (header = 22, latch = 23, niter = , upper_bound = 9, estimate = 9)
  {
    bb_22 (preds = {bb_21 bb_23 }, succs = {bb_24 bb_23 })
    {
      <bb 22>:
      # j_125 = PHI <0(21), j_90(23)>
      # .MEM_135 = PHI <.MEM_85(21), .MEM_89(23)>
      # DEBUG j => j_125
      # .MEM_89 = VDEF <.MEM_135>
      ranf_array (&u, 199);
      j_90 = j_125 + 1;
      # DEBUG j => j_90
      # DEBUG j => j_90
      if (j_90 == 10)
        goto <bb 24>;
      else
        goto <bb 23>;

    }
    bb_23 (preds = {bb_22 }, succs = {bb_22 })
    {
      <bb 23>:
      goto <bb 22>;

    }
  }
  loop_2 (header = 10, latch = 9, niter = )
  {
    bb_8 (preds = {bb_20 bb_19 }, succs = {bb_21 bb_9 })
    {
      <bb 8>:
      # t_48 = PHI <t_79(20), t_99(19)>
      # s_41 = PHI <0(20), s_80(19)>
      # .MEM_98 = PHI <.MEM_21(20), .MEM_132(19)>
      # DEBUG s => s_41
      # DEBUG t => t_48
      if (t_48 == 0)
        goto <bb 21>;
      else
        goto <bb 9>;

    }
    bb_9 (preds = {bb_8 }, succs = {bb_10 })
    {
      <bb 9>:

    }
    bb_10 (preds = {bb_9 bb_7 }, succs = {bb_11 })
    {
      <bb 10>:
      # t_99 = PHI <t_48(9), 69(7)>
      # s_58 = PHI <s_41(9), s_37(7)>
      # .MEM_128 = PHI <.MEM_98(9), .MEM_35(7)>
      # DEBUG s => s_58
      # DEBUG t => t_99
      # DEBUG j => 99

    }
    bb_13 (preds = {bb_11 }, succs = {bb_14 })
    {
      <bb 13>:
      # .MEM_107 = PHI <.MEM_68(11)>

    }
    bb_16 (preds = {bb_14 }, succs = {bb_17 bb_18 })
    {
      <bb 16>:
      # .MEM_21 = PHI <.MEM_15(14)>
      _65 = s_58 & 1;
      if (_65 != 0)
        goto <bb 17>;
      else
        goto <bb 18>;

    }
    bb_17 (preds = {bb_16 }, succs = {bb_19 })
    {
      <bb 17>:
      _116 = &u + 8;
      # .MEM_134 = VDEF <.MEM_21>
      __builtin_memmove (_116, &u, 800);
      # VUSE <.MEM_134>
      _70 = u[100];
      # .MEM_71 = VDEF <.MEM_134>
      u[0] = _70;
      # VUSE <.MEM_71>
      _72 = u[37];
      _74 = _70 + _72;
      _75 = (int) _74;
      _76 = (double) _75;
      _77 = _74 - _76;
      # .MEM_78 = VDEF <.MEM_71>
      u[37] = _77;
      goto <bb 19>;

    }
    bb_18 (preds = {bb_16 }, succs = {bb_19 bb_20 })
    {
      <bb 18>:
      if (s_58 != 0)
        goto <bb 19>;
      else
        goto <bb 20>;

    }
    bb_19 (preds = {bb_18 bb_17 }, succs = {bb_8 })
    {
      <bb 19>:
      # .MEM_132 = PHI <.MEM_21(18), .MEM_78(17)>
      s_80 = s_58 >> 1;
      # DEBUG s => s_80
      goto <bb 8>;

    }
    bb_20 (preds = {bb_18 }, succs = {bb_8 })
    {
      <bb 20>:
      t_79 = t_99 + -1;
      # DEBUG t => t_79
      goto <bb 8>;

    }
    loop_10 (header = 14, latch = 15, niter = )
    {
      bb_14 (preds = {bb_13 bb_15 }, succs = {bb_15 bb_16 })
      {
        <bb 14>:
        # graphite_IV.264_113 = PHI <0(13), graphite_IV.264_111(15)>
        # .MEM_69 = PHI <.MEM_107(13), .MEM_15(15)>
        # DEBUG j => NULL
        _108 = (int) graphite_IV.264_113;
        _103 = 135 - _108;
        # VUSE <.MEM_69>
        _109 = u[_103];
        _100 = (int) graphite_IV.264_113;
        _10 = 198 - _100;
        # VUSE <.MEM_69>
        _102 = u[_10];
        _3 = _102 + _109;
        _1 = (int) _3;
        _20 = (double) _1;
        _96 = _3 - _20;
        # .MEM_49 = VDEF <.MEM_69>
        u[_103] = _96;
        _73 = (int) graphite_IV.264_113;
        _94 = 98 - _73;
        # VUSE <.MEM_49>
        _19 = u[_94];
        # VUSE <.MEM_49>
        _18 = u[_10];
        _17 = _18 + _19;
        _16 = (int) _17;
        _93 = (double) _16;
        _95 = _17 - _93;
        # .MEM_15 = VDEF <.MEM_49>
        u[_94] = _95;
        # DEBUG j => NULL
        # DEBUG j => NULL
        graphite_IV.264_111 = graphite_IV.264_113 + 1;
        if (graphite_IV.264_113 < 98)
          goto <bb 15>;
        else
          goto <bb 16>;

      }
      bb_15 (preds = {bb_14 }, succs = {bb_14 })
      {
        <bb 15>:
        goto <bb 14>;

      }
    }
    loop_9 (header = 11, latch = 12, niter = )
    {
      bb_11 (preds = {bb_10 bb_12 }, succs = {bb_12 bb_13 })
      {
        <bb 11>:
        # graphite_IV.263_88 = PHI <0(10), graphite_IV.263_123(12)>
        # .MEM_106 = PHI <.MEM_128(10), .MEM_68(12)>
        # DEBUG j => NULL
        _82 = (int) graphite_IV.263_88;
        _83 = 99 - _82;
        # VUSE <.MEM_106>
        _81 = u[_83];
        _122 = (int) graphite_IV.263_88;
        _66 = 99 - _122;
        _67 = _66 * 2;
        # .MEM_84 = VDEF <.MEM_106>
        u[_67] = _81;
        _114 = (int) graphite_IV.263_88;
        _112 = _114 * -2;
        _110 = _112 + 197;
        # .MEM_68 = VDEF <.MEM_84>
        u[_110] = 0.0;
        # DEBUG j => NULL
        # DEBUG j => NULL
        graphite_IV.263_123 = graphite_IV.263_88 + 1;
        if (graphite_IV.263_88 < 98)
          goto <bb 12>;
        else
          goto <bb 13>;

      }
      bb_12 (preds = {bb_11 }, succs = {bb_11 })
      {
        <bb 12>:
        goto <bb 11>;

      }
    }
  }
  loop_1 (header = 3, latch = 6, niter = , upper_bound = 99, estimate = 99)
  {
    bb_3 (preds = {bb_6 bb_2 }, succs = {bb_4 bb_5 })
    {
      <bb 3>:
      # j_119 = PHI <j_32(6), 0(2)>
      # ss_126 = PHI <ss_11(6), ss_26(2)>
      # .MEM_127 = PHI <.MEM_29(6), .MEM_28(D)(2)>
      # DEBUG ss => ss_126
      # DEBUG j => j_119
      # .MEM_29 = VDEF <.MEM_127>
      u[j_119] = ss_126;
      ss_30 = ss_126 * 2.0e+0;
      # DEBUG ss => ss_30
      if (ss_30 >= 1.0e+0)
        goto <bb 4>;
      else
        goto <bb 5>;

    }
    bb_4 (preds = {bb_3 }, succs = {bb_5 })
    {
      <bb 4>:
      ss_31 = ss_30 - 9.99999999999999555910790149937383830547332763671875e-1;
      # DEBUG ss => ss_31

    }
    bb_5 (preds = {bb_3 bb_4 }, succs = {bb_7 bb_6 })
    {
      <bb 5>:
      # ss_11 = PHI <ss_30(3), ss_31(4)>
      # DEBUG ss => ss_11
      j_32 = j_119 + 1;
      # DEBUG j => j_32
      # DEBUG ss => ss_11
      # DEBUG j => j_32
      if (j_32 == 100)
        goto <bb 7>;
      else
        goto <bb 6>;

    }
    bb_6 (preds = {bb_5 }, succs = {bb_3 })
    {
      <bb 6>:
      goto <bb 3>;

    }
  }
}

Pass statistics:
----------------

void ranf_start(long int) (long intD.12 seedD.2919)
{
  signed long graphite_IV.264D.4219;
  doubleD.39 D.4218;
  doubleD.39 D.4217;
  intD.9 D.4216;
  doubleD.39 D.4215;
  doubleD.39 D.4214;
  doubleD.39 D.4213;
  doubleD.39 D.4212;
  doubleD.39 D.4211;
  intD.9 D.4210;
  doubleD.39 D.4209;
  doubleD.39 D.4208;
  doubleD.39 D.4207;
  signed long graphite_IV.263D.4206;
  doubleD.39 D.4205;
  doubleD.39 ssD.2927;
  doubleD.39 uD.2925[199];
  register intD.9 jD.2924;
  register intD.9 sD.2923;
  register intD.9 tD.2922;
  intD.9 _1;
  doubleD.39 _3;
  intD.9 _10;
  intD.9 _16;
  doubleD.39 _17;
  doubleD.39 _18;
  doubleD.39 _19;
  doubleD.39 _20;
  long intD.12 _23;
  long intD.12 _24;
  doubleD.39 _25;
  doubleD.39 _33;
  doubleD.39 _34;
  intD.9 _36;
  intD.9 _65;
  intD.9 _66;
  intD.9 _67;
  doubleD.39 _70;
  doubleD.39 _72;
  intD.9 _73;
  doubleD.39 _74;
  intD.9 _75;
  doubleD.39 _76;
  doubleD.39 _77;
  doubleD.39 _81;
  intD.9 _82;
  intD.9 _83;
  doubleD.39 _93;
  intD.9 _94;
  doubleD.39 _95;
  doubleD.39 _96;
  intD.9 _100;
  doubleD.39 _102;
  intD.9 _103;
  intD.9 _108;
  doubleD.39 _109;
  intD.9 _110;
  intD.9 _112;
  intD.9 _114;
  doubleD.39[199] * _116;
  intD.9 _122;
  doubleD.39[100] * _131;
  doubleD.39[199] * _133;

;;   basic block 2, loop depth 0, count 0, freq 9, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY [100.0%]  (FALLTHRU,EXECUTABLE)
  # DEBUG ulpD.2926 => 2.220446049250313080847263336181640625e-16
  # RANGE [0, 1073741823] NONZERO 1073741823
  _23 = seed_22(D) & 1073741823;
  # RANGE [2, 1073741825] NONZERO 2147483647
  _24 = _23 + 2;
  _25 = (doubleD.39) _24;
  ss_26 = _25 * 4.44089209850062616169452667236328125e-16;
  # DEBUG ssD.2927 => ss_26
  # DEBUG jD.2924 => 0
  # DEBUG ssD.2927 => ss_26
  # DEBUG jD.2924 => 0
;;    succ:       3 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 3, loop depth 1, count 0, freq 909, maybe hot
;;    prev block 2, next block 4, flags: (NEW, REACHABLE)
;;    pred:       6 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                2 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 100] NONZERO 127
  # j_119 = PHI <j_32(6), 0(2)>
  # ss_126 = PHI <ss_11(6), ss_26(2)>
  # .MEM_127 = PHI <.MEM_29(6), .MEM_28(D)(2)>
  # DEBUG ssD.2927 => ss_126
  # DEBUG jD.2924 => j_119
  # .MEM_29 = VDEF <.MEM_127>
  uD.2925[j_119] = ss_126;
  ss_30 = ss_126 * 2.0e+0;
  # DEBUG ssD.2927 => ss_30
  if (ss_30 >= 1.0e+0)
    goto <bb 4>;
  else
    goto <bb 5>;
;;    succ:       4 [73.0%]  (TRUE_VALUE,EXECUTABLE)
;;                5 [27.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 4, loop depth 1, count 0, freq 664, maybe hot
;;    prev block 3, next block 5, flags: (NEW, REACHABLE)
;;    pred:       3 [73.0%]  (TRUE_VALUE,EXECUTABLE)
  ss_31 = ss_30 - 9.99999999999999555910790149937383830547332763671875e-1;
  # DEBUG ssD.2927 => ss_31
;;    succ:       5 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 5, loop depth 1, count 0, freq 909, maybe hot
;;    prev block 4, next block 6, flags: (NEW, REACHABLE)
;;    pred:       3 [27.0%]  (FALSE_VALUE,EXECUTABLE)
;;                4 [100.0%]  (FALLTHRU,EXECUTABLE)
  # ss_11 = PHI <ss_30(3), ss_31(4)>
  # DEBUG ssD.2927 => ss_11
  # RANGE [1, 100] NONZERO 127
  j_32 = j_119 + 1;
  # DEBUG jD.2924 => j_32
  # DEBUG ssD.2927 => ss_11
  # DEBUG jD.2924 => j_32
  if (j_32 == 100)
    goto <bb 7>;
  else
    goto <bb 6>;
;;    succ:       7 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                6 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 6, loop depth 1, count 0, freq 900, maybe hot
;;    prev block 5, next block 7, flags: (NEW)
;;    pred:       5 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 7, loop depth 0, count 0, freq 9, maybe hot
;;    prev block 6, next block 8, flags: (NEW)
;;    pred:       5 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # VUSE <.MEM_29>
  _33 = uD.2925[1];
  _34 = _33 + 2.220446049250313080847263336181640625e-16;
  # .MEM_35 = VDEF <.MEM_29>
  uD.2925[1] = _34;
  _36 = (intD.9) seed_22(D);
  # RANGE [0, 1073741823] NONZERO 1073741823
  s_37 = _36 & 1073741823;
  # DEBUG sD.2923 => s_37
  # DEBUG tD.2922 => 69
  # DEBUG sD.2923 => s_37
  # DEBUG tD.2922 => 69
  goto <bb 10>;
;;    succ:       10 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 8, loop depth 1, count 0, freq 101, maybe hot
;;    prev block 7, next block 9, flags: (NEW, REACHABLE)
;;    pred:       20 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                19 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [-2147483648, 69]
  # t_48 = PHI <t_79(20), t_99(19)>
  # RANGE [0, 536870911] NONZERO 536870911
  # s_41 = PHI <0(20), s_80(19)>
  # .MEM_98 = PHI <.MEM_21(20), .MEM_132(19)>
  # DEBUG sD.2923 => s_41
  # DEBUG tD.2922 => t_48
  if (t_48 == 0)
    goto <bb 21>;
  else
    goto <bb 9>;
;;    succ:       21 [9.0%]  (TRUE_VALUE,EXECUTABLE)
;;                9 [91.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 9, loop depth 1, count 0, freq 92, maybe hot
;;    prev block 8, next block 10, flags: (NEW)
;;    pred:       8 [91.0%]  (FALSE_VALUE,EXECUTABLE)
;;    succ:       10 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 10, loop depth 1, count 0, freq 101, maybe hot
;;    prev block 9, next block 11, flags: (NEW, REACHABLE)
;;    pred:       9 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                7 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [-2147483648, 69]
  # t_99 = PHI <t_48(9), 69(7)>
  # RANGE [0, 1073741823] NONZERO 1073741823
  # s_58 = PHI <s_41(9), s_37(7)>
  # .MEM_128 = PHI <.MEM_98(9), .MEM_35(7)>
  # DEBUG sD.2923 => s_58
  # DEBUG tD.2922 => t_99
  # DEBUG jD.2924 => 99
;;    succ:       11 [100.0%]  (FALLTHRU)

;;   basic block 11, loop depth 2, count 0, freq 10000, maybe hot
;;    prev block 10, next block 12, flags: (NEW)
;;    pred:       10 [100.0%]  (FALLTHRU)
;;                12 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.263_88 = PHI <0(10), graphite_IV.263_123(12)>
  # .MEM_106 = PHI <.MEM_128(10), .MEM_68(12)>
  # DEBUG jD.2924 => NULL
  _82 = (intD.9) graphite_IV.263_88;
  _83 = 99 - _82;
  # VUSE <.MEM_106>
  _81 = uD.2925[_83];
  _122 = (intD.9) graphite_IV.263_88;
  _66 = 99 - _122;
  _67 = _66 * 2;
  # .MEM_84 = VDEF <.MEM_106>
  uD.2925[_67] = _81;
  _114 = (intD.9) graphite_IV.263_88;
  _112 = _114 * -2;
  _110 = _112 + 197;
  # .MEM_68 = VDEF <.MEM_84>
  uD.2925[_110] = 0.0;
  # DEBUG jD.2924 => NULL
  # DEBUG jD.2924 => NULL
  graphite_IV.263_123 = graphite_IV.263_88 + 1;
  if (graphite_IV.263_88 < 98)
    goto <bb 12>;
  else
    goto <bb 13>;
;;    succ:       12 [99.0%]  (TRUE_VALUE)
;;                13 [1.0%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 12, loop depth 2, count 0, freq 9899, maybe hot
;;    prev block 11, next block 13, flags: (NEW)
;;    pred:       11 [99.0%]  (TRUE_VALUE)
  goto <bb 11>;
;;    succ:       11 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 13, loop depth 1, count 0, freq 101, maybe hot
;;    prev block 12, next block 14, flags: (NEW)
;;    pred:       11 [1.0%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_107 = PHI <.MEM_68(11)>
;;    succ:       14 [100.0%]  (FALLTHRU)

;;   basic block 14, loop depth 2, count 0, freq 10000, maybe hot
;;    prev block 13, next block 15, flags: (NEW)
;;    pred:       13 [100.0%]  (FALLTHRU)
;;                15 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.264_113 = PHI <0(13), graphite_IV.264_111(15)>
  # .MEM_69 = PHI <.MEM_107(13), .MEM_15(15)>
  # DEBUG jD.2924 => NULL
  _108 = (intD.9) graphite_IV.264_113;
  _103 = 135 - _108;
  # VUSE <.MEM_69>
  _109 = uD.2925[_103];
  _100 = (intD.9) graphite_IV.264_113;
  _10 = 198 - _100;
  # VUSE <.MEM_69>
  _102 = uD.2925[_10];
  _3 = _102 + _109;
  _1 = (intD.9) _3;
  _20 = (doubleD.39) _1;
  _96 = _3 - _20;
  # .MEM_49 = VDEF <.MEM_69>
  uD.2925[_103] = _96;
  _73 = (intD.9) graphite_IV.264_113;
  _94 = 98 - _73;
  # VUSE <.MEM_49>
  _19 = uD.2925[_94];
  # VUSE <.MEM_49>
  _18 = uD.2925[_10];
  _17 = _18 + _19;
  _16 = (intD.9) _17;
  _93 = (doubleD.39) _16;
  _95 = _17 - _93;
  # .MEM_15 = VDEF <.MEM_49>
  uD.2925[_94] = _95;
  # DEBUG jD.2924 => NULL
  # DEBUG jD.2924 => NULL
  graphite_IV.264_111 = graphite_IV.264_113 + 1;
  if (graphite_IV.264_113 < 98)
    goto <bb 15>;
  else
    goto <bb 16>;
;;    succ:       15 [99.0%]  (TRUE_VALUE)
;;                16 [1.0%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 15, loop depth 2, count 0, freq 9899, maybe hot
;;    prev block 14, next block 16, flags: (NEW)
;;    pred:       14 [99.0%]  (TRUE_VALUE)
  goto <bb 14>;
;;    succ:       14 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 16, loop depth 1, count 0, freq 101, maybe hot
;;    prev block 15, next block 17, flags: (NEW)
;;    pred:       14 [1.0%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_21 = PHI <.MEM_15(14)>
  # RANGE [0, 1] NONZERO 1
  _65 = s_58 & 1;
  if (_65 != 0)
    goto <bb 17>;
  else
    goto <bb 18>;
;;    succ:       17 [29.0%]  (TRUE_VALUE,EXECUTABLE)
;;                18 [71.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 17, loop depth 1, count 0, freq 29, maybe hot
;;    prev block 16, next block 18, flags: (NEW, REACHABLE)
;;    pred:       16 [29.0%]  (TRUE_VALUE,EXECUTABLE)
  _116 = &uD.2925 + 8;
  # .MEM_134 = VDEF <.MEM_21>
  # USE = anything 
  # CLB = anything 
  memmoveD.995 (_116, &uD.2925, 800);
  # VUSE <.MEM_134>
  _70 = uD.2925[100];
  # .MEM_71 = VDEF <.MEM_134>
  uD.2925[0] = _70;
  # VUSE <.MEM_71>
  _72 = uD.2925[37];
  _74 = _70 + _72;
  _75 = (intD.9) _74;
  _76 = (doubleD.39) _75;
  _77 = _74 - _76;
  # .MEM_78 = VDEF <.MEM_71>
  uD.2925[37] = _77;
  goto <bb 19>;
;;    succ:       19 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 18, loop depth 1, count 0, freq 72, maybe hot
;;    prev block 17, next block 19, flags: (NEW, REACHABLE)
;;    pred:       16 [71.0%]  (FALSE_VALUE,EXECUTABLE)
  if (s_58 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;
;;    succ:       19 [50.0%]  (TRUE_VALUE,EXECUTABLE)
;;                20 [50.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 19, loop depth 1, count 0, freq 65, maybe hot
;;    prev block 18, next block 20, flags: (NEW, REACHABLE)
;;    pred:       18 [50.0%]  (TRUE_VALUE,EXECUTABLE)
;;                17 [100.0%]  (FALLTHRU,EXECUTABLE)
  # .MEM_132 = PHI <.MEM_21(18), .MEM_78(17)>
  # RANGE [0, 536870911] NONZERO 536870911
  s_80 = s_58 >> 1;
  # DEBUG sD.2923 => s_80
  goto <bb 8>;
;;    succ:       8 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 20, loop depth 1, count 0, freq 36, maybe hot
;;    prev block 19, next block 21, flags: (NEW, REACHABLE)
;;    pred:       18 [50.0%]  (FALSE_VALUE,EXECUTABLE)
  # RANGE [-2147483648, 68]
  t_79 = t_99 + -1;
  # DEBUG tD.2922 => t_79
  goto <bb 8>;
;;    succ:       8 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 21, loop depth 0, count 0, freq 9, maybe hot
;;    prev block 20, next block 22, flags: (NEW)
;;    pred:       8 [9.0%]  (TRUE_VALUE,EXECUTABLE)
  _131 = &ran_uD.2900 + 504;
  # .MEM_124 = VDEF <.MEM_98>
  # USE = anything 
  # CLB = anything 
  memcpyD.992 (_131, &uD.2925, 296);
  _133 = &uD.2925 + 296;
  # .MEM_85 = VDEF <.MEM_124>
  # USE = anything 
  # CLB = anything 
  memcpyD.992 (&ran_uD.2900, _133, 504);
;;    succ:       22 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 22, loop depth 1, count 0, freq 91, maybe hot
;;    prev block 21, next block 23, flags: (NEW, REACHABLE)
;;    pred:       21 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                23 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [0, 10] NONZERO 15
  # j_125 = PHI <0(21), j_90(23)>
  # .MEM_135 = PHI <.MEM_85(21), .MEM_89(23)>
  # DEBUG jD.2924 => j_125
  # .MEM_89 = VDEF <.MEM_135>
  # USE = nonlocal { D.2917 D.2925 } (nonlocal, escaped)
  # CLB = nonlocal { D.2917 D.2925 } (nonlocal, escaped)
  _Z10ranf_arrayPdiD.2903 (&uD.2925, 199);
  # RANGE [1, 10] NONZERO 15
  j_90 = j_125 + 1;
  # DEBUG jD.2924 => j_90
  # DEBUG jD.2924 => j_90
  if (j_90 == 10)
    goto <bb 24>;
  else
    goto <bb 23>;
;;    succ:       24 [10.0%]  (TRUE_VALUE,EXECUTABLE)
;;                23 [90.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 23, loop depth 1, count 0, freq 82, maybe hot
;;    prev block 22, next block 24, flags: (NEW)
;;    pred:       22 [90.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 22>;
;;    succ:       22 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 24, loop depth 0, count 0, freq 9, maybe hot
;;    prev block 23, next block 1, flags: (NEW)
;;    pred:       22 [10.0%]  (TRUE_VALUE,EXECUTABLE)
  # .MEM_91 = VDEF <.MEM_89>
  ranf_arr_ptrD.2918 = &ranf_arr_startedD.2917;
  # .MEM_92 = VDEF <.MEM_91>
  uD.2925 ={v} {CLOBBER};
  # VUSE <.MEM_92>
  return;
;;    succ:       EXIT [100.0%] 

}



;; Function int rng_double_main() (_Z15rng_double_mainv, funcdef_no=33, decl_uid=3717, cgraph_uid=33, symbol_order=38)


Pass statistics:
----------------

int rng_double_main() ()
{
  register intD.9 jD.4283;
  register intD.9 iD.4282;
  doubleD.39 aD.3720[2009];
  register intD.9 mD.3719;
  doubleD.39 _9;
  doubleD.39 _13;
  long unsigned intD.14 _24;
  long unsigned intD.14 _25;
  doubleD.39 * _26;
  sizetype _27;
  doubleD.39 * _28;
  doubleD.39 _29;
  sizetype _30;
  doubleD.39 * _31;
  doubleD.39 _32;
  doubleD.39 _33;
  intD.9 _34;
  doubleD.39 _35;
  doubleD.39 _36;
  long unsigned intD.14 _40;
  long unsigned intD.14 _41;
  sizetype _42;
  doubleD.39 * _43;
  doubleD.39 _44;
  sizetype _45;
  doubleD.39 * _46;
  doubleD.39 _47;
  doubleD.39 _48;
  intD.9 _49;
  doubleD.39 _50;
  doubleD.39 _51;
  long unsigned intD.14 _56;
  long unsigned intD.14 _57;
  sizetype _58;
  doubleD.39 * _59;
  doubleD.39 _60;
  intD.9 _61;
  doubleD.39 _62;
  doubleD.39 _63;
  intD.9 _64;
  doubleD.39 _65;
  doubleD.39 _66;

;;   basic block 2, loop depth 0, count 0, freq 1, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY [100.0%]  (FALLTHRU,EXECUTABLE)
  # .MEM_6 = VDEF <.MEM_5(D)>
  # USE = nonlocal null { D.3720 } (escaped)
  # CLB = nonlocal null { D.3720 } (escaped)
  _Z10ranf_startlD.2920 (310952);
  # DEBUG mD.3719 => 0
  # DEBUG mD.3719 => 0
;;    succ:       3 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 3, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 2, next block 4, flags: (NEW, REACHABLE)
;;    pred:       4 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                2 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 2009] NONZERO 2047
  # m_71 = PHI <m_8(4), 0(2)>
  # .MEM_100 = PHI <.MEM_7(4), .MEM_6(2)>
  # DEBUG mD.3719 => m_71
  # .MEM_7 = VDEF <.MEM_100>
  # USE = nonlocal null { D.3720 } (escaped)
  # CLB = nonlocal null { D.3720 } (escaped)
  _Z10ranf_arrayPdi.constprop.0D.3862 (&aD.3720);
  # RANGE [1, 2009] NONZERO 2047
  m_8 = m_71 + 1;
  # DEBUG mD.3719 => m_8
  # DEBUG mD.3719 => m_8
  if (m_8 == 2009)
    goto <bb 5>;
  else
    goto <bb 4>;
;;    succ:       5 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                4 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 4, loop depth 1, count 0, freq 99, maybe hot
;;    prev block 3, next block 5, flags: (NEW)
;;    pred:       3 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 5, loop depth 0, count 0, freq 1, maybe hot
;;    prev block 4, next block 6, flags: (NEW, REACHABLE)
;;    pred:       3 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # VUSE <.MEM_7>
  _9 = ran_uD.2900[0];
  # DEBUG __fmtD.3856 => "%.20f\n"
  # .MEM_14 = VDEF <.MEM_7>
  # USE = nonlocal null { D.3720 } (escaped)
  # CLB = nonlocal null { D.3720 } (escaped)
  __printf_chkD.1500 (1, "%.20f\n", _9);
  # .MEM_10 = VDEF <.MEM_14>
  # USE = nonlocal null { D.3720 } (escaped)
  # CLB = nonlocal null { D.3720 } (escaped)
  _Z10ranf_startlD.2920 (310952);
  # DEBUG mD.3719 => 0
  # DEBUG mD.3719 => 0
;;    succ:       6 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 6, loop depth 1, count 0, freq 100, maybe hot
;;   Invalid sum of outgoing probabilities 1.0%
;;    prev block 5, next block 9, flags: (NEW, REACHABLE)
;;    pred:       19 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                5 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 1009] NONZERO 1023
  # m_69 = PHI <m_12(19), 0(5)>
  # .MEM_101 = PHI <.MEM_80(19), .MEM_10(5)>
  # DEBUG mD.3719 => m_69
  # DEBUG jD.4283 => 0
  # .MEM_103 = VDEF <.MEM_101>
  # USE = anything 
  # CLB = anything 
  memcpyD.992 (&aD.3720, &ran_uD.2900, 800);
;;    succ:       9 [1.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 9, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 6, next block 10, flags: (NEW)
;;    pred:       6 [1.0%]  (FALLTHRU,EXECUTABLE)
;;    succ:       10 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 10, loop depth 2, count 0, freq 1011, maybe hot
;;    prev block 9, next block 11, flags: (NEW, REACHABLE)
;;    pred:       9 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                11 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [100, 2147483646] NONZERO 2047
  # j_104 = PHI <100(9), j_37(11)>
  # .MEM_109 = PHI <.MEM_103(9), .MEM_78(11)>
  # DEBUG jD.4283 => j_104
  # RANGE [100, 2008] NONZERO 2047
  _24 = (long unsigned intD.14) j_104;
  # RANGE [800, 16064] NONZERO 16376
  _25 = _24 * 8;
  # PT = { D.3720 } (escaped)
  # ALIGN = 8, MISALIGN = 0
  _26 = &aD.3720 + _25;
  # RANGE [0, 15264] NONZERO 16376
  _27 = _25 + 18446744073709550816;
  # PT = { D.3720 } (escaped)
  # ALIGN = 8, MISALIGN = 0
  _28 = &aD.3720 + _27;
  # VUSE <.MEM_109>
  _29 = *_28;
  # RANGE [504, 15768] NONZERO 16376
  _30 = _25 + 18446744073709551320;
  # PT = { D.3720 } (escaped)
  # ALIGN = 8, MISALIGN = 0
  _31 = &aD.3720 + _30;
  # VUSE <.MEM_109>
  _32 = *_31;
  _33 = _29 + _32;
  _34 = (intD.9) _33;
  _35 = (doubleD.39) _34;
  _36 = _33 - _35;
  # .MEM_78 = VDEF <.MEM_109>
  *_26 = _36;
  # RANGE [101, 2009] NONZERO 2047
  j_37 = j_104 + 1;
  # DEBUG jD.4283 => j_37
  # DEBUG jD.4283 => j_37
  if (j_37 > 2008)
    goto <bb 12>;
  else
    goto <bb 11>;
;;    succ:       12 [9.9%]  (TRUE_VALUE,EXECUTABLE)
;;                11 [90.1%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 11, loop depth 2, count 0, freq 911, maybe hot
;;    prev block 10, next block 12, flags: (NEW)
;;    pred:       10 [90.1%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 10>;
;;    succ:       10 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 12, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 11, next block 13, flags: (NEW)
;;    pred:       10 [9.9%]  (TRUE_VALUE,EXECUTABLE)
;;    succ:       13 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 13, loop depth 2, count 0, freq 3702, maybe hot
;;    prev block 12, next block 14, flags: (NEW, REACHABLE)
;;    pred:       12 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                14 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [0, 37] NONZERO 63
  # i_105 = PHI <0(12), i_52(14)>
  # RANGE [2009, 2147483647] NONZERO 2147483647
  # j_106 = PHI <2009(12), j_53(14)>
  # .MEM_110 = PHI <.MEM_78(12), .MEM_79(14)>
  # DEBUG jD.4283 => j_106
  # DEBUG iD.4282 => i_105
  # RANGE [0, 18446744073709551615] NONZERO 2147483647
  _40 = (long unsigned intD.14) j_106;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _41 = _40 * 8;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _42 = _41 + 18446744073709550816;
  # PT = { D.3720 } (escaped)
  # ALIGN = 8, MISALIGN = 0
  _43 = &aD.3720 + _42;
  # VUSE <.MEM_110>
  _44 = *_43;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _45 = _41 + 18446744073709551320;
  # PT = { D.3720 } (escaped)
  # ALIGN = 8, MISALIGN = 0
  _46 = &aD.3720 + _45;
  # VUSE <.MEM_110>
  _47 = *_46;
  _48 = _44 + _47;
  _49 = (intD.9) _48;
  _50 = (doubleD.39) _49;
  _51 = _48 - _50;
  # .MEM_79 = VDEF <.MEM_110>
  ran_uD.2900[i_105] = _51;
  # RANGE [1, 37] NONZERO 63
  i_52 = i_105 + 1;
  # DEBUG iD.4282 => i_52
  # RANGE [2010, 2147483647] NONZERO 2147483647
  j_53 = j_106 + 1;
  # DEBUG jD.4283 => j_53
  # DEBUG jD.4283 => j_53
  # DEBUG iD.4282 => i_52
  if (i_52 == 37)
    goto <bb 15>;
  else
    goto <bb 14>;
;;    succ:       15 [2.7%]  (TRUE_VALUE,EXECUTABLE)
;;                14 [97.3%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 14, loop depth 2, count 0, freq 3602, maybe hot
;;    prev block 13, next block 15, flags: (NEW)
;;    pred:       13 [97.3%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 13>;
;;    succ:       13 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 15, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 14, next block 16, flags: (NEW)
;;    pred:       13 [2.7%]  (TRUE_VALUE,EXECUTABLE)
;;    succ:       16 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 16, loop depth 2, count 0, freq 9900, maybe hot
;;    prev block 15, next block 17, flags: (NEW, REACHABLE)
;;    pred:       15 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                17 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [37, 137] NONZERO 127
  # i_107 = PHI <37(15), i_67(17)>
  # RANGE [2009, 2147483647] NONZERO 2147483647
  # j_108 = PHI <2046(15), j_68(17)>
  # .MEM_111 = PHI <.MEM_79(15), .MEM_80(17)>
  # DEBUG jD.4283 => j_108
  # DEBUG iD.4282 => i_107
  # RANGE [0, 18446744073709551615] NONZERO 2147483647
  _56 = (long unsigned intD.14) j_108;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _57 = _56 * 8;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _58 = _57 + 18446744073709550816;
  # PT = { D.3720 } (escaped)
  # ALIGN = 8, MISALIGN = 0
  _59 = &aD.3720 + _58;
  # VUSE <.MEM_111>
  _60 = *_59;
  # RANGE [0, 62] NONZERO 63
  _61 = i_107 + -37;
  # VUSE <.MEM_111>
  _62 = ran_uD.2900[_61];
  _63 = _60 + _62;
  _64 = (intD.9) _63;
  _65 = (doubleD.39) _64;
  _66 = _63 - _65;
  # .MEM_80 = VDEF <.MEM_111>
  ran_uD.2900[i_107] = _66;
  # RANGE [38, 100] NONZERO 127
  i_67 = i_107 + 1;
  # DEBUG iD.4282 => i_67
  # RANGE [2010, 2147483647] NONZERO 2147483647
  j_68 = j_108 + 1;
  # DEBUG jD.4283 => j_68
  # DEBUG jD.4283 => j_68
  # DEBUG iD.4282 => i_67
  if (i_67 > 99)
    goto <bb 18>;
  else
    goto <bb 17>;
;;    succ:       18 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                17 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 17, loop depth 2, count 0, freq 9800, maybe hot
;;    prev block 16, next block 18, flags: (NEW)
;;    pred:       16 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 16>;
;;    succ:       16 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 18, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 17, next block 19, flags: (NEW, REACHABLE)
;;    pred:       16 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # RANGE [1, 1009] NONZERO 1023
  m_12 = m_69 + 1;
  # DEBUG mD.3719 => m_12
  # DEBUG mD.3719 => m_12
  if (m_12 == 1009)
    goto <bb 20>;
  else
    goto <bb 19>;
;;    succ:       20 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                19 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 19, loop depth 1, count 0, freq 99, maybe hot
;;    prev block 18, next block 20, flags: (NEW)
;;    pred:       18 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 6>;
;;    succ:       6 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 20, loop depth 0, count 0, freq 1, maybe hot
;;    prev block 19, next block 1, flags: (NEW, REACHABLE)
;;    pred:       18 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # VUSE <.MEM_80>
  _13 = ran_uD.2900[0];
  # DEBUG __fmtD.3858 => "%.20f\n"
  # .MEM_16 = VDEF <.MEM_80>
  # USE = nonlocal null { D.3720 } (escaped)
  # CLB = nonlocal null { D.3720 } (escaped)
  __printf_chkD.1500 (1, "%.20f\n", _13);
  # .MEM_15 = VDEF <.MEM_16>
  aD.3720 ={v} {CLOBBER};
  # VUSE <.MEM_15>
  return 0;
;;    succ:       EXIT [100.0%] 

}


Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 2009
  bounds on difference of bases: 2008 ... 2008
  result:
    # of iterations 2008, bounded by 2008
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 2009
  bounds on difference of bases: 2008 ... 2008
  result:
    # of iterations 2008, bounded by 2008
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 2009
  bounds on difference of bases: 2008 ... 2008
  result:
    # of iterations 2008, bounded by 2008
Creating dr for ran_u[0]
analyze_innermost: success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 0
	aligned to: 256
	base_object: ran_u
	Access function 0: 0
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {800B, +, 8}_5
Analyzing # of iterations of loop 5
  exit condition [101, + , 1](no_overflow) <= 2008
  bounds on difference of bases: 1907 ... 1907
  result:
    # of iterations 1908, bounded by 1908
Analyzing # of iterations of loop 5
  exit condition [101, + , 1](no_overflow) <= 2008
  bounds on difference of bases: 1907 ... 1907
  result:
    # of iterations 1908, bounded by 1908
Creating dr for *_43
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_43
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_43
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_46
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for *_46
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for *_46
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for ran_u[i_105]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for ran_u[i_105]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for ran_u[i_105]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for *_43
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_43
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_43
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_46
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for *_46
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for *_46
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for ran_u[i_105]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for ran_u[i_105]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for ran_u[i_105]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Analyzing # of iterations of loop 4
  exit condition [1, + , 1](no_overflow) != 37
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Analyzing # of iterations of loop 4
  exit condition [1, + , 1](no_overflow) != 37
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Creating dr for *_59
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for *_59
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for *_59
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for ran_u[_61]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_3
Creating dr for ran_u[_61]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_3
Creating dr for ran_u[_61]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_3
Creating dr for ran_u[i_107]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_3
Creating dr for ran_u[i_107]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_3
Creating dr for ran_u[i_107]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_3
Creating dr for *_59
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for *_59
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for *_59
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for ran_u[_61]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_3
Creating dr for ran_u[_61]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_3
Creating dr for ran_u[_61]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_3
Creating dr for ran_u[i_107]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_3
Creating dr for ran_u[i_107]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_3
Creating dr for ran_u[i_107]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_3
Analyzing # of iterations of loop 3
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62
Analyzing # of iterations of loop 3
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62
Analyzing # of iterations of loop 2
  exit condition [1, + , 1](no_overflow) != 1009
  bounds on difference of bases: 1008 ... 1008
  result:
    # of iterations 1008, bounded by 1008
Analyzing # of iterations of loop 2
  exit condition [1, + , 1](no_overflow) != 1009
  bounds on difference of bases: 1008 ... 1008
  result:
    # of iterations 1008, bounded by 1008
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {800B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {800B, +, 8}_5
Analyzing # of iterations of loop 5
  exit condition [101, + , 1](no_overflow) <= 2008
  bounds on difference of bases: 1907 ... 1907
  result:
    # of iterations 1908, bounded by 1908
Creating dr for *_43
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_43
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_43
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_46
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for *_46
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for *_46
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for ran_u[i_105]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for ran_u[i_105]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for ran_u[i_105]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for *_43
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_43
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_43
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_46
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for *_46
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for *_46
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for ran_u[i_105]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for ran_u[i_105]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Creating dr for ran_u[i_105]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4
Analyzing # of iterations of loop 4
  exit condition [1, + , 1](no_overflow) != 37
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Creating dr for *_59
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for *_59
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for *_59
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for ran_u[_61]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_3
Creating dr for ran_u[_61]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_3
Creating dr for ran_u[_61]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_3
Creating dr for ran_u[i_107]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_3
Creating dr for ran_u[i_107]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_3
Creating dr for ran_u[i_107]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_3
Creating dr for *_59
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for *_59
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for *_59
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for ran_u[_61]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_3
Creating dr for ran_u[_61]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_3
Creating dr for ran_u[_61]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_3
Creating dr for ran_u[i_107]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_3
Creating dr for ran_u[i_107]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_3
Creating dr for ran_u[i_107]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_3
Analyzing # of iterations of loop 3
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62
Analyzing # of iterations of loop 2
  exit condition [1, + , 1](no_overflow) != 1009
  bounds on difference of bases: 1008 ... 1008
  result:
    # of iterations 1008, bounded by 1008
Creating dr for ran_u[0]
analyze_innermost: success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 0
	aligned to: 256
	base_object: ran_u
	Access function 0: 0

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:12, LOOPS:3, CONDITIONS:3, STMTS:62)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP statistics (BBS:1, LOOPS:0, CONDITIONS:0, STMTS:0)

Before limit_scops SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

number of SCoPs: 3

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:22)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:21)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

SCoP statistics (BBS:3, LOOPS:1, CONDITIONS:1, STMTS:19)

SCoP profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)

Global statistics (BBS:24, LOOPS:5, CONDITIONS:5, STMTS:89)

Global profiling statistics (BBS:0, LOOPS:0, CONDITIONS:0, STMTS:0)
Creating dr for *_43
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15272
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15272B, +, 8}_4
Creating dr for *_46
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15776
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15776B, +, 8}_4
Creating dr for ran_u[i_105]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_4

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 36; c1 += 1)
  S_13(c1);


Removing basic block 31
basic block 31, loop depth 1
 pred:      
goto <bb 29>;
 succ:       29



Updating SSA:
Registering new PHI nodes in block #28
Registering new PHI nodes in block #30
Registering new PHI nodes in block #13
Updating SSA information for statement ran_u[i_105] = _51;
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #16
Registering new PHI nodes in block #17
Registering new PHI nodes in block #18
Registering new PHI nodes in block #22
Registering new PHI nodes in block #19
Registering new PHI nodes in block #20
Registering new PHI nodes in block #21

DFA Statistics for int rng_double_main()

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                             83        664b
DEF operands                             45        360b
VUSE operands                            19        152b
VDEF operands                            10         80b
PHI nodes                                13       1352b
PHI arguments                            26       1248b
---------------------------------------------------------
Total memory used by DFA/SSA data                 3856b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_22 -> { .MEM_79 }
Incremental SSA update started at block: 28
Number of blocks in CFG: 32
Number of blocks to update: 8 ( 25%)
Affected blocks: 13 14 15 16 23 28 29 30


Applying pattern match.pd:397, generic-match.c:4039
Applying pattern match.pd:397, generic-match.c:4039
gimple_simplified to _133 = _159 + _165;

Updating SSA:
creating PHI node in block #33 for .MEM
creating PHI node in block #36 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Updating SSA information for statement ranf_start (310952);
Registering new PHI nodes in block #3
Updating SSA information for statement ranf_array.constprop (&a);
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #25
Updating SSA information for statement _9 = ran_u[0];
Updating SSA information for statement __printf_chk (1, "%.20f\n", _9);
Updating SSA information for statement ranf_start (310952);
Registering new PHI nodes in block #6
Updating SSA information for statement __builtin_memcpy (&a, &ran_u, 800);
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Updating SSA information for statement _29 = *_28;
Updating SSA information for statement _32 = *_31;
Updating SSA information for statement *_26 = _36;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #24
Registering new PHI nodes in block #28
Registering new PHI nodes in block #32
Registering new PHI nodes in block #36
Registering new PHI nodes in block #40
Updating SSA information for statement _165 = *_161;
Updating SSA information for statement _159 = *_134;
Updating SSA information for statement _133 = _159 + _165;
Updating SSA information for statement _132 = (int) _133;
Updating SSA information for statement _131 = (double) _132;
Updating SSA information for statement _130 = _133 - _131;
Updating SSA information for statement ran_u[_128] = _130;
Registering new PHI nodes in block #38
Registering new PHI nodes in block #37
Registering new PHI nodes in block #39
Registering new PHI nodes in block #34
Registering new PHI nodes in block #35
Registering new PHI nodes in block #33
Registering new PHI nodes in block #30
Registering new PHI nodes in block #13
Updating SSA information for statement _44 = *_43;
Updating SSA information for statement _47 = *_46;
Updating SSA information for statement _48 = _44 + _47;
Updating SSA information for statement _49 = (int) _48;
Updating SSA information for statement _50 = (double) _49;
Updating SSA information for statement _51 = _48 - _50;
Updating SSA information for statement ran_u[i_105] = _51;
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #16
Updating SSA information for statement _60 = *_59;
Updating SSA information for statement _62 = ran_u[_61];
Updating SSA information for statement ran_u[i_107] = _66;
Registering new PHI nodes in block #17
Registering new PHI nodes in block #18
Registering new PHI nodes in block #22
Registering new PHI nodes in block #19
Registering new PHI nodes in block #20
Registering new PHI nodes in block #21
Updating SSA information for statement _13 = ran_u[0];
Updating SSA information for statement __printf_chk (1, "%.20f\n", _13);
Updating SSA information for statement a ={v} {CLOBBER};
Updating SSA information for statement return 0;

DFA Statistics for int rng_double_main()

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            104        832b
DEF operands                             61        488b
VUSE operands                            22        176b
VDEF operands                            11         88b
PHI nodes                                16       1664b
PHI arguments                            32       1536b
---------------------------------------------------------
Total memory used by DFA/SSA data                 4784b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_129 -> { .MEM_79 }
_130 -> { _51 }
_131 -> { _50 }
_132 -> { _49 }
_133 -> { _48 }
_159 -> { _47 }
_165 -> { _44 }

Symbols to be put in SSA form
{ D.3849 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 41
Number of blocks to update: 37 ( 90%)
Affected blocks: 0 2 3 4 5 6 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 32 33 34 35 36 37 38 39 40



1 loops carried no dependency.
Creating dr for *_59
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 15568
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {15568B, +, 8}_3
Creating dr for ran_u[_61]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {0, +, 1}_3
Creating dr for ran_u[i_107]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &ran_u
	offset from base address: 0
	constant offset from base address: 296
	step: 8
	aligned to: 256
	base_object: ran_u
	Access function 0: {37, +, 1}_3
Analyzing # of iterations of loop 3
  exit condition [38, + , 1](no_overflow) <= 99
  bounds on difference of bases: 61 ... 61
  result:
    # of iterations 62, bounded by 62

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 62; c1 += 1)
  S_16(c1);


Removing basic block 46
basic block 46, loop depth 1
 pred:      
goto <bb 44>;
 succ:       44



Updating SSA:
Registering new PHI nodes in block #6
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #24
Registering new PHI nodes in block #28
Registering new PHI nodes in block #32
Registering new PHI nodes in block #36
Registering new PHI nodes in block #40
Registering new PHI nodes in block #38
Registering new PHI nodes in block #37
Registering new PHI nodes in block #39
Registering new PHI nodes in block #34
Registering new PHI nodes in block #35
Registering new PHI nodes in block #33
Registering new PHI nodes in block #30
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #43
Registering new PHI nodes in block #45
Registering new PHI nodes in block #16
Updating SSA information for statement ran_u[i_107] = _66;
Registering new PHI nodes in block #17
Registering new PHI nodes in block #18
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #41
Registering new PHI nodes in block #22
Registering new PHI nodes in block #19
Registering new PHI nodes in block #20
Registering new PHI nodes in block #21
Updating SSA information for statement _13 = ran_u[0];
Updating SSA information for statement __printf_chk (1, "%.20f\n", _13);

DFA Statistics for int rng_double_main()

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            104        832b
DEF operands                             61        488b
VUSE operands                            22        176b
VDEF operands                            11         88b
PHI nodes                                17       1768b
PHI arguments                            34       1632b
---------------------------------------------------------
Total memory used by DFA/SSA data                 4984b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_119 -> { .MEM_80 }
Incremental SSA update started at block: 6
Number of blocks in CFG: 47
Number of blocks to update: 9 ( 19%)
Affected blocks: 6 16 17 18 19 21 43 44 45


Applying pattern match.pd:397, generic-match.c:4039
gimple_simplified to _97 = _99 + _116;

Updating SSA:
creating PHI node in block #48 for .MEM
creating PHI node in block #51 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Updating SSA information for statement ranf_start (310952);
Registering new PHI nodes in block #3
Updating SSA information for statement ranf_array.constprop (&a);
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #25
Updating SSA information for statement _9 = ran_u[0];
Updating SSA information for statement __printf_chk (1, "%.20f\n", _9);
Updating SSA information for statement ranf_start (310952);
Registering new PHI nodes in block #6
Updating SSA information for statement __builtin_memcpy (&a, &ran_u, 800);
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Updating SSA information for statement _29 = *_28;
Updating SSA information for statement _32 = *_31;
Updating SSA information for statement *_26 = _36;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #24
Registering new PHI nodes in block #28
Registering new PHI nodes in block #32
Registering new PHI nodes in block #36
Registering new PHI nodes in block #40
Updating SSA information for statement _165 = *_161;
Updating SSA information for statement _159 = *_134;
Updating SSA information for statement ran_u[_128] = _130;
Registering new PHI nodes in block #38
Registering new PHI nodes in block #37
Registering new PHI nodes in block #39
Registering new PHI nodes in block #34
Registering new PHI nodes in block #35
Registering new PHI nodes in block #33
Registering new PHI nodes in block #30
Registering new PHI nodes in block #13
Updating SSA information for statement _44 = *_43;
Updating SSA information for statement _47 = *_46;
Updating SSA information for statement ran_u[i_105] = _51;
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #43
Registering new PHI nodes in block #47
Registering new PHI nodes in block #51
Registering new PHI nodes in block #55
Updating SSA information for statement _116 = *_112;
Updating SSA information for statement _99 = ran_u[_98];
Updating SSA information for statement _97 = _99 + _116;
Updating SSA information for statement _96 = (int) _97;
Updating SSA information for statement _95 = (double) _96;
Updating SSA information for statement _94 = _97 - _95;
Updating SSA information for statement ran_u[_91] = _94;
Registering new PHI nodes in block #53
Registering new PHI nodes in block #52
Registering new PHI nodes in block #54
Registering new PHI nodes in block #49
Registering new PHI nodes in block #50
Registering new PHI nodes in block #48
Registering new PHI nodes in block #45
Registering new PHI nodes in block #16
Updating SSA information for statement _60 = *_59;
Updating SSA information for statement _62 = ran_u[_61];
Updating SSA information for statement _63 = _60 + _62;
Updating SSA information for statement _64 = (int) _63;
Updating SSA information for statement _65 = (double) _64;
Updating SSA information for statement _66 = _63 - _65;
Updating SSA information for statement ran_u[i_107] = _66;
Registering new PHI nodes in block #17
Registering new PHI nodes in block #18
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #41
Registering new PHI nodes in block #22
Registering new PHI nodes in block #19
Registering new PHI nodes in block #20
Registering new PHI nodes in block #21
Updating SSA information for statement _13 = ran_u[0];
Updating SSA information for statement __printf_chk (1, "%.20f\n", _13);
Updating SSA information for statement a ={v} {CLOBBER};
Updating SSA information for statement return 0;

DFA Statistics for int rng_double_main()

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            123        984b
DEF operands                             75        600b
VUSE operands                            25        200b
VDEF operands                            12         96b
PHI nodes                                20       2080b
PHI arguments                            40       1920b
---------------------------------------------------------
Total memory used by DFA/SSA data                 5880b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_93 -> { .MEM_80 }
_94 -> { _66 }
_95 -> { _65 }
_96 -> { _64 }
_97 -> { _63 }
_99 -> { _62 }
_116 -> { _60 }

Symbols to be put in SSA form
{ D.3849 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 56
Number of blocks to update: 51 ( 91%)
Affected blocks: 0 2 3 4 5 6 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 32 33 34 35 36 37 38 39 40 41 42 43 44 45 47 48 49 50 51 52 53 54 55



1 loops carried no dependency.
Creating dr for *_28
analyze_innermost: success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {0B, +, 8}_5
Creating dr for *_31
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 504
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {504B, +, 8}_5
Creating dr for *_26
analyze_innermost: Applying pattern match.pd:49, generic-match.c:4015
success.
Applying pattern match.pd:49, generic-match.c:4015
	base_address: &a
	offset from base address: 0
	constant offset from base address: 800
	step: 8
	aligned to: 256
	base_object: MEM[(double *)&a]
	Access function 0: {800B, +, 8}_5
Analyzing # of iterations of loop 5
  exit condition [101, + , 1](no_overflow) <= 2008
  bounds on difference of bases: 1907 ... 1907
  result:
    # of iterations 1908, bounded by 1908

ISL AST generated by ISL: 
for (int c1 = 0; c1 <= 1908; c1 += 1)
  S_10(c1);


Removing basic block 61
basic block 61, loop depth 1
 pred:      
goto <bb 59>;
 succ:       59



Updating SSA:
Registering new PHI nodes in block #58
Registering new PHI nodes in block #60
Registering new PHI nodes in block #10
Updating SSA information for statement *_26 = _36;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #59
Registering new PHI nodes in block #57
Registering new PHI nodes in block #56
Registering new PHI nodes in block #24
Registering new PHI nodes in block #28
Registering new PHI nodes in block #32
Registering new PHI nodes in block #36
Registering new PHI nodes in block #40
Registering new PHI nodes in block #38
Registering new PHI nodes in block #37
Registering new PHI nodes in block #39
Registering new PHI nodes in block #34
Registering new PHI nodes in block #35
Registering new PHI nodes in block #33
Registering new PHI nodes in block #30
Registering new PHI nodes in block #13
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #43
Registering new PHI nodes in block #47
Registering new PHI nodes in block #51
Registering new PHI nodes in block #55
Registering new PHI nodes in block #53
Registering new PHI nodes in block #52
Registering new PHI nodes in block #54
Registering new PHI nodes in block #49
Registering new PHI nodes in block #50
Registering new PHI nodes in block #48
Registering new PHI nodes in block #45
Registering new PHI nodes in block #16
Registering new PHI nodes in block #17
Registering new PHI nodes in block #18
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #41
Registering new PHI nodes in block #22
Registering new PHI nodes in block #19
Registering new PHI nodes in block #20
Registering new PHI nodes in block #21

DFA Statistics for int rng_double_main()

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            123        984b
DEF operands                             75        600b
VUSE operands                            25        200b
VDEF operands                            12         96b
PHI nodes                                21       2184b
PHI arguments                            42       2016b
---------------------------------------------------------
Total memory used by DFA/SSA data                 6080b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_82 -> { .MEM_78 }
Incremental SSA update started at block: 58
Number of blocks in CFG: 62
Number of blocks to update: 12 ( 19%)
Affected blocks: 10 11 12 13 28 32 33 35 36 58 59 60


Applying pattern match.pd:397, generic-match.c:4039
gimple_simplified to _23 = _70 + _75;
Applying pattern match.pd:397, generic-match.c:4039

Updating SSA:
creating PHI node in block #63 for .MEM
creating PHI node in block #66 for .MEM
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Updating SSA information for statement ranf_start (310952);
Registering new PHI nodes in block #3
Updating SSA information for statement ranf_array.constprop (&a);
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #25
Updating SSA information for statement _9 = ran_u[0];
Updating SSA information for statement __printf_chk (1, "%.20f\n", _9);
Updating SSA information for statement ranf_start (310952);
Registering new PHI nodes in block #6
Updating SSA information for statement __builtin_memcpy (&a, &ran_u, 800);
Registering new PHI nodes in block #9
Registering new PHI nodes in block #58
Registering new PHI nodes in block #62
Registering new PHI nodes in block #66
Registering new PHI nodes in block #70
Updating SSA information for statement _75 = MEM[(double *)_72];
Updating SSA information for statement _70 = *_38;
Updating SSA information for statement _23 = _70 + _75;
Updating SSA information for statement _17 = (int) _23;
Updating SSA information for statement _11 = (double) _17;
Updating SSA information for statement _4 = _23 - _11;
Updating SSA information for statement *_168 = _4;
Registering new PHI nodes in block #68
Registering new PHI nodes in block #67
Registering new PHI nodes in block #69
Registering new PHI nodes in block #64
Registering new PHI nodes in block #65
Registering new PHI nodes in block #63
Registering new PHI nodes in block #60
Registering new PHI nodes in block #10
Updating SSA information for statement _29 = *_28;
Updating SSA information for statement _32 = *_31;
Updating SSA information for statement _33 = _29 + _32;
Updating SSA information for statement _34 = (int) _33;
Updating SSA information for statement _35 = (double) _34;
Updating SSA information for statement _36 = _33 - _35;
Updating SSA information for statement *_26 = _36;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #59
Registering new PHI nodes in block #57
Registering new PHI nodes in block #56
Registering new PHI nodes in block #24
Registering new PHI nodes in block #28
Registering new PHI nodes in block #32
Registering new PHI nodes in block #36
Registering new PHI nodes in block #40
Updating SSA information for statement _165 = *_161;
Updating SSA information for statement _159 = *_134;
Updating SSA information for statement ran_u[_128] = _130;
Registering new PHI nodes in block #38
Registering new PHI nodes in block #37
Registering new PHI nodes in block #39
Registering new PHI nodes in block #34
Registering new PHI nodes in block #35
Registering new PHI nodes in block #33
Registering new PHI nodes in block #30
Registering new PHI nodes in block #13
Updating SSA information for statement _44 = *_43;
Updating SSA information for statement _47 = *_46;
Updating SSA information for statement ran_u[i_105] = _51;
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #29
Registering new PHI nodes in block #27
Registering new PHI nodes in block #26
Registering new PHI nodes in block #23
Registering new PHI nodes in block #43
Registering new PHI nodes in block #47
Registering new PHI nodes in block #51
Registering new PHI nodes in block #55
Updating SSA information for statement _116 = *_112;
Updating SSA information for statement _99 = ran_u[_98];
Updating SSA information for statement ran_u[_91] = _94;
Registering new PHI nodes in block #53
Registering new PHI nodes in block #52
Registering new PHI nodes in block #54
Registering new PHI nodes in block #49
Registering new PHI nodes in block #50
Registering new PHI nodes in block #48
Registering new PHI nodes in block #45
Registering new PHI nodes in block #16
Updating SSA information for statement _60 = *_59;
Updating SSA information for statement _62 = ran_u[_61];
Updating SSA information for statement ran_u[i_107] = _66;
Registering new PHI nodes in block #17
Registering new PHI nodes in block #18
Registering new PHI nodes in block #44
Registering new PHI nodes in block #42
Registering new PHI nodes in block #41
Registering new PHI nodes in block #22
Registering new PHI nodes in block #19
Registering new PHI nodes in block #20
Registering new PHI nodes in block #21
Updating SSA information for statement _13 = ran_u[0];
Updating SSA information for statement __printf_chk (1, "%.20f\n", _13);
Updating SSA information for statement a ={v} {CLOBBER};
Updating SSA information for statement return 0;

DFA Statistics for int rng_double_main()

---------------------------------------------------------
                                Number of        Memory
                                instances         used 
---------------------------------------------------------
USE operands                            146       1168b
DEF operands                             93        744b
VUSE operands                            28        224b
VDEF operands                            13        104b
PHI nodes                                24       2496b
PHI arguments                            48       2304b
---------------------------------------------------------
Total memory used by DFA/SSA data                 7040b
---------------------------------------------------------

Average number of arguments per PHI node: 2.0 (max: 2)


Hash table statistics:
    var_infos:   size 61, 1 elements, 0.000000 collision/search ratio


SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_3 -> { .MEM_78 }
_4 -> { _36 }
_11 -> { _35 }
_17 -> { _34 }
_23 -> { _33 }
_70 -> { _32 }
_75 -> { _29 }

Symbols to be put in SSA form
{ D.3849 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 71
Number of blocks to update: 65 ( 92%)
Affected blocks: 0 2 3 4 5 6 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 32 33 34 35 36 37 38 39 40 41 42 43 44 45 47 48 49 50 51 52 53 54 55 56 57 58 59 60 62 63 64 65 66 67 68 69 70



1 loops carried no dependency.
Removing basic block 5
basic block 5, loop depth 0
 pred:      
 succ:       25


Merging blocks 6 and 9
Removing basic block 12
basic block 12, loop depth 1
 pred:      
goto <bb 59>;
 succ:       59


Removing basic block 15
basic block 15, loop depth 1
 pred:      
goto <bb 29>;
 succ:       29


Removing basic block 18
basic block 18, loop depth 1
 pred:      
goto <bb 44>;
 succ:       44


Removing basic block 20
basic block 20, loop depth 0
 pred:      
 succ:       21


Removing basic block 23
basic block 23, loop depth 1
 pred:      
 succ:       43


Removing basic block 24
basic block 24, loop depth 1
 pred:      
 succ:       28


Removing basic block 26
basic block 26, loop depth 1
 pred:      
 succ:       43


Removing basic block 27
basic block 27, loop depth 1
 pred:      
goto <bb 43>;
 succ:       43


Removing basic block 14
basic block 14, loop depth 2
 pred:       13
goto <bb 13>;
 succ:       13


Removing basic block 13
basic block 13, loop depth 2
 pred:       28
# i_105 = PHI <0(28)>
# j_106 = PHI <2009(28)>
# DEBUG j => j_106
# DEBUG i => i_105
_40 = (long unsigned int) j_106;
_41 = _40 * 8;
_42 = _41 + 18446744073709550816;
_43 = &a + _42;
_44 = *_43;
_45 = _41 + 18446744073709551320;
_46 = &a + _45;
_47 = *_46;
_48 = _44 + _47;
_49 = (int) _48;
_50 = (double) _49;
_51 = _48 - _50;
ran_u[i_105] = _51;
i_52 = i_105 + 1;
# DEBUG i => i_52
j_53 = j_106 + 1;
# DEBUG j => j_53
# DEBUG j => j_53
# DEBUG i => i_52
if (i_52 == 37)
 succ:       29


Removing basic block 28
basic block 28, loop depth 1
 pred:      
 succ:       32


Removing basic block 30
basic block 30, loop depth 1
 pred:      
 succ:       29


Removing basic block 35
basic block 35, loop depth 1
 pred:       32
goto <bb 33>;
 succ:       33


Removing basic block 34
basic block 34, loop depth 1
 pred:      
 succ:       33


Merging blocks 36 and 40
Removing basic block 39
basic block 39, loop depth 1
 pred:      
 succ:       33


Removing basic block 41
basic block 41, loop depth 1
 pred:      
 succ:       22


Removing basic block 42
basic block 42, loop depth 1
 pred:      
goto <bb 22>;
 succ:       22


Removing basic block 17
basic block 17, loop depth 2
 pred:       16
goto <bb 16>;
 succ:       16


Removing basic block 16
basic block 16, loop depth 2
 pred:       43
# i_107 = PHI <37(43)>
# j_108 = PHI <2046(43)>
# DEBUG j => j_108
# DEBUG i => i_107
_56 = (long unsigned int) j_108;
_57 = _56 * 8;
_58 = _57 + 18446744073709550816;
_59 = &a + _58;
_60 = *_59;
_61 = i_107 + -37;
_62 = ran_u[_61];
_63 = _60 + _62;
_64 = (int) _63;
_65 = (double) _64;
_66 = _63 - _65;
ran_u[i_107] = _66;
i_67 = i_107 + 1;
# DEBUG i => i_67
j_68 = j_108 + 1;
# DEBUG j => j_68
# DEBUG j => j_68
# DEBUG i => i_67
if (i_67 > 99)
 succ:       44


Removing basic block 43
basic block 43, loop depth 1
 pred:      
 succ:       47


Removing basic block 45
basic block 45, loop depth 1
 pred:      
 succ:       44


Removing basic block 50
basic block 50, loop depth 1
 pred:       47
goto <bb 48>;
 succ:       48


Removing basic block 49
basic block 49, loop depth 1
 pred:      
 succ:       48


Merging blocks 51 and 55
Removing basic block 54
basic block 54, loop depth 1
 pred:      
 succ:       48


Removing basic block 56
basic block 56, loop depth 1
 pred:      
 succ:       32


Removing basic block 57
basic block 57, loop depth 1
 pred:      
goto <bb 32>;
 succ:       32


Removing basic block 11
basic block 11, loop depth 2
 pred:       10
goto <bb 10>;
 succ:       10


Removing basic block 10
basic block 10, loop depth 2
 pred:       58
# j_104 = PHI <100(58)>
# DEBUG j => j_104
_24 = (long unsigned int) j_104;
_25 = _24 * 8;
_26 = &a + _25;
_27 = _25 + 18446744073709550816;
_28 = &a + _27;
_29 = *_28;
_30 = _25 + 18446744073709551320;
_31 = &a + _30;
_32 = *_31;
_33 = _29 + _32;
_34 = (int) _33;
_35 = (double) _34;
_36 = _33 - _35;
*_26 = _36;
j_37 = j_104 + 1;
# DEBUG j => j_37
# DEBUG j => j_37
if (j_37 > 2008)
 succ:       59


Removing basic block 58
basic block 58, loop depth 1
 pred:      
 succ:       62


Removing basic block 60
basic block 60, loop depth 1
 pred:      
 succ:       59


Removing basic block 65
basic block 65, loop depth 1
 pred:       62
goto <bb 63>;
 succ:       63


Removing basic block 64
basic block 64, loop depth 1
 pred:      
 succ:       63


Merging blocks 66 and 70
Removing basic block 69
basic block 69, loop depth 1
 pred:      
 succ:       63


Merging blocks 6 and 62
Merging blocks 33 and 29
Merging blocks 33 and 47
Merging blocks 36 and 38
Merging blocks 48 and 44
Merging blocks 48 and 22
Merging blocks 51 and 53
Merging blocks 63 and 59
Merging blocks 63 and 32
Merging blocks 66 and 68
fix_loop_structure: removing loop 3
fix_loop_structure: removing loop 4
fix_loop_structure: removing loop 5
Analyzing # of iterations of loop 2
  exit condition [1, + , 1](no_overflow) != 1009
  bounds on difference of bases: 1008 ... 1008
  result:
    # of iterations 1008, bounded by 1008
Analyzing # of iterations of loop 8
  exit condition [0, + , 1](no_overflow) < 62
  bounds on difference of bases: 62 ... 62
  result:
    # of iterations 62, bounded by 62
Analyzing # of iterations of loop 7
  exit condition [0, + , 1](no_overflow) < 36
  bounds on difference of bases: 36 ... 36
  result:
    # of iterations 36, bounded by 36
Analyzing # of iterations of loop 9
  exit condition [0, + , 1](no_overflow) < 1908
  bounds on difference of bases: 1908 ... 1908
  result:
    # of iterations 1908, bounded by 1908
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 2009
  bounds on difference of bases: 2008 ... 2008
  result:
    # of iterations 2008, bounded by 2008
1 edges in bb 2 predicted to even probabilities
Predictions for bb 3
  DS theory heuristics (ignored): 0.4%
  first match heuristics: 1.0%
  combined heuristics: 1.0%
  opcode values nonequal (on trees) heuristics (ignored): 28.0%
  loop iterations heuristics: 1.0%
1 edges in bb 4 predicted to even probabilities
1 edges in bb 5 predicted to even probabilities
1 edges in bb 6 predicted to even probabilities
Predictions for bb 7
  DS theory heuristics (ignored): 99.0%
  first match heuristics: 99.0%
  combined heuristics: 99.0%
  loop iterations heuristics: 99.0%
1 edges in bb 8 predicted to even probabilities
1 edges in bb 9 predicted to even probabilities
Predictions for bb 10
  DS theory heuristics (ignored): 97.3%
  first match heuristics: 97.3%
  combined heuristics: 97.3%
  loop iterations heuristics: 97.3%
1 edges in bb 11 predicted to even probabilities
1 edges in bb 12 predicted to even probabilities
Predictions for bb 13
  DS theory heuristics (ignored): 98.4%
  first match heuristics: 98.4%
  combined heuristics: 98.4%
  loop iterations heuristics: 98.4%
1 edges in bb 14 predicted to even probabilities
Predictions for bb 15
  DS theory heuristics (ignored): 0.2%
  first match heuristics: 1.0%
  combined heuristics: 1.0%
  opcode values nonequal (on trees) heuristics (ignored): 28.0%
  early return (on trees) heuristics (ignored): 39.0%
  loop iterations heuristics: 1.0%
1 edges in bb 16 predicted to even probabilities
1 edges in bb 17 predicted to even probabilities
loop_0 (header = 0, latch = 1, niter = )
{
  bb_2 (preds = {bb_0 }, succs = {bb_3 })
  {
    <bb 2>:
    # .MEM_6 = VDEF <.MEM_5(D)>
    ranf_start (310952);
    # DEBUG m => 0
    # DEBUG m => 0

  }
  bb_5 (preds = {bb_3 }, succs = {bb_6 })
  {
    <bb 5>:
    # VUSE <.MEM_7>
    _9 = ran_u[0];
    # DEBUG __fmt => "%.20f\n"
    # .MEM_14 = VDEF <.MEM_7>
    __printf_chk (1, "%.20f\n", _9);
    # .MEM_10 = VDEF <.MEM_14>
    ranf_start (310952);
    # DEBUG m => 0
    # DEBUG m => 0

  }
  bb_17 (preds = {bb_15 }, succs = {bb_1 })
  {
    <bb 17>:
    # VUSE <.MEM_90>
    _13 = ran_u[0];
    # DEBUG __fmt => "%.20f\n"
    # .MEM_16 = VDEF <.MEM_90>
    __printf_chk (1, "%.20f\n", _13);
    # .MEM_15 = VDEF <.MEM_16>
    a ={v} {CLOBBER};
    # VUSE <.MEM_15>
    return 0;

  }
  loop_2 (header = 6, latch = 16, niter = , upper_bound = 1008, estimate = 1008)
  {
    bb_6 (preds = {bb_16 bb_5 }, succs = {bb_7 })
    {
      <bb 6>:
      # m_69 = PHI <m_12(16), 0(5)>
      # .MEM_101 = PHI <.MEM_90(16), .MEM_10(5)>
      # DEBUG m => m_69
      # DEBUG j => 0
      # .MEM_103 = VDEF <.MEM_101>
      __builtin_memcpy (&a, &ran_u, 800);

    }
    bb_9 (preds = {bb_7 }, succs = {bb_10 })
    {
      <bb 9>:
      # .MEM_160 = PHI <.MEM_3(7)>

    }
    bb_12 (preds = {bb_10 }, succs = {bb_13 })
    {
      <bb 12>:
      # .MEM_127 = PHI <.MEM_129(10)>

    }
    bb_15 (preds = {bb_13 }, succs = {bb_17 bb_16 })
    {
      <bb 15>:
      # .MEM_90 = PHI <.MEM_93(13)>
      m_12 = m_69 + 1;
      # DEBUG m => m_12
      # DEBUG m => m_12
      if (m_12 == 1009)
        goto <bb 17>;
      else
        goto <bb 16>;

    }
    bb_16 (preds = {bb_15 }, succs = {bb_6 })
    {
      <bb 16>:
      goto <bb 6>;

    }
    loop_8 (header = 13, latch = 14, niter = )
    {
      bb_13 (preds = {bb_12 bb_14 }, succs = {bb_14 bb_15 })
      {
        <bb 13>:
        # graphite_IV.308_118 = PHI <0(12), graphite_IV.308_117(14)>
        # .MEM_89 = PHI <.MEM_127(12), .MEM_93(14)>
        # DEBUG j => NULL
        # DEBUG i => NULL
        _115 = (sizetype) graphite_IV.308_118;
        _114 = _115 + 1946;
        _113 = _114 * 8;
        _112 = &a + _113;
        # VUSE <.MEM_89>
        _116 = *_112;
        _98 = (int) graphite_IV.308_118;
        # VUSE <.MEM_89>
        _99 = ran_u[_98];
        _97 = _99 + _116;
        _96 = (int) _97;
        _95 = (double) _96;
        _94 = _97 - _95;
        _92 = (int) graphite_IV.308_118;
        _91 = _92 + 37;
        # .MEM_93 = VDEF <.MEM_89>
        ran_u[_91] = _94;
        # DEBUG i => NULL
        # DEBUG j => NULL
        # DEBUG j => NULL
        # DEBUG i => NULL
        graphite_IV.308_117 = graphite_IV.308_118 + 1;
        if (graphite_IV.308_118 < 62)
          goto <bb 14>;
        else
          goto <bb 15>;

      }
      bb_14 (preds = {bb_13 }, succs = {bb_13 })
      {
        <bb 14>:
        goto <bb 13>;

      }
    }
    loop_7 (header = 10, latch = 11, niter = )
    {
      bb_10 (preds = {bb_9 bb_11 }, succs = {bb_11 bb_12 })
      {
        <bb 10>:
        # graphite_IV.307_167 = PHI <0(9), graphite_IV.307_166(11)>
        # .MEM_126 = PHI <.MEM_160(9), .MEM_129(11)>
        # DEBUG j => NULL
        # DEBUG i => NULL
        _164 = (sizetype) graphite_IV.307_167;
        _163 = _164 + 1909;
        _162 = _163 * 8;
        _161 = &a + _162;
        # VUSE <.MEM_126>
        _165 = *_161;
        _158 = (sizetype) graphite_IV.307_167;
        _142 = _158 + 1972;
        _141 = _142 * 8;
        _134 = &a + _141;
        # VUSE <.MEM_126>
        _159 = *_134;
        _133 = _159 + _165;
        _132 = (int) _133;
        _131 = (double) _132;
        _130 = _133 - _131;
        _128 = (int) graphite_IV.307_167;
        # .MEM_129 = VDEF <.MEM_126>
        ran_u[_128] = _130;
        # DEBUG i => NULL
        # DEBUG j => NULL
        # DEBUG j => NULL
        # DEBUG i => NULL
        graphite_IV.307_166 = graphite_IV.307_167 + 1;
        if (graphite_IV.307_167 < 36)
          goto <bb 11>;
        else
          goto <bb 12>;

      }
      bb_11 (preds = {bb_10 }, succs = {bb_10 })
      {
        <bb 11>:
        goto <bb 10>;

      }
    }
    loop_9 (header = 7, latch = 8, niter = )
    {
      bb_7 (preds = {bb_6 bb_8 }, succs = {bb_8 bb_9 })
      {
        <bb 7>:
        # graphite_IV.309_81 = PHI <0(6), graphite_IV.309_76(8)>
        # .MEM_157 = PHI <.MEM_103(6), .MEM_3(8)>
        # DEBUG j => NULL
        _74 = (sizetype) graphite_IV.309_81;
        _73 = _74 * 8;
        _72 = &a + _73;
        # VUSE <.MEM_157>
        _75 = MEM[(double *)_72];
        _55 = (sizetype) graphite_IV.309_81;
        _54 = _55 + 63;
        _39 = _54 * 8;
        _38 = &a + _39;
        # VUSE <.MEM_157>
        _70 = *_38;
        _23 = _70 + _75;
        _17 = (int) _23;
        _11 = (double) _17;
        _4 = _23 - _11;
        _2 = (sizetype) graphite_IV.309_81;
        _1 = _2 + 100;
        _169 = _1 * 8;
        _168 = &a + _169;
        # .MEM_3 = VDEF <.MEM_157>
        *_168 = _4;
        # DEBUG j => NULL
        # DEBUG j => NULL
        graphite_IV.309_76 = graphite_IV.309_81 + 1;
        if (graphite_IV.309_81 < 1908)
          goto <bb 8>;
        else
          goto <bb 9>;

      }
      bb_8 (preds = {bb_7 }, succs = {bb_7 })
      {
        <bb 8>:
        goto <bb 7>;

      }
    }
  }
  loop_1 (header = 3, latch = 4, niter = , upper_bound = 2008, estimate = 2008)
  {
    bb_3 (preds = {bb_4 bb_2 }, succs = {bb_5 bb_4 })
    {
      <bb 3>:
      # m_71 = PHI <m_8(4), 0(2)>
      # .MEM_100 = PHI <.MEM_7(4), .MEM_6(2)>
      # DEBUG m => m_71
      # .MEM_7 = VDEF <.MEM_100>
      ranf_array.constprop (&a);
      m_8 = m_71 + 1;
      # DEBUG m => m_8
      # DEBUG m => m_8
      if (m_8 == 2009)
        goto <bb 5>;
      else
        goto <bb 4>;

    }
    bb_4 (preds = {bb_3 }, succs = {bb_3 })
    {
      <bb 4>:
      goto <bb 3>;

    }
  }
}

Pass statistics:
----------------

int rng_double_main() ()
{
  signed long graphite_IV.309D.4307;
  doubleD.39 D.4306;
  doubleD.39 D.4305;
  intD.9 D.4304;
  doubleD.39 D.4303;
  doubleD.39 D.4302;
  doubleD.39 D.4301;
  signed long graphite_IV.308D.4300;
  doubleD.39 D.4299;
  doubleD.39 D.4298;
  intD.9 D.4297;
  doubleD.39 D.4296;
  doubleD.39 D.4295;
  doubleD.39 D.4294;
  signed long graphite_IV.307D.4293;
  doubleD.39 D.4292;
  doubleD.39 D.4291;
  intD.9 D.4290;
  doubleD.39 D.4289;
  doubleD.39 D.4288;
  doubleD.39 D.4287;
  register intD.9 jD.4283;
  register intD.9 iD.4282;
  doubleD.39 aD.3720[2009];
  register intD.9 mD.3719;
  sizetype _1;
  sizetype _2;
  doubleD.39 _4;
  doubleD.39 _9;
  doubleD.39 _11;
  doubleD.39 _13;
  intD.9 _17;
  doubleD.39 _23;
  doubleD.39 * _38;
  sizetype _39;
  sizetype _54;
  sizetype _55;
  doubleD.39 _70;
  doubleD.39[2009] * _72;
  sizetype _73;
  sizetype _74;
  doubleD.39 _75;
  intD.9 _91;
  intD.9 _92;
  doubleD.39 _94;
  doubleD.39 _95;
  intD.9 _96;
  doubleD.39 _97;
  intD.9 _98;
  doubleD.39 _99;
  doubleD.39 * _112;
  sizetype _113;
  sizetype _114;
  sizetype _115;
  doubleD.39 _116;
  intD.9 _128;
  doubleD.39 _130;
  doubleD.39 _131;
  intD.9 _132;
  doubleD.39 _133;
  doubleD.39 * _134;
  sizetype _141;
  sizetype _142;
  sizetype _158;
  doubleD.39 _159;
  doubleD.39 * _161;
  sizetype _162;
  sizetype _163;
  sizetype _164;
  doubleD.39 _165;
  doubleD.39 * _168;
  sizetype _169;

;;   basic block 2, loop depth 0, count 0, freq 1, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY [100.0%]  (FALLTHRU,EXECUTABLE)
  # .MEM_6 = VDEF <.MEM_5(D)>
  # USE = nonlocal null { D.3720 } (escaped)
  # CLB = nonlocal null { D.3720 } (escaped)
  _Z10ranf_startlD.2920 (310952);
  # DEBUG mD.3719 => 0
  # DEBUG mD.3719 => 0
;;    succ:       3 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 3, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 2, next block 4, flags: (NEW, REACHABLE)
;;    pred:       4 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                2 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 2009] NONZERO 2047
  # m_71 = PHI <m_8(4), 0(2)>
  # .MEM_100 = PHI <.MEM_7(4), .MEM_6(2)>
  # DEBUG mD.3719 => m_71
  # .MEM_7 = VDEF <.MEM_100>
  # USE = nonlocal null { D.3720 } (escaped)
  # CLB = nonlocal null { D.3720 } (escaped)
  _Z10ranf_arrayPdi.constprop.0D.3862 (&aD.3720);
  # RANGE [1, 2009] NONZERO 2047
  m_8 = m_71 + 1;
  # DEBUG mD.3719 => m_8
  # DEBUG mD.3719 => m_8
  if (m_8 == 2009)
    goto <bb 5>;
  else
    goto <bb 4>;
;;    succ:       5 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                4 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 4, loop depth 1, count 0, freq 99, maybe hot
;;    prev block 3, next block 5, flags: (NEW)
;;    pred:       3 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 5, loop depth 0, count 0, freq 1, maybe hot
;;    prev block 4, next block 6, flags: (NEW)
;;    pred:       3 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # VUSE <.MEM_7>
  _9 = ran_uD.2900[0];
  # DEBUG __fmtD.3856 => "%.20f\n"
  # .MEM_14 = VDEF <.MEM_7>
  # USE = nonlocal null { D.3720 } (escaped)
  # CLB = nonlocal null { D.3720 } (escaped)
  __printf_chkD.1500 (1, "%.20f\n", _9);
  # .MEM_10 = VDEF <.MEM_14>
  # USE = nonlocal null { D.3720 } (escaped)
  # CLB = nonlocal null { D.3720 } (escaped)
  _Z10ranf_startlD.2920 (310952);
  # DEBUG mD.3719 => 0
  # DEBUG mD.3719 => 0
;;    succ:       6 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 6, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 5, next block 7, flags: (NEW, REACHABLE)
;;    pred:       16 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
;;                5 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 1009] NONZERO 1023
  # m_69 = PHI <m_12(16), 0(5)>
  # .MEM_101 = PHI <.MEM_90(16), .MEM_10(5)>
  # DEBUG mD.3719 => m_69
  # DEBUG jD.4283 => 0
  # .MEM_103 = VDEF <.MEM_101>
  # USE = anything 
  # CLB = anything 
  memcpyD.992 (&aD.3720, &ran_uD.2900, 800);
;;    succ:       7 [100.0%]  (FALLTHRU)

;;   basic block 7, loop depth 2, count 0, freq 10000, maybe hot
;;    prev block 6, next block 8, flags: (NEW)
;;    pred:       6 [100.0%]  (FALLTHRU)
;;                8 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.309_81 = PHI <0(6), graphite_IV.309_76(8)>
  # .MEM_157 = PHI <.MEM_103(6), .MEM_3(8)>
  # DEBUG jD.4283 => NULL
  _74 = (sizetype) graphite_IV.309_81;
  _73 = _74 * 8;
  _72 = &aD.3720 + _73;
  # VUSE <.MEM_157>
  _75 = MEM[(doubleD.39 *)_72];
  _55 = (sizetype) graphite_IV.309_81;
  _54 = _55 + 63;
  _39 = _54 * 8;
  _38 = &aD.3720 + _39;
  # VUSE <.MEM_157>
  _70 = *_38;
  _23 = _70 + _75;
  _17 = (intD.9) _23;
  _11 = (doubleD.39) _17;
  _4 = _23 - _11;
  _2 = (sizetype) graphite_IV.309_81;
  _1 = _2 + 100;
  _169 = _1 * 8;
  _168 = &aD.3720 + _169;
  # .MEM_3 = VDEF <.MEM_157>
  *_168 = _4;
  # DEBUG jD.4283 => NULL
  # DEBUG jD.4283 => NULL
  graphite_IV.309_76 = graphite_IV.309_81 + 1;
  if (graphite_IV.309_81 < 1908)
    goto <bb 8>;
  else
    goto <bb 9>;
;;    succ:       8 [99.0%]  (TRUE_VALUE)
;;                9 [1.0%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 8, loop depth 2, count 0, freq 9900, maybe hot
;;    prev block 7, next block 9, flags: (NEW)
;;    pred:       7 [99.0%]  (TRUE_VALUE)
  goto <bb 7>;
;;    succ:       7 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 9, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 8, next block 10, flags: (NEW)
;;    pred:       7 [1.0%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_160 = PHI <.MEM_3(7)>
;;    succ:       10 [100.0%]  (FALLTHRU)

;;   basic block 10, loop depth 2, count 0, freq 3704, maybe hot
;;    prev block 9, next block 11, flags: (NEW)
;;    pred:       9 [100.0%]  (FALLTHRU)
;;                11 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.307_167 = PHI <0(9), graphite_IV.307_166(11)>
  # .MEM_126 = PHI <.MEM_160(9), .MEM_129(11)>
  # DEBUG jD.4283 => NULL
  # DEBUG iD.4282 => NULL
  _164 = (sizetype) graphite_IV.307_167;
  _163 = _164 + 1909;
  _162 = _163 * 8;
  _161 = &aD.3720 + _162;
  # VUSE <.MEM_126>
  _165 = *_161;
  _158 = (sizetype) graphite_IV.307_167;
  _142 = _158 + 1972;
  _141 = _142 * 8;
  _134 = &aD.3720 + _141;
  # VUSE <.MEM_126>
  _159 = *_134;
  _133 = _159 + _165;
  _132 = (intD.9) _133;
  _131 = (doubleD.39) _132;
  _130 = _133 - _131;
  _128 = (intD.9) graphite_IV.307_167;
  # .MEM_129 = VDEF <.MEM_126>
  ran_uD.2900[_128] = _130;
  # DEBUG iD.4282 => NULL
  # DEBUG jD.4283 => NULL
  # DEBUG jD.4283 => NULL
  # DEBUG iD.4282 => NULL
  graphite_IV.307_166 = graphite_IV.307_167 + 1;
  if (graphite_IV.307_167 < 36)
    goto <bb 11>;
  else
    goto <bb 12>;
;;    succ:       11 [97.3%]  (TRUE_VALUE)
;;                12 [2.7%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 11, loop depth 2, count 0, freq 3604, maybe hot
;;    prev block 10, next block 12, flags: (NEW)
;;    pred:       10 [97.3%]  (TRUE_VALUE)
  goto <bb 10>;
;;    succ:       10 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 12, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 11, next block 13, flags: (NEW)
;;    pred:       10 [2.7%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_127 = PHI <.MEM_129(10)>
;;    succ:       13 [100.0%]  (FALLTHRU)

;;   basic block 13, loop depth 2, count 0, freq 6289, maybe hot
;;    prev block 12, next block 14, flags: (NEW)
;;    pred:       12 [100.0%]  (FALLTHRU)
;;                14 [100.0%]  (FALLTHRU,DFS_BACK)
  # graphite_IV.308_118 = PHI <0(12), graphite_IV.308_117(14)>
  # .MEM_89 = PHI <.MEM_127(12), .MEM_93(14)>
  # DEBUG jD.4283 => NULL
  # DEBUG iD.4282 => NULL
  _115 = (sizetype) graphite_IV.308_118;
  _114 = _115 + 1946;
  _113 = _114 * 8;
  _112 = &aD.3720 + _113;
  # VUSE <.MEM_89>
  _116 = *_112;
  _98 = (intD.9) graphite_IV.308_118;
  # VUSE <.MEM_89>
  _99 = ran_uD.2900[_98];
  _97 = _99 + _116;
  _96 = (intD.9) _97;
  _95 = (doubleD.39) _96;
  _94 = _97 - _95;
  _92 = (intD.9) graphite_IV.308_118;
  _91 = _92 + 37;
  # .MEM_93 = VDEF <.MEM_89>
  ran_uD.2900[_91] = _94;
  # DEBUG iD.4282 => NULL
  # DEBUG jD.4283 => NULL
  # DEBUG jD.4283 => NULL
  # DEBUG iD.4282 => NULL
  graphite_IV.308_117 = graphite_IV.308_118 + 1;
  if (graphite_IV.308_118 < 62)
    goto <bb 14>;
  else
    goto <bb 15>;
;;    succ:       14 [98.4%]  (TRUE_VALUE)
;;                15 [1.6%]  (FALSE_VALUE,LOOP_EXIT)

;;   basic block 14, loop depth 2, count 0, freq 6189, maybe hot
;;    prev block 13, next block 15, flags: (NEW)
;;    pred:       13 [98.4%]  (TRUE_VALUE)
  goto <bb 13>;
;;    succ:       13 [100.0%]  (FALLTHRU,DFS_BACK)

;;   basic block 15, loop depth 1, count 0, freq 100, maybe hot
;;    prev block 14, next block 16, flags: (NEW)
;;    pred:       13 [1.6%]  (FALSE_VALUE,LOOP_EXIT)
  # .MEM_90 = PHI <.MEM_93(13)>
  # RANGE [1, 1009] NONZERO 1023
  m_12 = m_69 + 1;
  # DEBUG mD.3719 => m_12
  # DEBUG mD.3719 => m_12
  if (m_12 == 1009)
    goto <bb 17>;
  else
    goto <bb 16>;
;;    succ:       17 [1.0%]  (TRUE_VALUE,EXECUTABLE)
;;                16 [99.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 16, loop depth 1, count 0, freq 99, maybe hot
;;    prev block 15, next block 17, flags: (NEW)
;;    pred:       15 [99.0%]  (FALSE_VALUE,EXECUTABLE)
  goto <bb 6>;
;;    succ:       6 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 17, loop depth 0, count 0, freq 1, maybe hot
;;    prev block 16, next block 1, flags: (NEW)
;;    pred:       15 [1.0%]  (TRUE_VALUE,EXECUTABLE)
  # VUSE <.MEM_90>
  _13 = ran_uD.2900[0];
  # DEBUG __fmtD.3858 => "%.20f\n"
  # .MEM_16 = VDEF <.MEM_90>
  # USE = nonlocal null { D.3720 } (escaped)
  # CLB = nonlocal null { D.3720 } (escaped)
  __printf_chkD.1500 (1, "%.20f\n", _13);
  # .MEM_15 = VDEF <.MEM_16>
  aD.3720 ={v} {CLOBBER};
  # VUSE <.MEM_15>
  return 0;
;;    succ:       EXIT [100.0%] 

}



;; Function <built-in> (void_ranf_array_double___int_._loopfn.0, funcdef_no=37, decl_uid=3908, cgraph_uid=4, symbol_order=46)


Pass statistics:
----------------


Pass statistics:
----------------

<built-in> (voidD.45 * .paral_data_paramD.3910)
{
  signed long graphite_IV.18D.3918;
  unsigned long tt.24D.3917;
  unsigned long q.23D.3916;
  doubleD.39 * aa.19D.3915;
  struct  * .paral_data_load.22D.3914;
  doubleD.39[100] * ran_u_5;
  intD.9 _6;
  unsigned long _7;
  intD.9 _8;
  unsigned long _9;
  unsigned long _16;
  unsigned long _17;
  unsigned long _18;
  unsigned long ivtmp_20;
  unsigned long ivtmp_21;
  sizetype _26;
  sizetype _27;
  doubleD.39 * _28;
  doubleD.39 _29;
  sizetype _31;
  sizetype _32;
  doubleD.39 * _33;
  doubleD.39 _34;
  doubleD.39 _35;
  intD.9 _36;
  doubleD.39 _37;
  doubleD.39 _38;
  intD.9 _39;

;;   basic block 2, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY (FALLTHRU,EXECUTABLE)
  # VUSE <.MEM_44(D)>
  # PT = nonlocal escaped 
  aa.19_4 = MEM[(struct  *).paral_data_param_1(D)].aaD.3904;
  # VUSE <.MEM_44(D)>
  # PT = nonlocal escaped 
  ran_u_5 = MEM[(struct  *).paral_data_param_1(D)].ran_uD.3905;
  _6 = omp_get_num_threadsD.1718 ();
  # RANGE ~[2147483648, 18446744071562067967]
  _7 = (unsigned long) _6;
  _8 = omp_get_thread_numD.1717 ();
  # RANGE ~[2147483648, 18446744071562067967]
  _9 = (unsigned long) _8;
  # RANGE [0, 36] NONZERO 63
  q.23_10 = 36 / _7;
  # RANGE [0, 18446744073709551615]
  tt.24_11 = 36 % _7;
  if (_9 < tt.24_11)
    goto <bb 9>;
  else
    goto <bb 3>;
;;    succ:       9 [25.0%]  (TRUE_VALUE,EXECUTABLE)
;;                3 [75.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 3, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 2, next block 4, flags: (NEW, REACHABLE)
;;    pred:       9 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                2 [75.0%]  (FALSE_VALUE,EXECUTABLE)
  # RANGE [0, 37] NONZERO 63
  # q.23_12 = PHI <q.23_13(9), q.23_10(2)>
  # tt.24_14 = PHI <0(9), tt.24_11(2)>
  # RANGE ~[79456894940, 18446743994252656639]
  _16 = _9 * q.23_12;
  # RANGE [0, 18446744073709551615]
  _17 = tt.24_14 + _16;
  # RANGE [0, 18446744073709551615]
  _18 = q.23_12 + _17;
  if (_17 >= _18)
    goto <bb 4>;
  else
    goto <bb 5>;
;;    succ:       5 [100.0%]  (FALSE_VALUE,EXECUTABLE)
;;                4 (TRUE_VALUE,EXECUTABLE)

;;   basic block 4, loop depth 0, count 0, freq 0, maybe hot
;;    prev block 3, next block 5, flags: (NEW, REACHABLE)
;;    pred:       3 (TRUE_VALUE,EXECUTABLE)
;;                7 [100.0%]  (FALLTHRU,EXECUTABLE)
  # .MEM_76 = PHI <.MEM_44(D)(3), .MEM_43(7)>
  # VUSE <.MEM_76>
  return;
;;    succ:       EXIT

;;   basic block 5, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 4, next block 6, flags: (NEW)
;;    pred:       3 [100.0%]  (FALSE_VALUE,EXECUTABLE)
;;    succ:       6 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 6, loop depth 1, count 0, freq 2963, maybe hot
;;    prev block 5, next block 7, flags: (NEW)
;;    pred:       5 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                8 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [0, 18446744073709551614]
  # ivtmp_20 = PHI <_17(5), ivtmp_21(8)>
  # .MEM_42 = PHI <.MEM_44(D)(5), .MEM_45(8)>
  # RANGE ~[908, 908]
  _26 = ivtmp_20 + 909;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _27 = _26 * 8;
  # PT = nonlocal escaped 
  _28 = aa.19_4 + _27;
  # VUSE <.MEM_42>
  _29 = *_28;
  # RANGE ~[971, 971]
  _31 = ivtmp_20 + 972;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _32 = _31 * 8;
  # PT = nonlocal escaped 
  _33 = aa.19_4 + _32;
  # VUSE <.MEM_42>
  _34 = *_33;
  _35 = _29 + _34;
  _36 = (intD.9) _35;
  _37 = (doubleD.39) _36;
  _38 = _35 - _37;
  _39 = (intD.9) ivtmp_20;
  # .MEM_45 = VDEF <.MEM_42>
  *ran_u_5[_39] = _38;
  # RANGE [1, 18446744073709551615]
  ivtmp_21 = ivtmp_20 + 1;
  if (_18 > ivtmp_21)
    goto <bb 8>;
  else
    goto <bb 7>;
;;    succ:       8 [100.0%]  (TRUE_VALUE,EXECUTABLE)
;;                7 (FALSE_VALUE,EXECUTABLE)

;;   basic block 7, loop depth 0, count 0, freq 0, maybe hot
;;    prev block 6, next block 8, flags: (NEW)
;;    pred:       6 (FALSE_VALUE,EXECUTABLE)
  # .MEM_43 = PHI <.MEM_45(6)>
  goto <bb 4>;
;;    succ:       4 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 8, loop depth 1, count 0, freq 2963, maybe hot
;;    prev block 7, next block 9, flags: (NEW)
;;    pred:       6 [100.0%]  (TRUE_VALUE,EXECUTABLE)
  goto <bb 6>;
;;    succ:       6 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 9, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 8, next block 1, flags: (NEW, REACHABLE)
;;    pred:       2 [25.0%]  (TRUE_VALUE,EXECUTABLE)
  # RANGE [1, 37] NONZERO 63
  q.23_13 = q.23_10 + 1;
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,EXECUTABLE)

}



;; Function <built-in> (void_ranf_array_double___int_._loopfn.1, funcdef_no=38, decl_uid=4071, cgraph_uid=7, symbol_order=49)


Pass statistics:
----------------


Pass statistics:
----------------

<built-in> (voidD.45 * .paral_data_paramD.4073)
{
  signed long graphite_IV.142D.4082;
  unsigned long tt.149D.4081;
  unsigned long q.148D.4080;
  doubleD.39 * aa.144D.4079;
  intD.9 j.143D.4078;
  struct  * .paral_data_load.147D.4077;
  doubleD.39[100] * ran_u_6;
  intD.9 _7;
  unsigned long _8;
  intD.9 _9;
  unsigned long _10;
  unsigned long _17;
  unsigned long _18;
  unsigned long _19;
  unsigned long ivtmp_21;
  unsigned long ivtmp_22;
  sizetype _28;
  sizetype _29;
  sizetype _30;
  doubleD.39 * _31;
  doubleD.39 _32;
  sizetype _37;
  doubleD.39 * _38;
  doubleD.39 _39;
  doubleD.39 _40;
  intD.9 _41;
  doubleD.39 _42;
  doubleD.39 _43;
  intD.9 _44;
  sizetype pretmp_74;

;;   basic block 2, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY (FALLTHRU,EXECUTABLE)
  # VUSE <.MEM_49(D)>
  j.143_4 = MEM[(struct  *).paral_data_param_1(D)].jD.4066;
  # VUSE <.MEM_49(D)>
  # PT = nonlocal escaped 
  aa.144_5 = MEM[(struct  *).paral_data_param_1(D)].aaD.4067;
  # VUSE <.MEM_49(D)>
  # PT = nonlocal escaped 
  ran_u_6 = MEM[(struct  *).paral_data_param_1(D)].ran_uD.4068;
  _7 = omp_get_num_threadsD.1718 ();
  # RANGE ~[2147483648, 18446744071562067967]
  _8 = (unsigned long) _7;
  _9 = omp_get_thread_numD.1717 ();
  # RANGE ~[2147483648, 18446744071562067967]
  _10 = (unsigned long) _9;
  # RANGE [0, 36] NONZERO 63
  q.148_11 = 36 / _8;
  # RANGE [0, 18446744073709551615]
  tt.149_12 = 36 % _8;
  if (_10 < tt.149_12)
    goto <bb 8>;
  else
    goto <bb 3>;
;;    succ:       8 [25.0%]  (TRUE_VALUE,EXECUTABLE)
;;                3 [75.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 3, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 2, next block 4, flags: (NEW, REACHABLE)
;;    pred:       8 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                2 [75.0%]  (FALSE_VALUE,EXECUTABLE)
  # RANGE [0, 37] NONZERO 63
  # q.148_13 = PHI <q.148_14(8), q.148_11(2)>
  # tt.149_15 = PHI <0(8), tt.149_12(2)>
  # RANGE ~[79456894940, 18446743994252656639]
  _17 = _10 * q.148_13;
  # RANGE [0, 18446744073709551615]
  _18 = tt.149_15 + _17;
  # RANGE [0, 18446744073709551615]
  _19 = q.148_13 + _18;
  if (_18 >= _19)
    goto <bb 4>;
  else
    goto <bb 5>;
;;    succ:       5 [100.0%]  (FALSE_VALUE,EXECUTABLE)
;;                4 (TRUE_VALUE,EXECUTABLE)

;;   basic block 4, loop depth 0, count 0, freq 0, maybe hot
;;    prev block 3, next block 5, flags: (NEW, REACHABLE)
;;    pred:       3 (TRUE_VALUE,EXECUTABLE)
;;                6 (FALSE_VALUE,EXECUTABLE)
  # .MEM_79 = PHI <.MEM_49(D)(3), .MEM_50(6)>
  # VUSE <.MEM_79>
  return;
;;    succ:       EXIT

;;   basic block 5, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 4, next block 6, flags: (NEW)
;;    pred:       3 [100.0%]  (FALSE_VALUE,EXECUTABLE)
  pretmp_74 = (sizetype) j.143_4;
;;    succ:       6 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 6, loop depth 1, count 0, freq 2963, maybe hot
;;    prev block 5, next block 7, flags: (NEW)
;;    pred:       5 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                7 [100.0%]  (FALLTHRU,EXECUTABLE)
  # RANGE [0, 18446744073709551614]
  # ivtmp_21 = PHI <_18(5), ivtmp_22(7)>
  # .MEM_47 = PHI <.MEM_49(D)(5), .MEM_50(7)>
  # DEBUG j.143D.4078 => NULL
  # RANGE [0, 18446744073709551615]
  _28 = ivtmp_21 + pretmp_74;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _29 = _28 * 8;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _30 = _29 + 18446744073709550816;
  # PT = nonlocal escaped 
  _31 = aa.144_5 + _30;
  # VUSE <.MEM_47>
  _32 = *_31;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _37 = _29 + 18446744073709551320;
  # PT = nonlocal escaped 
  _38 = aa.144_5 + _37;
  # VUSE <.MEM_47>
  _39 = *_38;
  _40 = _32 + _39;
  _41 = (intD.9) _40;
  _42 = (doubleD.39) _41;
  _43 = _40 - _42;
  _44 = (intD.9) ivtmp_21;
  # .MEM_50 = VDEF <.MEM_47>
  *ran_u_6[_44] = _43;
  # DEBUG j.143D.4078 => NULL
  # DEBUG j.143D.4078 => NULL
  # RANGE [1, 18446744073709551615]
  ivtmp_22 = ivtmp_21 + 1;
  if (_19 > ivtmp_22)
    goto <bb 7>;
  else
    goto <bb 4>;
;;    succ:       7 [100.0%]  (TRUE_VALUE,EXECUTABLE)
;;                4 (FALSE_VALUE,EXECUTABLE)

;;   basic block 7, loop depth 1, count 0, freq 2963, maybe hot
;;    prev block 6, next block 8, flags: (NEW)
;;    pred:       6 [100.0%]  (TRUE_VALUE,EXECUTABLE)
  goto <bb 6>;
;;    succ:       6 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 8, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 7, next block 1, flags: (NEW, REACHABLE)
;;    pred:       2 [25.0%]  (TRUE_VALUE,EXECUTABLE)
  # RANGE [1, 37] NONZERO 63
  q.148_14 = q.148_11 + 1;
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,EXECUTABLE)

}



;; Function <built-in> (int_rng_double_main__._loopfn.2, funcdef_no=40, decl_uid=4314, cgraph_uid=3, symbol_order=52)


Pass statistics:
----------------


Pass statistics:
----------------

<built-in> (voidD.45 * .paral_data_paramD.4316)
{
  signed long graphite_IV.310D.4323;
  unsigned long tt.315D.4322;
  unsigned long q.314D.4321;
  struct  * .paral_data_load.313D.4320;
  doubleD.39[2009] * a_4;
  doubleD.39[100] * ran_u_5;
  intD.9 _6;
  unsigned long _7;
  intD.9 _8;
  unsigned long _9;
  unsigned long _16;
  unsigned long _17;
  unsigned long _18;
  unsigned long ivtmp_20;
  unsigned long ivtmp_21;
  sizetype _26;
  sizetype _27;
  doubleD.39 * _28;
  doubleD.39 _29;
  sizetype _31;
  sizetype _32;
  doubleD.39 * _33;
  doubleD.39 _34;
  doubleD.39 _35;
  intD.9 _36;
  doubleD.39 _37;
  doubleD.39 _38;
  intD.9 _39;

;;   basic block 2, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 0, next block 3, flags: (NEW, REACHABLE)
;;    pred:       ENTRY (FALLTHRU,EXECUTABLE)
  # VUSE <.MEM_44(D)>
  # PT = nonlocal escaped 
  a_4 = MEM[(struct  *).paral_data_param_1(D)].aD.4310;
  # VUSE <.MEM_44(D)>
  # PT = nonlocal escaped 
  ran_u_5 = MEM[(struct  *).paral_data_param_1(D)].ran_uD.4311;
  _6 = omp_get_num_threadsD.1718 ();
  # RANGE ~[2147483648, 18446744071562067967]
  _7 = (unsigned long) _6;
  _8 = omp_get_thread_numD.1717 ();
  # RANGE ~[2147483648, 18446744071562067967]
  _9 = (unsigned long) _8;
  # RANGE [0, 36] NONZERO 63
  q.314_10 = 36 / _7;
  # RANGE [0, 18446744073709551615]
  tt.315_11 = 36 % _7;
  if (_9 < tt.315_11)
    goto <bb 9>;
  else
    goto <bb 3>;
;;    succ:       9 [25.0%]  (TRUE_VALUE,EXECUTABLE)
;;                3 [75.0%]  (FALSE_VALUE,EXECUTABLE)

;;   basic block 3, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 2, next block 4, flags: (NEW, REACHABLE)
;;    pred:       9 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                2 [75.0%]  (FALSE_VALUE,EXECUTABLE)
  # RANGE [0, 37] NONZERO 63
  # q.314_12 = PHI <q.314_13(9), q.314_10(2)>
  # tt.315_14 = PHI <0(9), tt.315_11(2)>
  # RANGE ~[79456894940, 18446743994252656639]
  _16 = _9 * q.314_12;
  # RANGE [0, 18446744073709551615]
  _17 = tt.315_14 + _16;
  # RANGE [0, 18446744073709551615]
  _18 = q.314_12 + _17;
  if (_17 >= _18)
    goto <bb 4>;
  else
    goto <bb 5>;
;;    succ:       5 [100.0%]  (FALSE_VALUE,EXECUTABLE)
;;                4 (TRUE_VALUE,EXECUTABLE)

;;   basic block 4, loop depth 0, count 0, freq 0, maybe hot
;;    prev block 3, next block 5, flags: (NEW, REACHABLE)
;;    pred:       3 (TRUE_VALUE,EXECUTABLE)
;;                7 [100.0%]  (FALLTHRU,EXECUTABLE)
  # .MEM_76 = PHI <.MEM_44(D)(3), .MEM_43(7)>
  # VUSE <.MEM_76>
  return;
;;    succ:       EXIT

;;   basic block 5, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 4, next block 6, flags: (NEW)
;;    pred:       3 [100.0%]  (FALSE_VALUE,EXECUTABLE)
;;    succ:       6 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 6, loop depth 1, count 0, freq 2963, maybe hot
;;    prev block 5, next block 7, flags: (NEW)
;;    pred:       5 [100.0%]  (FALLTHRU,EXECUTABLE)
;;                8 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)
  # RANGE [0, 18446744073709551614]
  # ivtmp_20 = PHI <_17(5), ivtmp_21(8)>
  # .MEM_42 = PHI <.MEM_44(D)(5), .MEM_45(8)>
  # RANGE ~[1908, 1908]
  _26 = ivtmp_20 + 1909;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _27 = _26 * 8;
  # PT = nonlocal escaped 
  _28 = a_4 + _27;
  # VUSE <.MEM_42>
  _29 = *_28;
  # RANGE ~[1971, 1971]
  _31 = ivtmp_20 + 1972;
  # RANGE [0, 18446744073709551615] NONZERO 18446744073709551608
  _32 = _31 * 8;
  # PT = nonlocal escaped 
  _33 = a_4 + _32;
  # VUSE <.MEM_42>
  _34 = *_33;
  _35 = _29 + _34;
  _36 = (intD.9) _35;
  _37 = (doubleD.39) _36;
  _38 = _35 - _37;
  _39 = (intD.9) ivtmp_20;
  # .MEM_45 = VDEF <.MEM_42>
  *ran_u_5[_39] = _38;
  # RANGE [1, 18446744073709551615]
  ivtmp_21 = ivtmp_20 + 1;
  if (_18 > ivtmp_21)
    goto <bb 8>;
  else
    goto <bb 7>;
;;    succ:       8 [100.0%]  (TRUE_VALUE,EXECUTABLE)
;;                7 (FALSE_VALUE,EXECUTABLE)

;;   basic block 7, loop depth 0, count 0, freq 0, maybe hot
;;    prev block 6, next block 8, flags: (NEW)
;;    pred:       6 (FALSE_VALUE,EXECUTABLE)
  # .MEM_43 = PHI <.MEM_45(6)>
  goto <bb 4>;
;;    succ:       4 [100.0%]  (FALLTHRU,EXECUTABLE)

;;   basic block 8, loop depth 1, count 0, freq 2963, maybe hot
;;    prev block 7, next block 9, flags: (NEW)
;;    pred:       6 [100.0%]  (TRUE_VALUE,EXECUTABLE)
  goto <bb 6>;
;;    succ:       6 [100.0%]  (FALLTHRU,DFS_BACK,EXECUTABLE)

;;   basic block 9, loop depth 0, count 0, freq 80, maybe hot
;;    prev block 8, next block 1, flags: (NEW, REACHABLE)
;;    pred:       2 [25.0%]  (TRUE_VALUE,EXECUTABLE)
  # RANGE [1, 37] NONZERO 63
  q.314_13 = q.314_10 + 1;
  goto <bb 3>;
;;    succ:       3 [100.0%]  (FALLTHRU,EXECUTABLE)

}


